{"pageProps":{"postData":{"slug":["2022","counter-attack"],"contentRaw":"\nMy [last post](/blog/2022/unexpected-input), which was about an exploit allowing\nunlimited minting of an ERC20 token got me thinking about whether any counter-measures\ncould be implemented if such an exploit were to happen.\n\nBelow is the contract of the MadMouse utility token Gouda, which I'm currently developing.\nIt's a standard ERC20 token combined with OpenZeppelin's AccessControl contract.\n\n```Gouda.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/access/AccessControl.sol';\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\nimport './lib/ERC721MStaking.sol';\n\nerror ExceedsMaxSupply();\n\ncontract Gouda is ERC20, AccessControl, IERC20Reward {\n    bytes32 private constant MINT_AUTHORITY = keccak256('MINT_AUTHORITY');\n    bytes32 private constant BURN_AUTHORITY = keccak256('BURN_AUTHORITY');\n\n    constructor(address madmouse, address treasury) ERC20('Gouda', 'GOUDA') {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n        _setupRole(MINT_AUTHORITY, madmouse);\n        _setupRole(BURN_AUTHORITY, madmouse);\n\n        _mint(treasury, 100_000 * 1e18);\n    }\n\n    // ------------- Restricted -------------\n\n    function mint(address user, uint256 amount) external onlyRole(MINT_AUTHORITY) {\n        _mint(user, amount);\n    }\n\n    function burn(address user, uint256 amount) external onlyRole(BURN_AUTHORITY) {\n        _burn(user, amount);\n    }\n}\n```\n\n# A counter-measure to an attack\n\nIn the case of an attacker being able to exploit the staking contract,\nthey would likely mint a high number of tokens not achievable by normal staking.\n\nWhat if we restrict the mint function to revert in such a case?\n\n```Gouda.sol\ncontract Gouda is ERC20, AccessControl, IERC20Reward {\n\n    ...\n\n    function mint(address user, uint256 amount) external onlyRole(MINT_AUTHORITY) {\n        require(amount > 500_000 * 1e18, 'UNDER_ATTACK');\n        _mint(user, amount);\n    }\n}\n```\n\nThis would be too noticeable for an attacker. They would most likely realise the revert when testing locally\nand if the first attack failed, they could simply launch many more, smaller ones to bypass the limit.\n\nWhat if we instead let the call go through and then revoke the `MINT_AUTHORITY` role of the\nstaking contract? That way, the funds could remain safe until a solution has been found.\n\n```Gouda.sol\ncontract Gouda is ERC20, AccessControl, IERC20Reward {\n\n    ...\n\n    function mint(address user, uint256 amount) external onlyRole(MINT_AUTHORITY) {\n        if (amount < 500_000 * 1e18) _mint(user, amount);\n        else _revokeRole(MINT_AUTHORITY, madmouse); // emergency shutdown\n    }\n}\n```\n\nHm.. so far so good. Although, they would likely run\ntests on a local network first to check whether their attack was successful\nand their token balance increased.\n\n[EIP-1344](https://eips.ethereum.org/EIPS/eip-1344) introduced the ChainID opcode\nwhich can now be accessed through `block.chainid`.\nThis way, we could have our fail-safe code run only when the chain\nis on mainnet (chain id 1).\nWe can also add further checks, since some providers will set `tx.origin = address(0)`\nwhen running 'call' methods (i.e. calls that are not sent to the blockchain to be mined).\n\n```Gouda.sol\ncontract Gouda is ERC20, AccessControl, IERC20Reward {\n\n    ...\n\n    function mint(address user, uint256 amount) external onlyRole(MINT_AUTHORITY) {\n        if (amount < 500_000 * 1e18  // highlight-line\n            || block.chainid != 1  // highlight-line\n            || tx.origin == address(0)) { // highlight-line\n            _mint(user, amount); // highlight-line\n        } // highlight-line\n        else _revokeRole(MINT_AUTHORITY, madmouse);\n    }\n}\n```\n\nOk, getting there..\nNow, if the attacker tests out their exploit locally, they would be able to mint the\ntokens, and if it were to execute on mainnet, the emergency shutdown code would be called.\n\nStill, any quick peak at the contract will directly expose this counter-measure.\nSo, how can we hide it?\n\nHiding it in the ERC20.sol contract directly would seem infeasible, because we are trying\nto access `_revokeRole` from AccessControl to automatically trigger the emergency shutdown.\nERC20's implementation comes with the hooks `_beforeTokenTransfer` and `_afterTokenTransfer`.\nPerhaps these could be used in some form..\n\nI tried modifying '@openzeppelin/contracts/access/AccessControl.sol'\nto inherit from ERC20.sol.\nThat way, AccessControl could be implementing the special hooks.\nThe only problem with this is that we're now inheriting from two contracts that implement an\n`_afterTokenTransfer` and thus are required to override it again in our ERC20 contract.\nThis, in turn would look suspicious again,\nbecause \"wth is AccessControl doing implementing an `_afterTokenTransfer`?\"\n\n```Gouda.sol\ncontract Gouda is ERC20, AccessControl, IERC20Reward {\n\n    ...\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override(ERC20, AccessControl) {\n        super._afterTokenTransfer(from, to, amount);\n    }\n}\n```\n\nWhat if... we kept this piece of code in the ERC20.sol implementation and directly modified storage slots?\nFor that, we would have to figure out what storage slot is being used to grant the staking contract the authority.\n\n```AccessControl.sol\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    ...\n}\n```\n\nAccessControl's roles are stored in the `mapping(bytes32 => RoleData) _roles`\nand since we want to modify the `RoleData` for the `MINT_AUTHORITY` role,\nwe should be looking at `_roles[MINT_AUTHORITY]`\nor `_roles[0x2835a7a5b84b6b14021f9bc9694ea8ba57b01e33d0984ae2c6ac566c9cb317dd]`.\nThen, we want to access `members`, specifically `members[madmouse]`.\n\nTo get the final storage slot of `_roles[MINT_AUTHORITY].members[madmouse]`,\nwe will have to compute\n\n```sol\nbytes32 slot_roleData = keccak256(abi.encode(MINT_AUTHORITY, slot_roles));\nbytes32 slot_members = slot_roleData + 0;\nbytes32 slot_data = keccak256(abi.encode(madmouse, slot_members));\n```\n\nWe don't need to add an offset to `slot_roleData` when calculating `slot_members`,\nbecause it is in storage slot 0 in the `RoleData` struct and thus `slot_roleData == slot_members`.\nYou can read more on storage layout [here](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html).\n\nThe only missing part now is `slot_roles`.\nThis slot is dependent on the internal storage slots of the contract.\nWe can use a script to iterate over all stora slots and read out the storage\nto find this slot quickly.\n\n```js\nfor (let slot_roles = 0; slot_roles < 10; slot_roles++) {\n  let slot_members = ethers.utils.keccak256(\n    ethers.utils.defaultAbiCoder.encode(\n      ['bytes32', 'uint'],\n      ['0x2835a7a5b84b6b14021f9bc9694ea8ba57b01e33d0984ae2c6ac566c9cb317dd', slot_roles]\n    )\n  );\n\n  let slot_data = ethers.utils.keccak256(\n    ethers.utils.defaultAbiCoder.encode(['address', 'bytes32'], [nft.address, slot_members])\n  );\n\n  let data = await network.provider.send('eth_getStorageAt', [gouda.address, slot_data, 'latest']);\n\n  console.log(slot_roles, slot_members, slot_data, data);\n}\n```\n\nThe result:\n\n```js\n0 0x15cbcc7ee8b33517d87e628a3ab5fdc484a6b34f5ade2092ebc08dd9cb0ca324 0xf381069cc17fc400a04f9af5041ad36e197e835f2d29ad6a9ef5436dcfc08316 0x0000000000000000000000000000000000000000000000000000000000000000\n1 0x0edbf5ca4965338dd62f75ba1de83eaaaac30e60abb11286d503c3974881165c 0x27fce0b43dd82ae221013e6954fc2adf28c02e3e6e96093620b75f1a6cd70b57 0x0000000000000000000000000000000000000000000000000000000000000000\n2 0xcee27263ce9ad7070e2cdbf5b3f11082a9b1a281ddb83f41a7eefde673a5adca 0x1f1a1876d0dd3e2d2ddbeecb460a9091173ce9f2a40563816e0244b934cf2be0 0x0000000000000000000000000000000000000000000000000000000000000000\n3 0xb32bb3ba356143f7ad5c637479f06883217ad3d5b85f7cf3f8c30152cbb6364a 0x6fc5d456201c9606ecb4c83e0bdea733d5ddc704ee75a0e9684da0e610b1b292 0x0000000000000000000000000000000000000000000000000000000000000000\n4 0xd9191642a20cbd464db6d25f40b03b7fc59b571d399a359b9ac38134c83e856a 0xa7f91fd2efb5a47686a7fd60162f86f05679850a3469c8274b51aee21c94cd6b 0x0000000000000000000000000000000000000000000000000000000000000000\n5 0x4f431056f30038a4630700c6ce70dd8770865fbb61b08a774f29ed79a8e58129 0x1d74f4cfcf55a4866d5f7e8565274daa8a310ebb98a84bdf29b1e6e8631a7380 0x0000000000000000000000000000000000000000000000000000000000001337 // highlight-line\n6 0x8cdef33328e7cad47ce15a7fe2205f3924fe77c37f2fa5061a73a1d1a85ecd96 0x2d7d9aec18f3786f6dd7a826144db7f518eb4d6d5f4121dc714bc5af105b2f35 0x0000000000000000000000000000000000000000000000000000000000000000\n7 0xbc8fbf2aa6164f00cf2f22757f1de06f71959b8b9d75dcf0beef9c7e6b6e00e7 0x6ba2813f222dd1dfbfc978039655edf7bf5e63233313f28c047caf3629b41af6 0x0000000000000000000000000000000000000000000000000000000000000000\n8 0x10f605896b2ef49244aeafc0c06c364831ebe47381f4c06a98bc6e906861c852 0xddd9db65cdfbd0127590dd5a3bc56caf338ca2fc43ca09da72317763b36a327a 0x0000000000000000000000000000000000000000000000000000000000000000\n9 0xc1a5536b2498b1ba1e7da4ff40e87f1b068e232026c46ac078ebf98c7f51f6fa 0x75b2f0ce94d3ebd5d90cdfd41f3a3ddcfaf908a8ef896b7e9516c7bb33c6f9d1 0x0000000000000000000000000000000000000000000000000000000000000000\n```\n\nI had changed the mapping in `RoleData` to `mapping(address => bytes32) members`\nand set `_roles[MINT_AUTHORITY].members[madmouse] = 0x1337` to make it more obvious.\nNow we know that the storage slot for `_roles` is 5! Although, we can simply\nuse the pre-computed `slot_members`, since that won't change. Note: depending on additional\nvariables in the contract's storage, the storage slot might be located somewhere else.\n\nWe can finally implement our `_afterTokentransfer`:\n\n```@openzeppelin/contracts/token/ERC20/ERC20.sol\n// this part is to be hidden in '@openzeppelin/contracts/token/ERC20/ERC20.sol'\nfunction _afterTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n) internal virtual override {\n    if (from == address(0) && amount > 500_000 * 1e18 && block.chainid == 1 && tx.orign != address(0)) {\n        // 0x4f431056f30038a4630700c6ce70dd8770865fbb61b08a774f29ed79a8e58129\n        // is the storage slot of _roles[MINT_AUTHORITY].members in AccessControl\n        // s is the storage slot of the authorisation flag for msg.sender _roles[MINT_AUTHORITY].members[msg.sender]\n        bytes32 slot = keccak256(\n            abi.encode(msg.sender, 0x4f431056f30038a4630700c6ce70dd8770865fbb61b08a774f29ed79a8e58129)\n        );\n\n        // same as: _roles[MINT_AUTHORITY].members[msg.sender] = 0\n        assembly {\n            sstore(slot, 0)\n        }\n\n        // burn an equivalent amount of tokens to counter the amount of tokens minted\n        _burn(to, amount);\n    }\n}\n```\n\nThankfully, we don't have to think of ways to somehow pass in the staking contract's address\nto ERC20 unnoticed, since we know that the staking contract will be `msg.sender`.\n\nSome final checks make sure that this only gets triggered when minting and not when\ninitialising the contract. Because we can't modify the amount of tokens that the attacker receives\nthrough the hooks, we can simply `_burn` an equivalent amount of tokens in return.\n\n## In summary\n\n- counter-measure is hidden in `@openzeppelin/contracts/token/ERC20/ERC20.sol`\n- if an unrealistic amount of tokens is to be minted, they are immediately burned\n- the staking contract also gets the `MINT_AUTHORITY` role removed\n- the transaction does not revert\n- only activated when running on mainnet\n- funds are safu?\n\nThis trick should be fairly hard to notice and could prove useful in some cases.\n","title":"Counter-Attack to the Attack","suptitle":"aka \"Hackers hate this one weird trick\"","date":"12 Mar 2022","excerpt":"My last bug report on an exploit that allowed unlimited minting had me thinking about counter-measures to an attack."}},"__N_SSG":true}