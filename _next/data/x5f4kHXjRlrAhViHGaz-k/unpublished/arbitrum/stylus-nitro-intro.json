{"pageProps":{"postData":{"slug":["unpublished","arbitrum","stylus-nitro-intro"],"contentRaw":"\n# Nitro\n\n```\nbrew link go@1.20\nmake build\nmake wasm-ci-build\n```\n\n- Builds `brotli` (`cmake`, `cc`)\n- Builds `jit` (`cargo`)\n- Compiles `contracts` (`yarn`, `forge`, `solc`)\n- Builds `nitro` (`go`)\n\nThe `make all` command in Nitro's Makefile triggers a sequence of build and test processes. Specifically, it executes the following high-level tasks:\n\n1. **Build Executables and Components (`build`)**:\n\n   - This is a complex step involving multiple executables and components. The rule targets several binaries including `nitro`, `deploy`, `relay`, `daserver`, `datool`, `seq-coordinator-invalidate`, `nitro-val`, and `seq-coordinator-manager`. These are all built from their respective Go source files (`$(go_source)`) located in various directories (`$(repo_dirs)`). It is likely that Goâ€™s cross-compilation is leveraged for building specific architectures. This step utilizes conditional linking flags (`$(GOLANG_PARAMS)`) potentially defined by the environment to embed versioning or other metadata into the binaries.\n\n2. **Set Up the Replay Environment (`build-replay-env`)**:\n\n   - Constructs the necessary environment for replaying blockchain transactions or similar events. This step compiles a WebAssembly binary (`$(replay_wasm)`) using Go, targeting the JavaScript/WebAssembly architecture. Additional components included are various `.wasm` libraries and a compressed machine representation (`machine.wavm.br`). These components are likely used for simulating or analyzing blockchain behavior in a controlled environment.\n\n3. **Generate Proof Tests (`test-gen-proofs`)**:\n   - Generates proofs based on test cases written in WebAssembly text format (`.wat`) and Rust (`.rs`). This step transforms test cases into JSON formatted proof outputs that likely represent transaction validations or other proof verifications crucial for blockchain operations. This utilizes the prover executable (`$(arbitrator_prover_bin)`) to handle the transformation and proof generation.\n\nEach of these primary tasks has detailed dependencies which are handled by other rules in the Makefile:\n\n- **Dependency Management**:\n  - Uses variables like `$(DEP_PREDICATE)` and `$(ORDER_ONLY_PREDICATE)` to manage dependencies especially in environments where Docker might affect file timestamps. The conditional setting of these variables controls whether dependencies are considered as order-only (ignoring timestamp changes).\n- **Dynamic Linking Flags**:\n\n  - Conditional rules add flags to `GOLANG_LDFLAGS` based on environment variables, affecting how Go binaries are linked during the build process. This could include embedding the build version, date, and whether the source code has been modified.\n\n- **Auxiliary Build Processes**:\n\n  - Other targets in the Makefile handle building WebAssembly libraries, managing Rust dependencies, formatting code, and running linters. These support the main build and testing processes.\n\n- **Environment and Configuration**:\n  - Various environment variables (like `WASI_SYSROOT`) and configuration settings influence how binaries and libraries are built, particularly for targeting different platforms like WebAssembly.\n\nFinally, after completing these primary tasks (`all` target), a file named `.make/all` is touched to signify that the `all` target has successfully completed, serving as a marker for dependency management in future builds.\n\nOverall, the `make all` command coordinates building the software, setting up necessary environments for transaction replay, and generating test proofs crucial for ensuring the correctness and reliability of blockchain-related operations managed by this software.\n\n# Testing\n\n## Arbitrator\n","title":"First steps to running Arbitrum Stylus","date":"May 1, 2024","suptitle":"An auditor's guide to Arbitrum Stylus"}},"__N_SSG":true}