{"pageProps":{"postData":{"slug":["blog","2022","abi-decoding-calldata"],"contentRaw":"\n`abi.decode(data, (type))` can be used to decode abi-encoded bytes located in memory and calldata. Currently, it's only possible to assign dynamic types to memory. Decoding to calldata is not supported yet, however, this can still be achieved manually.\n\nSay we wanted to send a NFT cross-chain. For this we have have to encode a message that could look like this.\n\n```FxERC721Root.sol\nbytes4 constant REGISTER_ERC721_IDS_SELECTOR = \n    bytes4(keccak256(\"registerERC721IdsWithChild(address,uint256[])\"));\n\n    function _registerERC721IdsWithChild(address to, uint256[] calldata ids) internal virtual {\n        bytes memory message = abi.encodeWithSelector(REGISTER_ERC721_IDS_SELECTOR, to, ids); // highlight-line\n\n        _sendMessageToChild(message);\n    }\n```\n\nThe child chain can receive the full message as `calldata`, run some security checks and then process it in another function.\n\n\n```FxERC721Child.sol\n    function processMessageFromRoot(\n        uint256 stateId,\n        address rootMessageSender,\n        bytes calldata message // highlight-line\n    ) external {\n        if (msg.sender != fxChild) revert CallerNotFxChild();\n        if (rootMessageSender == address(0) || rootMessageSender != s().fxRootTunnel) revert InvalidRootSender();\n\n        _processMessageFromRoot(stateId, rootMessageSender, message);\n    }\n```\n\nSolidity does not allow us to decode the ids as a `uint256[] calldata` array directly yet. I.e. the following \n```solidity\n    (address to, uint256[] calldata ids) = abi.decode(message[4:], (address, uint256[]));\n```\nwould fail with the message:\n`\"TypeError: Type uint256[] memory is not implicitly convertible to expected type uint256[] calldata.\"`\n\nHowever, by declaring `uint256[] calldata ids;` and manually setting `ids.offset` and `ids.length` via assembly, we can manually decode the data.\nFor more on the abi encoding spec, read up on the [docs](https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#argument-encoding).\n\n```FxERC721Child.sol\n    function _processMessageFromRoot(\n        uint256,\n        address,\n        bytes calldata message\n    ) internal virtual override {\n        bytes4 selector = bytes4(message);\n\n        if (selector != REGISTER_ERC721_IDS_SELECTOR) revert InvalidSelector();\n\n        address to = address(uint160(uint256(bytes32(message[4:36]))));\n\n        uint256[] calldata ids;\n        // abi-decode `ids` directly in calldata.\n        assembly {\n            // Skip bytes4 selector + bytes32 encoded address\n            // starting from message's offset in calldata\n            // to get the relative offset of the uint256[] encoded array's size.\n            let idsLenOffset := add(add(message.offset, 0x04), calldataload(add(message.offset, 0x24)))\n            ids.length := calldataload(idsLenOffset)\n            ids.offset := add(idsLenOffset, 0x20)\n        }\n\n        _registerIds(to, ids);\n    }\n\n    function _registerIds(address to, uint256[] calldata ids) internal virtual {\n        for (uint256 i; i < ids.length; ++i) {\n            _registerId(to, ids[i]);\n        }\n    }\n```\n\nHere's an example of a call to the function `processMessageFromRoot()`.\n\n```sol\n    child.processMessageFromRoot(\n        1,\n        address(this),\n        abi.encodeWithSelector(REGISTER_ERC721_IDS_SELECTOR, address(0xbabe), 31.range(34))\n    );\n```\n\nIn this case, the calldata would look like this.\n\n```sol\n  [selector] 0x9a7c4b71 // processMessageFromRoot.selector\n  [0x00] 0000000000000000000000000000000000000000000000000000000000000001 // stateId\n  [0x20] 000000000000000000000000b4c79dab8f259c7aee6e5b2aa729821864227e84 // rootMessageSender\n  [0x40] 0000000000000000000000000000000000000000000000000000000000000060 // message.length offset\n  [0x60] 00000000000000000000000000000000000000000000000000000000000000c4 // message.length\n  [0x80] 4d26d408000000000000000000000000000000000000000000000000000000000000babe00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000001f0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002100000000000000000000000000000000000000000000000000000000 // encoded message\n```\n\n> Note: Even though the message length is located at message[0x64:0x84] the offset (of message.length) is set to 0x60, since the selector is not counted.\n\nBecause the message is abi-encoded separately, the offsets in the encoded bytes are relative to the start of the message after the selector.\n\n```sol\n  [selector] 0x4d26d408 // REGISTER_ERC721_IDS_SELECTOR\n  [0x00] 000000000000000000000000000000000000000000000000000000000000babe // address to\n  [0x20] 0000000000000000000000000000000000000000000000000000000000000040 // ids.length relative offset\n  [0x40] 0000000000000000000000000000000000000000000000000000000000000003 // ids.length\n  [0x60] 000000000000000000000000000000000000000000000000000000000000001f // ids[0]\n  [0x80] 0000000000000000000000000000000000000000000000000000000000000020 // ids[1]\n  [0xa0] 0000000000000000000000000000000000000000000000000000000000000021 // ids[2]\n  [0xc0] 00000000000000000000000000000000000000000000000000000000 // padded zeros\n```\n\nThis means that, if we want to get the correct calldata offset for `ids.offset`, we need\nto load the word located at 0x20 in the encoded message. In order to get the absolute position in the calldata, we thus need to add the offset of the message in the calldata to 0x24 - the 4 bytes selector from the message must be taken into account, since the message is embedded into the calldata as bytes.\n\n```sol\n    let idsOffsetRel := calldataload(add(message.offset, 0x24))\n```\n\nNow to get the absolute offset of `ids.length` we need to add the position of where the relative offset in the message starts: `message.offset + 0x04` - the starting location of the message + the encoded selector.\n\n```sol\n    let idsLenOffset := add(add(message.offset, 0x04), idsOffsetRel)\n```\n\nNow that we have the offset of the length, we just need to load it from the calldata. By looking at the encoding we can also see that we simply need to add one word (0x20) to find the start of the `uint256[]` data - `ids.offset`.\n\n```sol\n    ids.length := calldataload(idsLenOffset)\n    ids.offset := add(idsLenOffset, 0x20)\n```\n\n## Why not just hardcode the offset?\n\nWe could also simply hardcode the values for `ids.length` and `ids.offset` after we have calculated them once. \n\n```sol\n    ids.offset := 0xe8\n    ids.length := calldataload(sub(ids.offset, 0x20))\n```\n\nThis works as long as the function signature won't change (so that the offset of `message` doesn't change) and the calldata is encoded in a standard way.\n\nWe can create a non-standard encoding by adding useless filler data for example and we quickly see why the hardcoded version will not work anymore.\n\n```sol\n    address(child).call(\n        hex\"9a7c4b71\"                                                         // processMessageFromRoot.selector\n        hex\"0000000000000000000000000000000000000000000000000000000000000001\" // stateId\n        hex\"000000000000000000000000b4c79dab8f259c7aee6e5b2aa729821864227e84\" // rootMessageSender\n        hex\"0000000000000000000000000000000000000000000000000000000000000080\" // message.length offset\n        hex\"ccaaffeeccaaffeeccaaffeeccaaffeeccaaffeeccaaffeeccaaffeeccaaffee\" // ??\n        hex\"00000000000000000000000000000000000000000000000000000000000000e4\" // message.length\n        hex\"4d26d408\"                                                         // REGISTER_ERC721_IDS_SELECTOR\n        hex\"000000000000000000000000000000000000000000000000000000000000babe\" // address to\n        hex\"0000000000000000000000000000000000000000000000000000000000000060\" // ids.length relative offset\n        hex\"ccaaffeeccaaffeeccaaffeeccaaffeeccaaffeeccaaffeeccaaffeeccaaffee\" // ??\n        hex\"0000000000000000000000000000000000000000000000000000000000000003\" // ids.length\n        hex\"000000000000000000000000000000000000000000000000000000000000001f\" // ids[0]\n        hex\"0000000000000000000000000000000000000000000000000000000000000020\" // ids[1]\n        hex\"0000000000000000000000000000000000000000000000000000000000000021\" // ids[2]\n        hex\"00000000000000000000000000000000000000000000000000000000\"         // padded zeros\n    );\n```\n\nWithout hardcoding the offsets, reading the `uint256[] calldata` from the above encoding will still be possible.\n\n\n\n\n# Gas Savings\n\nAbi-decoding directly to calldata can avoid copying data to memory.\nThis saves us a few `mstore` and `mload` operations.\nBelow is a comparison of the gas savings for encoding a certain number of ids.\n\n\n| #ids | Calldata | Memory | Difference |\n| --- | --- | --- | ---- |\n| 0 | 1125 |1552 | 427 |\n| 1 | 2271 |2775 | 504 |\n| 2 | 3197 |3781 | 584 |\n| 3 | 4126 |4790 | 664 |\n| 4 | 5050 |5794 | 744 |\n| 5 | 5977 |6801 | 824 |\n| 6 | 6904 |7809 | 905 |\n| 7 | 7835 |8820 | 985 |\n| 8 | 8760 |9825 | 1065 |\n| 9 | 9694 |10839 | 1145 |\n\n\nIn this case, using calldata over memory can save us 427 gas + roughly an additional 80 gas per extra word.","title":"ABI-Decoding Calldata","date":"Oct 22, 2022","excerpt":"Abi-decode directly in calldata without using memory."}},"__N_SSG":true}