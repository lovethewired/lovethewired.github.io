{"pageProps":{"postData":{"slug":["audit","2022","haki-audit"],"contentRaw":"\n\n# Table of Contents\n\n# Context\n\nThe audit was performed as a \"non-extensive review\".\nThis means that solely the code is reviewed as is\nand no further tests have been prepared for this review.\nUnit-tests are essential for ensuring correct behavior and calculations.\n\nThis audit is a review of the [Haki staking contracts](https://github.com/rekttdoteth/haki-staking-contract)\n(currently private repository)\nand was performed at commit\n[77865daafe1311dd45ad29bb8087f55fdc660c54](https://github.com/rekttdoteth/haki-staking-contract/commit/77865daafe1311dd45ad29bb8087f55fdc660c54).\n\nThe given repository itself contains no tests.\n\n**Focus:**\n\nGas optimizations (specifically storage accesses) \non `TheShrine.sol` (to be deployed on Ethereum) are highlighted, whereas they are largely ignored for `ShrineToken.sol` (to be deployed on Polygon).\n\nSpecial attention was given to unauthorized access-control and exploitability. Logical errors were covered as best as possible,\nalthough these require extensive unit-testing to cover appropriately.\n\n# Overview\n\nThe client has designed contracts that allow for staking of ERC721 NFTs.\nWhile the staking itself will be performed on Ethereum, \nstaking rewards are emitted as ERC20 tokens on Polygon.\nThe communication between the chains is done using Polygon's \n[flexible portal contracts](https://github.com/fx-portal/contracts).\nStaking on Ethereum is handled by\n`TheShrine.sol` which is designed to be able to handle multiple ERC721 contracts.\n`ShrineToken.sol` is an ERC20 token on Polygon that contains logic\nto handle state updates from the root contract `TheShrine.sol`.\n`SekiraVerifier.sol` acts as a simple \"proxy\" that allows counting owned and staked NFT balances for the _Sekira_ contract.\n\n\n# Scope\n\nThe repository contains the following contracts\n```ml\n└── contracts\n    ├── ERC20.sol\n    ├── ExitPayloadReader.sol\n    ├── FxBaseChildTunnel.sol\n    ├── FxBaseRootTunnel.sol\n    ├── Merkle.sol\n    ├── MerklePatriciaProof.sol\n    ├── RLPReader.sol\n    ├── SekiraVerifier.sol\n    ├── ShrineToken.sol\n    └── TheShrine.sol\n```\n\nAs a basis for the ERC20 contract, `ShrineToken.sol` uses Rari-Capital solmate's [ERC20 implementation](https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol) `ERC20.sol`.\nNo noteworthy differences to the [latest commit](https://github.com/Rari-Capital/solmate/commit/25015a1d18e75921f8cb1bacd4beb9f364e788a9) exist.\n\nPolygon's [flexible portal contracts](https://github.com/fx-portal/contracts)\nare being used for message passing between Ethereum and Polygon.\nNo noteworthy differences to the [latest commit](https://github.com/fx-portal/contracts/commit/baed24d22178201bca33140c303e0925661ec0ac) exist.\n\nThese external contracts are out of scope.\nThe focus of the review is narrowed down to the following contracts.\n\n```ml\n└── contracts\n    ├── SekiraVerifier.sol\n    ├── ShrineToken.sol\n    └── TheShrine.sol\n```\n\n# Summary\n\nNo critical errors were identified.\n\nThe contracts could benefit from simplification\nto reduce complexity, computation and storage access.\nFurthermore, although not explicitly detailed,\nrepetition of contract logic/functions can be avoided.\nThis would also help validate logic and improve readability.\nIt is further noted that the use of custom errors vs. require-statements could chosen consistently and docstring comments could be standardized.\n\n# Audit Findings Classifications\n\n# Medium Findings\n\n## :zap: [ShrineToken.sol] State-Desync Possible\n\nCurrently `ShrineToken.sol` gets relative balance updates from the root contract `TheShrine.sol` on Ethereum.\nA complete synchronization between the two chains is not guaranteed and incoming tokens are not validated to be uniquely counted in \n`userInfo.stakedBalance` and `userInfo.stakedIds`. \n\nSetting the child contract `ShrineToken.sol` to be paused\nwould lead to failed transactions and a state-desync when `_processMessageFromRoot` is called.\nThis would mean that, for example, unstaking on Ethereum L1\nwould not be updated on L2.\n\nThe results of this effect, however, are minimized due to the way \nrewards are being calculated.\nWhen claiming rewards, the ids found in `userInfo.stakedIds`\nare iterated over and the reward is calculated based on the\n`record` found for each individual id. The individual id is immediately \"marked\" as claimed by updating `stakeRecord.lastClaimed`.\n\nThis does, however, still mean that it could be possible for a user to claim\nrewards for an NFT no longer owned, even if it is currently being\nstaked by someone else. Additionally, this could lead to a higher `multipleStakedBoostThreshold`.\n\n**Mitigation:**\nNew token ids being registered in the `ShrineToken` contract could\ncheck whether they are currently still attributed to someone else\nin the system. If they are, they should be removed from that user's\nbalance/stake.\n\n\n## :zap: [TheShrine.sol] Hardcoded Testnet Address \n\n```TheShrine.sol\n    function balanceOf(address owner) external view returns (uint256) {\n        address hakiContract = 0xd053b4FdbC3470E6aAF9f65ED13AFDaA5af0d7E5; //highlight-line\n        return\n            addressToContractStakedIds[owner][hakiContract].length +\n            ERC721(hakiContract).balanceOf(owner);\n    }\n```\n\n`TheShrine.sol` contains a hardcoded `address hakiContract` which does not correspond to `address hakiERC721` of the constructor. This address currently only contains code on test-nets.\n\n**Mitigation:**\nUpdate address pointing to the correct ERC721 contract on Ethereum or declare a variable that is set\nby the constructor parameter.\n\n\n# Minor Findings\n\n## :zap: [FxBaseRootTunnel.sol] Unprotected Function\n\n_Note: Originally declared as out of scope._\n\n```FxBaseRootTunnel.sol\n    function setFxChildTunnel(address _fxChildTunnel) public virtual { //highlight-line\n        require(fxChildTunnel == address(0x0), \"FxBaseRootTunnel: CHILD_TUNNEL_ALREADY_SET\");\n        fxChildTunnel = _fxChildTunnel;\n    }\n```\n\n`setFxChildTunnel` does not contain any access-control. Anyone is able to call this function. Although, once set, it cannot be changed due to the contract logic. Any malicious address is able to call this and essentially void the full contract if accidentally left unset.\nThis generally should be seen as bad practice, even if introduced by the Matic-Team.\n\n**Mitigation:**\nOverride function in inheriting contract `TheShrine.sol` and add the `onlyOwner` modifier.\nA check for whether it has been set already is not strictly necessary, otherwise this could be marked as immutable, furthermore ensuring that it is set and reducing gas costs.\n\n```TheShrine.sol\n    function setFxChildTunnel(address _fxChildTunnel) public override onlyOwner { //highlight-line\n        fxChildTunnel = _fxChildTunnel;\n    }\n```\n\n_Note:_\nThe same holds for `setFxRootTunnel` in `FxBaseChildTunnel.sol`.\n\n\n## :recycle: [ShrineToken.sol] Reduce Use of Permits\n\n`gaslessHarvest` and `gaslessHarvestByNFT` allow an authorized party\nto distribute pending rewards to a user.\nThese function are currently guarded by the `onlyHarvester` modifier\nonly allowing calls by previously authorized accounts.\n\n**Mitigation:**\nSince `_harvestReward` does not contain any security-critical\nlogic, this extra authorization could be foregone to increase simplicity.\n\n\n## :recycle: [ShrineToken.sol] Reduce Logic for Tracking Staked Contracts\n\n`_processMessageFromRoot` keeps track contracts a user\nhas any staked balances separately through the use of an 'enumerable set'\nstructure. This is done via the mapping `addressToContractIndex`\nthat keeps track of multiple values, including an index to `userInfo.stakedContract`. There are multiple variables that are being tracked\nthat could be redundant.\n\n\n**Mitigation:**\nTo reduce complexity, `addressToContractIndex` and `userInfo.stakedContract` could be removed and logic could be simplified:\nInstead of iterating over the `userInfo.stakedContract` array,\nlooping over both contracts and checking `userInfo.stakedIds[collection].length` would reduce complexity.\n\nA lot of the \"messy\" logic for enumerable sets can be hidden by using\ntrusted libraries, like [OpenZeppelin's Enumerable Set](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol).\n\n## :recycle: [TheShrine.sol] Nearly Identical Logic\n\n`stake` & `stakeMultiple` (and `unstake` & `unstakeMultiple`) largely contain the same code.\nThere is very little gas overhead involved when simply using `stakeMultiple`, `unstakeMultiple`,\nas these would likely involve only a few more stack-operations.\nRemoving duplicate code, reduces maintenance work and \nsimplifies interfacing the contract on a frontend\ndue to multiple choices of functions being considered.\n\n**Mitigation:**\nConsider removing `stake` and `unstake` functions.\n\n## :recycle: [TheShrine.sol] Reduce External Calls\n\n`_sendMessageToChild` is being called in a loop requiring multiple external calls (& memory accesses, event emissions).\n\n**Mitigation:**\nConsider directly encoding an array of token ids thus only requiring one message to be sent.\n\n```TheShrine.sol\n    _sendMessageToChild(\n        abi.encode(\n            msg.sender,\n            collection,\n            tokenIds[i], //del-line\n            tokenIds, //add-line\n            lockupDelta,\n            true\n        )\n    );\n```\n\n## :recycle: [TheShrine.sol] Optimize Storage Reads/Writes\n\nCurrently `TheShrine.sol` keeps track of token ownerships through the use of 3 mappings:\n- `contractToTokenStaker` (tracks token ownership)\n- `addressToContractStakedIds` (enumerable list of ids per user)\n- `contractToTokenIndex` (tracks indices in enumerable list)\n\nThis is comparable to `ERC721Enumerable` vs. `ERC721` (logic-wise and storage cost-wise). Reducing these mappings to one would simplify logic\nand lower gas costs.\n\n**Mitigation:**\nThe contract could simply track `contractToTokenStaker` (token ownerships) and balances.\n\n*Note:*\nBecause `contractToTokenIndex` is a mapping to a list, keeping track of ownerships\nin the `stake` function update involves 4 distinct storage slots,\nwhereas, if optimized, it would only involve one.\nThis would also remove the complexity of keeping track of and re-arranging indices.\n\n*Further Note:*\nBecause `contractToTokenIndex` and `unlockOn` share the same mapping keys, these\ncould further be combined into one packed storage slot instead of taking up 2 separate slots.\n\n\n\n## :recycle: [SekiraVerifier.sol] Remove Unused Logic\n\n`SekiraVerifier.sol`'s code size can be significantly reduced. This contract acts as a simple proxy that propagates owned balances and staked balances of the _Sekira_ ERC721. It does not require any of the existing ERC721 logic, as it is never expected to be called (there exists no logic for minting tokens).\nThe only function that is necessary is `balanceOf`.\n\n**Mitigation:**\nConsider removing the ERC721 logic in order to save gas costs for deployment.\n\n\n## ️️:recycle: [FxBaseRootTunnel.sol] Make Non-Changing Variables Immutable\n\n_Note: Originally declared as out of scope._\n\n```FxBaseRootTunnel.sol\n    // state sender contract\n    IFxStateSender public fxRoot; //delete-line\n    IFxStateSender public immutable fxRoot; //add-line\n    // root chain manager\n    ICheckpointManager public checkpointManager; //delete-line\n    ICheckpointManager public immutable checkpointManager; //add-line\n    // child tunnel contract which receives and sends messages\n    address public fxChildTunnel;\n```\n`IFxStateSender fxRoot` and `ICheckpointManager checkpointManager`\nare declared as storage variables that do not contain logic to be changed/updated in any form.\n\n**Mitigation:**\nThese variables can be declared _immutable_ saving roughly 4200 gas.\n\n_Note_: `address fxChildTunnel` is not part of the constructor variables, as it requires the address of the child contract on Polygon to be set.\nIt is, however, possible to first deploy the child contract or to\npre-compute the address. This way `fxChildTunnel` could also be declared\n_immutable_ saving a total of 6300 gas.\n\n\n# Audit Disclaimer","title":"Haki/Sekira Contract Audit","date":"21 Jun 2022","unpublished":true}},"__N_SSG":true}