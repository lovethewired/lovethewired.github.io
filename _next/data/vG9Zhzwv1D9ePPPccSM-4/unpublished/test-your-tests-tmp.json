{"pageProps":{"postData":{"slug":["unpublished","test-your-tests-tmp"],"contentRaw":"\nPRB:\n\n- start with naming conventions\n- structure\n- unit vs integration vs fuzz vs fork (foundry book)\n- english specification\n- contract inheritance (Base.t.sol)\n\nTests are written in order to give a higher confidence about a function's behavior. This is all the more important when writing high assurance software, like smart contracts that could end up handling millions of dollars on a immutable ledger.\n\nWhen writing tests, they should be dealt with in a similar manner as runtime code. By that I mean that we should be thinking about what control-flow paths are being covered and what kind of assurance can be given for the function's behavior on what range of inputs. Inputs and edge-cases that are not covered should be considered without any behavioral guarantees.\n\nLet's look at some examples to make this less obscure.\n\n# Recommendations\n\n## Arrange Act Assert\n\n- **Guarantees for function execution or reversion for all possible input ranges:**\n  It's essential to know under what conditions a function passes and when it reverts. If we don't have any guarantees on the successful execution or failure of the function and this is not obviously detected in other tests, then all of our tests might appear meaningless.\n- **Correctly constraining input values:**\n  We don't want zero or low coverage on tests. Ideally (and I think in almost all cases we can), we should be able to explicitly define the input ranges for which the properties hold and constrain our inputs to those ranges without discarding tests. This ensures that we get sufficient coverage for those properties.\n- **Reverts should be explicitly handled or seen as test-failures:**\n  This is my biggest pain-point. Assertion mode makes sense for exploring large and complex stateful code, but I think it has little justification for these kind of stateless tests. We do not want silent reverts. We need the assurance that the test has successfully executed and we need to be explicit about when it reverts. At the moment it seems like the best solution is to run a campaign in `dapptest` mode.\n- **Avoid testing trivial properties:**\n  There are some trivial properties that are being checked. If we can clearly define one counter-cases where the property does not hold, then it is at least not trivial.\n- **Testing complex helper functions:**\n  The helper functions in this test suite are sufficiently complex to warrant tests themselves. I don't think that they all work as expected. The requirements of the helper functions should be made clear and if they are not satisfied, this should be immediately reported as a test-failure. Not checking these requirements for helper functions will end up as foot-guns when writing tests.\n- **Testing one property at a time:**\n  It's easier to track and comprehend tests that focus on a single property at a time. This also helps avoiding unintended interactions with multiple properties or early exits. It also helps when constraining inputs and their edge cases.\n- **Minimizing nested 'if' statements in tests:**\n  Nested 'if' conditions can be difficult to understand and prone to errors. We should consider early returns or breaking up tests into smaller, more manageable parts.\n- **Tight testing bounds:**\n  Tests that check for bounds should be tight, meaning an expansion of the bound should result in test failure. The edges of these bounds should be explicitly tested for the counter-case to ensure that the bounds are valid.\n\nThe rest shows some examples in the code.\n\n### Ensuring function execution success\n\nA big problem with the current test setup that I see is that it looks like the any of the ABDKMath functions could revert and the tests would pass nonetheless. E.g. the functions could be\n\n```solidity\nfunction add(int128 x, int128 y) internal pure returns (int128) {\n    revert();\n}\n```\n\nand many tests would still pass. It might sound trivial that it won't happen in this case, but it is less obvious for more complex functions. Also reversions can occur through division by zero checks or similar or through developer mistakes.\n\nThere is the coverage report, however inspecting it is cumbersome when prototyping tests or the library itself. It also doesn't report how often a path was taken, so it could be that there is one trivial case that is executed for the function and all other cases revert.\n\n### Testing trivial statements\n\nThe function `mul_test_range` tests the output range of the returned value from the `mul` function.\n\n<!-- gh-embed:crytic:properties:d3855861df5ff2f87fe2157de60417f9fc8cb4e3:contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol:583:593 -->\n\n**[ABDKMath64x64PropertyTests.sol](https://github.com/crytic/properties/blob/d3855861df5ff2f87fe2157de60417f9fc8cb4e3/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L583-L593)**\n\n```sol\n// The result of the multiplication must be between the maximum\n// and minimum allowed values for 64x64\nfunction mul_test_range(int128 x, int128 y) public view {\n    int128 result;\n    try this.mul(x, y) {\n        result = this.mul(x, y);\n        assert(result <= MAX_64x64 && result >= MIN_64x64);\n    } catch {\n        // If it reverts, just ignore\n    }\n}\n```\n\nWhen translating what the test covers back into natural language, it tests that \"if the mul function is successful, then my output should be in the valid range, if it reverts, then that's ok\". The problem I see with this function is that the output of the `mul` function is a `int128` and the range that is being tested is essentially `type(int128).min <= int128(result) <= type(int128).max`. This test is trivial and does not give any meaningful result. I also find the syntax to be hard to read and it could be simplified to this:\n\n```solidity\n    function mul_test_range(int128 x, int128 y) public view {\n        int128 result = this.mul(x, y);\n        assert(result <= MAX_64x64 && result >= MIN_64x64);\n    }\n```\n\nThough again, this test will always pass, regardless of the implementation of `mul`.\n\n### Not all input cases covered\n\nOne of the first and most important questions that I would want to know when testing a function is: For all input ranges, when does the function revert and when does it pass?\n\nThis function gives some guarantee that the `this.mul` function doesn't revert.\n\n<!-- gh-embed:crytic:properties:d3855861df5ff2f87fe2157de60417f9fc8cb4e3:contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol:595:606 -->\n\n**[ABDKMath64x64PropertyTests.sol](https://github.com/crytic/properties/blob/d3855861df5ff2f87fe2157de60417f9fc8cb4e3/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L595-L606)**\n\n```sol\n// Multiplying the maximum value times one shouldn't revert, as it is valid\n// Moreover, the result must be MAX_64x64\nfunction mul_test_maximum_value() public view {\n    int128 result;\n    try this.mul(MAX_64x64, ONE_FP) {\n        // Expected behaviour, does not revert\n        result = this.mul(MAX_64x64, ONE_FP);\n        assert(result == MAX_64x64);\n    } catch {\n        assert(false);\n    }\n}\n```\n\nHowever it is only a unit-test and does not give me sufficient guarantees over the whole input range of all values.\n\n### Tests should not be testing multiple things at once\n\nThe `div_test_division_identity` test tests both, division by `1` and by `0`.\n\n<!-- gh-embed:crytic:properties:d3855861df5ff2f87fe2157de60417f9fc8cb4e3:contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol:635:653 -->\n\n**[ABDKMath64x64PropertyTests.sol](https://github.com/crytic/properties/blob/d3855861df5ff2f87fe2157de60417f9fc8cb4e3/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L635-L653)**\n\n```sol\n// Test for identity property\n// x / 1 == x (equivalent to x / x == 1)\n// Moreover, x/x should not revert unless x == 0\nfunction div_test_division_identity(int128 x) public view {\n    int128 div_1 = div(x, ONE_FP);\n    assert(x == div_1);\n\n    int128 div_x;\n\n    try this.div(x, x) {\n        // This should always equal one\n        div_x = div(x, x);\n        assert(div_x == ONE_FP);\n    } catch {\n        // The only allowed case to revert is if x == 0\n        assert(x == ZERO_FP);\n    }\n\n}\n```\n\nWhile it's tempting to test multiple properties at once, the issue I see here is that the second test depends on the successful execution of the first. This would be ok if I had the guarantee that the division by `1` would always succeed and indeed return the same value.\n\n### Tested bounds are not tight\n\nWhen reviewing the test for `neg_test_maximum`, I noticed that the test is being performed on `MAX_64x64 - 1`.\n\n<!-- gh-embed:crytic:properties:d3855861df5ff2f87fe2157de60417f9fc8cb4e3:contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol:786:794 -->\n\n**[ABDKMath64x64PropertyTests.sol](https://github.com/crytic/properties/blob/d3855861df5ff2f87fe2157de60417f9fc8cb4e3/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L786-L794)**\n\n```sol\n// Test for the maximum value case\n// Since this is implementation-dependant, we will actually test with MAX_64x64-EPS\nfunction neg_test_maximum() public view {\n    try this.neg(sub(MAX_64x64, EPSILON)) {\n        // Expected behaviour, does not revert\n    } catch {\n        assert(false);\n    }\n}\n```\n\nThis is ok, however the bounds are not tight (i.e. the maximal value is not being checked). Furthermore, `neg` should be expected to work for any input except for `MIN_64x64` (including `MAX_64x64 `).\n\n### Helper functions not tested\n\nHelper functions, such as `most_significant_bits` are sufficiently complex that they would warrant their own tests to ensure that their functionality is correct.\n\n<!-- gh-embed:crytic:properties:d3855861df5ff2f87fe2157de60417f9fc8cb4e3:contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol:106:122 -->\n\n**[ABDKMath64x64PropertyTests.sol](https://github.com/crytic/properties/blob/d3855861df5ff2f87fe2157de60417f9fc8cb4e3/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L106-L122)**\n\n```sol\n// Return the i most significant bits from |n|. If n has less than i significant bits, return |n|\n// Uses functions from the library under test!\nfunction most_significant_bits(int128 n, uint256 i) public pure returns (uint256) {\n    // Create a mask consisting of i bits set to 1\n    uint256 mask = (2**i) - 1;\n\n    // Get the position of the MSB set to 1 of n\n    uint256 pos = uint64(toInt(log_2(n)) + 64 + 1);\n\n    // Get the positive value of n\n    uint256 value = (n>0) ? uint128(n) : uint128(-n);\n\n    // Shift the mask to match the rightmost 1-set bit\n    if(pos > i) { mask <<= (pos - i); }\n\n    return (value & mask);\n}\n```\n\nIf this function were to always return `0x0` for example, then many other tests would trivially pass. Also, touching on the first issue, if they were to revert, these tests would also trivially \"pass\".\n\nThe `most_significant_bits` function for example uses `log_2`, which has a `require(x > 0)` statement. Judging from the comment in the function description, this function should not revert for negative numbers. What's more, the line `-n` can also revert when `n = type(int128).min`. This case does not seem to be handled and it is unclear what the output should be.\n\nThe same can be said for almost all helper functions.\n\n<!-- gh-embed:crytic:properties:091654413501207323a4980f81e1349b09cf3a91:contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol:109:122 -->\n\n**[ABDKMath64x64PropertyTests.sol](https://github.com/crytic/properties/blob/091654413501207323a4980f81e1349b09cf3a91/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L109-L122)**\n\n```sol\nfunction significant_bits_after_mult(\n    int128 a,\n    int128 b\n) public pure returns (uint256) {\n    int128 x = a >= 0 ? a : -a;\n    int128 y = b >= 0 ? b : -b;\n\n    int128 lx = toInt(log_2(x));\n    int128 ly = toInt(log_2(y));\n    int256 prec = lx + ly - 1;\n\n    if (prec < -64) return 0;\n    else return (64 + uint256(prec));\n}\n```\n\nThere is also the `equal_within_precision` function which computes `(max - min)` for two `int128`s. And if this overflows the function will silently revert...\n\n<!-- gh-embed:crytic:properties:091654413501207323a4980f81e1349b09cf3a91:contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol:51:65 -->\n\n**[ABDKMath64x64PropertyTests.sol](https://github.com/crytic/properties/blob/091654413501207323a4980f81e1349b09cf3a91/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L51-L65)**\n\n```sol\n// These functions allows to compare a and b for equality, discarding\n// the last precision_bits bits.\n// An absolute value function is implemented inline in order to not use\n// the implementation from the library under test.\nfunction equal_within_precision(\n    int128 a,\n    int128 b,\n    uint256 precision_bits\n) public pure returns (bool) {\n    int128 max = (a > b) ? a : b;\n    int128 min = (a > b) ? b : a;\n    int128 r = (max - min) >> precision_bits;\n\n    return (r == 0);\n}\n```\n\n### Conditional branches for unit-tests\n\nThere are some tests that are effectively constructed as unit-tests. We (or the developer) should know with certainty what happens in those cases and we should not allow either outcome to pass.\n\n<!-- gh-embed:crytic:properties:091654413501207323a4980f81e1349b09cf3a91:contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol:905:925 -->\n\n**[ABDKMath64x64PropertyTests.sol](https://github.com/crytic/properties/blob/091654413501207323a4980f81e1349b09cf3a91/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L905-L925)**\n\n```sol\n// Test the maximum value\nfunction abs_test_maximum() public view {\n    int128 abs_max;\n\n    try this.abs(MAX_64x64) {\n        // If it doesn't revert, the value must be MAX_64x64\n        abs_max = this.abs(MAX_64x64);\n        assert(abs_max == MAX_64x64);\n    } catch {}\n}\n\n// Test the minimum value\nfunction abs_test_minimum() public view {\n    int128 abs_min;\n\n    try this.abs(MIN_64x64) {\n        // If it doesn't revert, the value must be the negative of MIN_64x64\n        abs_min = this.abs(MIN_64x64);\n        assert(abs_min == neg(MIN_64x64));\n    } catch {}\n}\n```\n\nThe test for the `abs` function is an example of this. The test passes if the function reverts, but it also passes if the function doesn't revert.\n\nThe `gavg` function uses conditional testing and has the comment that the overflow might be implementation specific.\n\n<!-- gh-embed:crytic:properties:091654413501207323a4980f81e1349b09cf3a91:contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol:1213:1223 -->\n\n**[ABDKMath64x64PropertyTests.sol](https://github.com/crytic/properties/blob/091654413501207323a4980f81e1349b09cf3a91/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L1213-L1223)**\n\n```sol\n// Test for the maximum value\nfunction gavg_test_maximum() public view {\n    int128 result;\n\n    // This may revert due to overflow depending on implementation\n    // If it doesn't revert, the result must be MAX_64x64\n    try this.gavg(MAX_64x64, MAX_64x64) {\n        result = this.gavg(MAX_64x64, MAX_64x64);\n        assert(result == MAX_64x64);\n    } catch {}\n}\n```\n\nBut I'm wondering why we have tests that are constructed for multiple different 64x64 libraries, when we are only testing one specific one. And whether we should even be writing tests that can handle multiple different libraries with different behavior.\n\n### Assumptions are not clear\n\nWhen reviewing the `inv_test_double_inverse` function, I noticed that because of the way the `loss` is computed, the function will reject any values where `x < ONE_FP` (because the log would become negative and the `toUint` would then throw).\n\n<!-- gh-embed:crytic:properties:091654413501207323a4980f81e1349b09cf3a91:contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol:939:950 -->\n\n**[ABDKMath64x64PropertyTests.sol](https://github.com/crytic/properties/blob/091654413501207323a4980f81e1349b09cf3a91/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L939-L950)**\n\n```sol\n// Test that the inverse of the inverse is close enough to the\n// original number\nfunction inv_test_double_inverse(int128 x) public view {\n    require(x != ZERO_FP);\n\n    int128 double_inv_x = inv(inv(x));\n\n    // The maximum loss of precision will be 2 * log2(x) bits rounded up\n    uint256 loss = 2 * toUInt(log_2(x)) + 2;\n\n    assert(equal_within_precision(x, double_inv_x, loss));\n}\n```\n\nThe only requirement for the test shows that `require(x != ZERO_FP)` which can give misleading guarantees. This is not the only function that does that.\n\n### Properties are not clear\n\nThe properties checked in `mul_test_values` are not very clear (or are not tightly bound).\n\n<!-- gh-embed:crytic:properties:d3855861df5ff2f87fe2157de60417f9fc8cb4e3:contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol:552:574 -->\n\n**[ABDKMath64x64PropertyTests.sol](https://github.com/crytic/properties/blob/d3855861df5ff2f87fe2157de60417f9fc8cb4e3/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L552-L574)**\n\n```sol\n// Test that the result increases or decreases depending\n// on the value to be added\nfunction mul_test_values(int128 x, int128 y) public view {\n    require(x != ZERO_FP && y != ZERO_FP);\n\n    int128 x_y = mul(x, y);\n\n    require(significant_digits_lost_in_mult(x, y) == false);\n\n    if (x >= ZERO_FP) {\n        if (y >= ONE_FP) {\n            assert(x_y >= x);\n        } else {\n            assert(x_y <= x);\n        }\n    } else {\n        if (y >= ONE_FP) {\n            assert(x_y <= x);\n        } else {\n            assert(x_y >= x);\n        }\n    }\n}\n```\n\nThis essentially translates to\n\n```\nx > 0 and y >= 1: x * y >= x\nx < 0 and y >= 1: x * y <= x\nx > 0 and y <  1: x * y <= x\nx < 0 and y <  1: x * y >= x\n```\n\nThe first two cases show that the product will grow (or stay the same) in absolute value relative to `x` when `y >= 1`.\nAnd the second two cases show that the product shrinks in absolute value relative to `x` when `y < 1`.\n\nThis could be better summarized as\n\n```\n|y| >= 1: |x * y| >= |x|\n|y| <  1: |x * y| <  |x|\n```\n\nAlso, because the cases only check for positive bounds on `y >= 1`, but not the negative `y <= -1` (which would be captured by using `abs`).\n\n### Insufficient coverage\n\nThere are functions that don't seem to be covered correctly. For example, the `inv_test_multiplication` shows the following coverage after 50k runs.\n\n```\n  958 |     |     // Test the multiplication of inverses\n  959 |     |     // 1/(x * y) == 1/x * 1/y\n  960 | r   |     function inv_test_multiplication(int128 x, int128 y) public view {\n  961 | r   |         require(x != ZERO_FP && y != ZERO_FP);\n  962 |     |\n  963 | r   |         int128 inv_x = inv(x);\n  964 | r   |         int128 inv_y = inv(y);\n  965 | r   |         int128 inv_x_times_inv_y = mul(inv_x, inv_y);\n  966 |     |\n  967 | r   |         int128 x_y = mul(x, y);\n  968 | r   |         int128 inv_x_y = inv(x_y);\n  969 |     |\n  970 | r   |         require(significant_bits_after_mult(x, y) > REQUIRED_SIGNIFICANT_BITS);\n  971 | r   |         require(significant_bits_after_mult(inv_x, inv_y) > REQUIRED_SIGNIFICANT_BITS);\n  972 |     |\n  973 |     |         // The maximum loss of precision is given by the formula:\n  974 |     |         // 2 * | log_2(x) - log_2(y) | + 1\n  975 |     |         uint256 loss = 2 * toUInt(abs(log_2(x) - log_2(y))) + 1;\n  976 |     |\n  977 |     |         assert(equal_within_precision(inv_x_y, inv_x_times_inv_y, loss));\n  978 |     |     }\n```\n\nThere are other cases where the full test paths are insufficiently covered after 50k runs.\n\n```\n 1516 |     |     // Test for logarithm of a power\n 1517 |     |     // log2(x ** y) = y * log2(x)\n 1518 | r   |     function log2_test_power(int128 x, uint256 y) public pure {\n 1519 | r   |         int128 x_y = pow(x, y);\n 1520 | r   |         int128 log2_x_y = log_2(x_y);\n 1521 |     |\n 1522 | r   |         uint256 y_log2_x = mulu(log_2(x), y);\n 1523 |     |\n 1524 |     |         assert(y_log2_x == toUInt(log2_x_y));\n 1525 |     |     }\n```\n\nThere are also certain branches that are not covered. Here, the if condition always reverts.\n\n```\n 1682 |     |     // Test for inverse function\n 1683 |     |     // If y = log_2(x) then exp_2(y) == x\n 1684 | *r  |     function exp2_test_inverse(int128 x) public view {\n 1685 | *r  |         int128 log2_x = log_2(x);\n 1686 | *r  |         int128 exp2_x = exp_2(log2_x);\n 1687 |     |\n 1688 | *r  |         uint256 bits = 50;\n 1689 |     |\n 1690 | *r  |         if(log2_x < ZERO_FP) {\n 1691 | r   |             bits = uint256(int256(bits) + int256(log2_x));\n 1692 |     |         }\n 1693 |     |\n 1694 | *r  |         assert(equal_most_significant_bits_within_precision(x, exp2_x, bits));\n 1695 |     |     }\n```\n\nIf we don't reach the final `assert` statement after 50k runs, then I think we're doing something wrong. The functions should not revert at all if we constrain it correctly (or only for single values). That would also give us assurance as to the valid intervals where this invariant holds true.\n\n### Failed test cases\n\nWhen I run the tests I get a reported test failure\n\n```\nln_test_distributive_mul(int128,int128): failed!:boom:\n  Call sequence:\n    ln_test_distributive_mul(118234586596974386564027176417986829418,9)\n\nEvent sequence: Panic(1): Using assert.\n```\n\nWe should run the tests long enough to make sure that we actually catch failing tests. I believe this function is also so hard to test for the fuzzer, because of all the hard requirements on the input. This could be improved with better input bounding.\n\nhttps://github.com/crytic/properties/blob/091654413501207323a4980f81e1349b09cf3a91/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#LL1611C1-L1630C6\n\nI think many of the issues stem from some design decisions around how Echidna tests work in general and we might need to re-think how we approach stateless tests with Echidna. Going through these made me consider that we might want to create some kind of more formalized guidelines for writing tests in general.\n","title":"Test Your Tests","date":"Feb 19, 2023","suptitle":"What makes a good and a bad test"}},"__N_SSG":true}