{"pageProps":{"postData":{"slug":["blog","2023","arithmetic-checks"],"contentRaw":"\n> This post was created during my time at Trail of Bits. It is featured in the [secure-contracts/learn-evm](https://secure-contracts.com/learn_evm/arithmetic-checks).\n\nThe Ethereum Virtual Machine (EVM) distinguishes itself from other virtual machines and computer systems through several unique aspects.\nOne notable difference is its treatment of arithmetic checks.\nWhile most architectures and virtual machines provide access to carry bits or an overflow flag,\nthese features are absent in the EVM.\nConsequently, these safeguards must be incorporated within the machine's constraints.\n\nStarting with Solidity version 0.8.0 the compiler automatically includes over and underflow protection in all arithmetic operations.\nPrior to version 0.8.0, developers were required to implement these checks manually, often using a library known as [SafeMath](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol), originally developed by OpenZeppelin.\nThe compiler incorporates arithmetic checks in a manner similar to SafeMath, through additional operations.\n\nAs the Solidity language has evolved, the compiler has generated increasingly optimized code for arithmetic checks. This trend is also observed in smart contract development in general, where highly optimized arithmetic code written in low-level assembly is becoming more common. However, there is still a lack of comprehensive resources explaining the nuances of how the EVM handles arithmetic for signed and unsigned integers of 256 bits and less.\n\nThis article serves as a guide for gaining a deeper understanding of arithmetic in the EVM by exploring various ways to perform arithmetic checks. We'll learn more about the two's complement system and some lesser-known opcodes. This article is designed for those curious about the EVM's inner workings and those interested in bit manipulations in general. A basic understanding of bitwise arithmetic and Solidity opcodes is assumed.\n\nAdditional references for complementary reading are:\n\n- [evm.codes](https://evm.codes)\n- [Understanding Two's Complement](https://www.geeksforgeeks.org/twos-complement/)\n\n> **Disclaimer:** Please note that this article is for educational purposes.\n> It is not our intention to encourage micro optimizations in order to save gas,\n> as this can potentially introduce new, hard-to-detect bugs that may compromise the security and stability of a protocol.\n> As a developer, prioritize the safety and security of the protocol over [premature optimizations](https://www.youtube.com/watch?v=tKbV6BpH-C8).\n> Including redundant checks for critical operations may be a good practice when the protocol code is still evolving.\n> However, we do encourage experimentation with these operations for educational purposes.\n\n## Arithmetic checks for uint256 addition\n\nTo examine how the solc compiler implements arithmetic checks, we can compile the code with the `--asm` flag and inspect the resulting bytecode.\nAlternatively, using the `--ir` flag allows us to examine the Yul code that is generated as an intermediate representation (IR).\n\n> Note that Solidity aims to make the new Yul pipeline the standard.\n> Certain operations (including arithmetic checks) are always included as Yul code, regardless of whether the code is compiled with the new pipeline using `--via-ir`.\n> This provides an opportunity to examine the Yul code and gain a better understanding of how arithmetic checks are executed in Solidity.\n> However, keep in mind that the final bytecode may differ slightly when compiler optimizations are turned on.\n\nTo illustrate how the compiler detects overflow in unsigned integer addition, consider the following example of Yul code produced by the compiler before version 0.8.16.\n\n```solidity\nfunction checked_add_t_uint256(x, y) -> sum {\n    x := cleanup_t_uint256(x)\n    y := cleanup_t_uint256(y)\n\n    // overflow, if x > (maxValue - y)\n    if gt(x, sub(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, y)) { panic_error_0x11() }\n\n    sum := add(x, y)\n}\n```\n\nTo improve readability, we can translate the Yul code back into high-level Solidity code.\n\n```solidity\n/// @notice versions >=0.8.0 && <0.8.16\nfunction checkedAddUint1(uint256 a, uint256 b) public pure returns (uint256 c) {\n    unchecked {\n        c = a + b;\n\n        if (a > type(uint256).max - b) arithmeticError();\n    }\n}\n```\n\n> Solidity's arithmetic errors are encoded as `abi.encodeWithSignature(\"Panic(uint256)\", 0x11)`.\n\nThe check for overflow in unsigned integer addition involves calculating the largest value that one summand can have when added to the other without causing an overflow.\nSpecifically, in this case, the maximum value `a` can have is `type(uint256).max - b`.\nIf `a` exceeds this value, we can conclude that `a + b` will overflow.\n\nAn alternative and slightly more efficient approach for computing the maximum value of `a` involves inverting the bits of `b`.\n\n```solidity\n/// @notice versions >=0.8.0 && <0.8.16 with compiler optimizations\nfunction checkedAddUint2(uint256 a, uint256 b) public pure returns (uint256 c) {\n    unchecked {\n        c = a + b;\n\n        if (a > ~b) arithmeticError();\n    }\n}\n```\n\nThis is process is equivalent, because `type(uint256).max` is a 256-bit integer with all its bits set to `1`.\nSubtracting `b` from `type(uint256).max` can be viewed as inverting each bit in `b`.\nThis transformation is demonstrated by `~b = ~(0 ^ b) = ~0 ^ b = MAX ^ b = MAX - b`.\n\n> Note that `a - b = a ^ b` is **NOT** a general rule, except in special cases, such as when one of the values equals `type(uint256).max`.\n> The relation `~b + 1 = 0 - b = -b` is also obtained if we add `1` mod `2**256` to both sides of the previous equation.\n\nBy first calculating the result of the addition and then performing a check on the sum, the need performing extra arithmetic operations are removed.\nThis is how the compiler implements arithmetic checks for unsigned integer addition in versions 0.8.16 and later.\n\n```solidity\n/// @notice versions >=0.8.16\nfunction checkedAddUint(uint256 a, uint256 b) public pure returns (uint256 c) {\n    unchecked {\n        c = a + b;\n\n        if (a > c) arithmeticError();\n    }\n}\n```\n\nOverflow is detected when the sum is smaller than one of its addends.\nIn other words, if `a > a + b`, then overflow has occurred.\nTo fully prove this, it is necessary to verify that overflow occurs if and only if `a > a + b`.\nAn important observation is that `a > a + b` (mod `2**256`) for `b > 0` is only possible when `b >= 2**256`, which exceeds the maximum possible value.\n\n## Arithmetic checks for int256 addition\n\nThe Solidity compiler generates the following (equivalent) code for detecting overflow in signed integer addition for versions below 0.8.16.\n\n```solidity\n/// @notice versions >=0.8.0 && <0.8.16\nfunction checkedAddInt(int256 a, int256 b) public pure returns (int256 c) {\n    unchecked {\n        c = a + b;\n\n        // If `a > 0`, then `b` can't exceed `type(int256).max - a`.\n        if (a > 0 && b > type(int256).max - a) arithmeticError();\n        // If `a < 0`, then `b` can't be less than `type(int256).min - a`.\n        if (a < 0 && b < type(int256).min - a) arithmeticError();\n    }\n}\n```\n\nSimilar to the previous example, we can compute the maximum and minimum value of one addend, given that the other is either positive or negative.\n\nFor reference, this is the Yul code that is produced when compiling via IR.\n\n```solidity\nfunction checked_add_t_int256(x, y) -> sum {\n    x := cleanup_t_int256(x)\n    y := cleanup_t_int256(y)\n\n    // overflow, if x >= 0 and y > (maxValue - x)\n    if and(iszero(slt(x, 0)), sgt(y, sub(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, x))) { panic_error_0x11() }\n    // underflow, if x < 0 and y < (minValue - x)\n    if and(slt(x, 0), slt(y, sub(0x8000000000000000000000000000000000000000000000000000000000000000, x))) { panic_error_0x11() }\n\n    sum := add(x, y)\n}\n```\n\nIt's important to note that when comparing signed values, the opcodes `slt` (signed less than) and `sgt` (signed greater than) must be used to avoid interpreting signed integers as unsigned integers.\nSolidity will automatically insert the correct opcode based on the value's type. This applies to other signed operations as well.\n\n### Quick primer on a two's complement system\n\nIn a two's complement system, the range of possible integers is divided into two halves: the positive and negative domains.\nThe first bit of an integer represents the sign, with `0` indicating a positive number and `1` indicating a negative number.\nFor positive integers (those with a sign bit of `0`), their binary representation is the same as their unsigned bit representation.\nHowever, the negative domain is shifted to lie \"above\" the positive domain.\n\n$$\nuint256 \\text{ domain}\n$$\n\n$$\n├\\underset{0}{─}────────────────────────────\\underset{\\hskip -2em 2^{256} - 1}{─}┤\n$$\n\n```solidity\n0x0000000000000000000000000000000000000000000000000000000000000000 // 0\n0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff // uint256_max\n```\n\n$$\nint256 \\text{ domain}\n$$\n\n$$\n\\overset{\\hskip 1em positive}{\n    ├\\underset{0}{─}────────────\\underset{\\hskip -2em 2^{255} - 1}{─}┤\n}\n\\overset{\\hskip 1em negative}{\n    ├────\\underset{\\hskip -3.5em - 2^{255}}─────────\\underset{\\hskip -0.4 em -1}{─}┤\n}\n$$\n\n```solidity\n0x0000000000000000000000000000000000000000000000000000000000000000 // 0\n0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff // int256_max\n0x8000000000000000000000000000000000000000000000000000000000000000 // int256_min\n0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff // -1\n```\n\nThe maximum positive integer that can be represented in a two's complement system using 256 bits is\n`0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` which is roughly equal to half of the maximum value that can be represented using uint256.\nThe most significant bit of this number is `0`, while all other bits are `1`.\n\nOn the other hand, all negative numbers start with a `1` as their first bit.\nIf we look at the underlying hex representation of these numbers, they are all greater than or equal to the smallest integer that can be represented using int256, which is `0x8000000000000000000000000000000000000000000000000000000000000000`. The integer's binary representation is a `1` followed by 255 `0`'s.\n\nTo obtain the negative value of an integer in a two's complement system, we flip the underlying bits and add `1`: `-a = ~a + 1`.\nAn example illustrates this.\n\n```solidity\n0x0000000000000000000000000000000000000000000000000000000000000003 // 3\n0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc // ~3\n0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd // -3 = ~3 + 1\n```\n\nTo verify that `-a + a = 0` holds for all integers, we can use the property of two's complement arithmetic that `-a = ~a + 1`.\nBy substituting this into the equation, we get `-a + a = (~a + 1) + a = MAX + 1 = 0`, where `MAX` is the maximum integer value.\n\nIn two's complement arithmetic, there is a unique case that warrants special attention. The smallest possible integer `int256).min = 0x8000000000000000000000000000000000000000000000000000000000000000 = -57896044618658097711785492504343953926634992332820282019728792003956564819968`\ndoes not have a positive inverse, making it the only negative number with this property.\n\nInterestingly, if we try to compute `-type(int256).min`, we obtain the same number, as `-type(int256).min = ~type(int256).min + 1 = type(int256).min`.\nThis means there are two fixed points for additive inverses: `-0 = 0` and `-type(int256).min = type(int256).min`.\nIt's important to note that Solidity's arithmetic checks will throw an error when evaluating `-type(int256).min` (outside of unchecked blocks).\n\nExamining the underlying bit (or hex) representation emphasizes the importance of using the correct operators for signed integers, such as `slt` instead of `lt`, to prevent misinterpreting negative values as large numbers.\n\n```solidity\n  0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff // int256(-1) or type(uint256).max\n< 0x0000000000000000000000000000000000000000000000000000000000000000 // 0\n// When using `slt`, the comparison is interpreted as `-1 < 0 = true`.\n= 0x0000000000000000000000000000000000000000000000000000000000000001\n// When using `lt`, the comparison is interpreted as `type(uint256).max < 0 = false`.\n= 0x0000000000000000000000000000000000000000000000000000000000000000\n```\n\nStarting with Solidity versions 0.8.16, integer overflow is prevented by using the computed result `c = a + b` to check for overflow/underflow.\nHowever, signed addition requires two separate checks instead of one, unlike unsigned addition.\n\n```solidity\n/// @notice versions >=0.8.16\nfunction checkedAddInt2(int256 a, int256 b) public pure returns (int256 c) {\n    unchecked {\n        c = a + b;\n\n        // If `a` is positive, then the sum `c = a + b` can't be less than `b`.\n        if (a > 0 && c < b) arithmeticError();\n        // If `a` is negative, then the sum `c = a + b` can't be greater than `b`.\n        if (a < 0 && c > b) arithmeticError();\n    }\n}\n```\n\nNevertheless, by utilizing the boolean exclusive-or, we can combine these checks into a single step.\nAlthough Solidity does not allow the `xor` operation for boolean values, it can be used in inline-assembly.\nWhile doing so, it is important to validate our assumptions that both inputs are genuinely boolean (either `0` or `1`), as the xor operation functions bitwise and is not limited to only boolean values.\n\n```solidity\nfunction checkedAddInt3(int256 a, int256 b) public pure returns (int256 c) {\n    unchecked {\n        c = a + b;\n\n        bool overflow;\n\n        assembly {\n            // If `a >= 0`, then the sum `c = a + b` can't be less than `b`.\n            // If `a <  0`, then the sum `c = a + b` can't be greater than `b`.\n            // We combine these two conditions into one using `xor`.\n            overflow := xor(slt(a, 0), sgt(b, c))\n        }\n\n        if (overflow) arithmeticError();\n    }\n}\n```\n\nAn alternative approach to detecting overflow in addition is based on the observation that adding two integers with different signs will never result in an overflow.\nThis simplifies the check to the case when both operands have the same sign.\nIf the sign of the sum differs from one of the operands, the result has overflowed.\n\n```solidity\nfunction checkedAddInt4(int256 a, int256 b) public pure returns (int256 c) {\n    unchecked {\n        c = a + b;\n\n        // Overflow, if the signs of `a` and `b` are the same,\n        // but the sign of the result `c = a + b` differs from its summands.\n        // When the signs of `a` and `b` differ overflow is not possible.\n        if ((~a ^ b) & (a ^ c) < 0) arithmeticError();\n    }\n}\n```\n\nInstead of checking the sign bit explicitly, which can be done by shifting the value to the right by 255 bits and verifying that it is non-zero,\nwe can use the `slt` operation to compare the value with `0`.\n\n## Arithmetic checks for uint256 subtraction\n\nThe process of checking for underflow in subtraction is similar to that of addition.\nWhen subtracting `a - b`, and `b` is greater than `a`, an underflow occurs.\n\n```solidity\nfunction checkedSubUint(uint256 a, uint256 b) public pure returns (uint256 c) {\n    unchecked {\n        c = a - b;\n\n        if (b > a) arithmeticError();\n    }\n}\n```\n\nAlternatively, we could perform the check on the result itself using `if (c > a) arithmeticError();`, because subtracting a positive value from `a` should yield a value less than or equal to `a`.\nHowever, in this case, we don't save any operations.\n\nSimilar to addition, for signed integers, we can combine the checks for both scenarios into a single check using `xor`.\n\n```solidity\nfunction checkedSubInt(int256 a, int256 b) public pure returns (int256 c) {\n    unchecked {\n        c = a - b;\n\n        bool overflow;\n\n        assembly {\n            // If `b >= 0`, then the result `c = a - b` can't be greater than `a`.\n            // If `b <  0`, then the result `c = a - b` can't be less than `a`.\n            overflow := xor(sgt(b, 0), sgt(a, c))\n        }\n\n        if (overflow) arithmeticError();\n    }\n}\n```\n\n## Arithmetic checks for uint256 multiplication\n\nTo detect overflow when multiplying two unsigned integers, we can use the approach of computing the maximum possible value of a multiplicand and check that it isn't exceeded.\n\n```solidity\n/// @notice versions >=0.8.0 && <0.8.17\nfunction checkedMulUint1(uint256 a, uint256 b) public pure returns (uint256 c) {\n    unchecked {\n        c = a * b;\n\n        if (a != 0 && b > type(uint256).max / a) arithmeticError();\n    }\n}\n```\n\n> The Solidity compiler always includes a zero check for all division and modulo operations, irrespective of whether an unchecked block is present.\n> The EVM itself, however, returns `0` when dividing by `0`, which applies to inline-assembly as well.\n> Evaluating the boolean expression `a != 0 && b > type(uint256).max / a` in reverse order would cause an incorrect reversion when `a = 0`.\n\nWe can compute the maximum value for `b` as long as `a` is non-zero. However, if `a` is zero, we know that the result will be zero as well, and there is no need to check for overflow.\nLike before, we can also make use of the result and try to reconstruct one multiplicand from it. This is possible if the product didn't overflow and the first multiplicand is non-zero.\n\n```solidity\n/// @notice versions >=0.8.17\nfunction checkedMulUint2(uint256 a, uint256 b) public pure returns (uint256 c) {\n    unchecked {\n        c = a * b;\n\n        if (a != 0 && b != c / a) arithmeticError();\n    }\n}\n```\n\nFor reference, we can further remove the additional division by zero check by writing the code in assembly.\n\n```solidity\nfunction checkedMulUint3(uint256 a, uint256 b) public pure returns (uint256 c) {\n    unchecked {\n        c = a * b;\n\n        bool overflow;\n\n        assembly {\n            // This version does not include a redundant division-by-0 check\n            // which the Solidity compiler includes when performing `c / a`.\n            overflow := iszero(or(iszero(a), eq(div(c, a), b)))\n        }\n\n        if (overflow) arithmeticError();\n    }\n}\n```\n\n## Arithmetic checks for int256 multiplication\n\nIn versions before 0.8.17, the Solidity compiler uses four separate checks to detect integer multiplication overflow.\nThe produced Yul code is equivalent to the following high-level Solidity code.\n\n```solidity\n/// @notice versions >=0.8.0 && <0.8.17\nfunction checkedMulInt(int256 a, int256 b) public pure returns (int256 c) {\n    unchecked {\n        c = a * b;\n\n        if (a > 0 && b > 0 && a > type(int256).max / b) arithmeticError();\n        if (a > 0 && b < 0 && a < type(int256).min / b) arithmeticError();\n        if (a < 0 && b > 0 && a < type(int256).min / b) arithmeticError();\n        if (a < 0 && b < 0 && a < type(int256).max / b) arithmeticError();\n    }\n}\n```\n\nSince Solidity version 0.8.17, the check is performed by utilizing the computed product in the check.\n\n```solidity\n/// @notice versions >=0.8.17\nfunction checkedMulInt2(int256 a, int256 b) public pure returns (int256 c) {\n    unchecked {\n        c = a * b;\n\n        if (a < 0 && b == type(int256).min) arithmeticError();\n        if (a != 0 && b != c / a) arithmeticError();\n    }\n}\n```\n\nWhen it comes to integer multiplication, it's important to handle the case when `a < 0` and `b == type(int256).min`.\nThe actual case, where the product `c` will overflow, is limited to `a == -1` and `b == type(int256).min`.\nThis is because `-b` cannot be represented as a positive signed integer, as previously mentioned.\n\n## Arithmetic checks for addition with sub-32-byte types\n\nWhen performing arithmetic checks on data types that use less than 32 bytes, there are some additional steps to consider.\nFirst, let's take a look at the addition of signed 64-bit integers.\n\nOn a 64-bit system, integer addition works in the same way as before.\n\n```solidity\n  0xfffffffffffffffe // int64(-2)\n+ 0x0000000000000003 // int64(3)\n= 0x0000000000000001 // int64(1)\n```\n\nHowever, when performing the same calculations on a 256-bit machine, we need to extend the sign of the int64 value over all unused bits,\notherwise the value won't be interpreted correctly.\n\n```solidity\n                                   extended sign ──┐┌── 64-bit information\n  0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe // int64(-2)\n+ 0x0000000000000000000000000000000000000000000000000000000000000003 // int64(3)\n= 0x0000000000000000000000000000000000000000000000000000000000000001 // int64(1)\n```\n\nIt's worth noting that not all operations require clean upper bits. In fact, even if the upper bits are dirty, we can still get correct results for addition. However, the sum will usually contain dirty upper bits that will need to be cleaned. For example, we can perform addition without knowledge of the upper bits.\n\n```solidity\n  0x????????????????????????????????????????????????fffffffffffffffe // int64(-2)\n+ 0x????????????????????????????????????????????????0000000000000003 // int64(3)\n= 0x????????????????????????????????????????????????0000000000000001 // int64(1)\n```\n\nIt is crucial to be mindful of when to clean the bits before and after operations.\nBy default, Solidity takes care of cleaning the bits before operations on smaller types and lets the optimizer remove any redundant steps.\nHowever, values accessed after operations included by the compiler are not guaranteed to be clean. In particular, this is the case for addition with small data types.\nFor example, the bit cleaning steps will be removed by the optimizer (even without optimizations enabled) if a variable is only accessed in a subsequent assembly block.\nRefer to the [Solidity documentation](https://docs.soliditylang.org/en/v0.8.18/internals/variable_cleanup.html#cleaning-up-variables) for further information on this matter.\n\nWhen performing arithmetic checks in the same way as before, it is necessary to include a step to clean the bits on the sum.\nOne approach to achieve this is by performing `signextend(7, value)`, which extends the sign of a 64-bit (7 + 1 = 8 bytes) integer over all upper bits.\n\n```solidity\nfunction checkedAddInt64_1(int64 a, int64 b) public pure returns (int64 c) {\n    unchecked {\n        bool overflow;\n\n        c = a + b;\n\n        assembly {\n            // Note that we must manually clean the upper bits in this case.\n            // Solidity will optimize the cleaning away otherwise.\n            // Extend the sign of the sum to 256 bits.\n            c := signextend(7, c)\n\n            // Perform the same arithmetic overflow check as before.\n            overflow := xor(slt(a, 0), sgt(b, c))\n        }\n\n        if (overflow) arithmeticError();\n    }\n}\n```\n\nIf we remove the line that includes `c := signextend(7, c)` the overflow check will not function correctly.\nThis is because Solidity does not take into account the fact that the variable is used in an assembly block, and the optimizer removes the bit cleaning operation, even if the Yul code includes it after the addition.\n\nOne thing to keep in mind is that since we are performing a 64-bit addition in 256 bits, we practically have access to the carry/overflow bits.\nIf our computed value does not overflow, then it will fall within the correct bounds `type(int64).min <= c <= type(int64).max`.\nThe actual overflow check in Solidity involves verifying both the upper and lower bounds.\n\n```solidity\n/// @notice version >= 0.8.16\nfunction checkedAddInt64_2(int64 a, int64 b) public pure returns (int64 c) {\n    unchecked {\n        // Perform the addition in int256.\n        int256 uc = int256(a) + b;\n\n        // If the value can not be represented by a int64, there is overflow.\n        if (uc > type(int64).max || uc < type(int64).min) arithmeticError();\n\n        // We can safely cast the result.\n        c = int64(uc);\n    }\n}\n```\n\nThere are a few ways to verify that the result in its 256-bit representation will fit into the expected data type.\nThis is only true when all upper bits are the same.\nThe most direct method, as previously shown, involves verifying both the lower and upper bounds.\n\n```solidity\n/// @notice Check used in int64 addition for version >= 0.8.16.\nfunction overflowInt64(int256 value) public pure returns (bool overflow) {\n    overflow = value > type(int64).max || value < type(int64).min;\n}\n```\n\nWe can simplify the expression to a single comparison if we can shift the disjointed number domain back so that it's connected.\nTo accomplish this, we subtract the smallest negative int64 `type(int64).min` from a value (or add the underlying unsigned value).\nA better way to understand this is by visualizing the signed integer number domain in relation to the unsigned domain (which is demonstrated here using int128).\n\n$$\nuint256 \\text{ domain}\n$$\n\n$$\n├\\underset{0}{─}────────────────────────────\\underset{\\hskip -2em 2^{256} - 1}{─}┤\n$$\n\n$$\nint256 \\text{ domain}\n$$\n\n$$\n\\overset{\\hskip 1em positive}{\n    ├\\underset{0}{─}────────────\\underset{\\hskip -2em 2^{255} - 1}{─}┤\n}\n\\overset{\\hskip 1em negative}{\n    ├────\\underset{\\hskip -3.5em - 2^{255}}─────────\\underset{\\hskip -0.4 em -1}{─}┤\n}\n$$\n\nThe domain for uint128/int128 can be visualized as follows.\n\n$$\nuint128 \\text{ domain}\n$$\n\n$$\n├\\underset{0}─────────────\\underset{\\hskip -2em 2^{128}-1}─┤\n\\phantom{───────────────}┆\n$$\n\n$$\nint128 \\text{ domain}\n$$\n\n$$\n\\overset{\\hskip 1em positive}{\n    ├\\underset{0}{─}────\\underset{\\hskip -2em 2^{127} - 1}{─}┤\n}\n\\phantom{────────────────}\n\\overset{\\hskip 1em negative}{\n    ├────\\underset{\\hskip -3.5em - 2^{127}}─\\underset{\\hskip -0.4 em -1}{─}┤\n}\n$$\n\nNote that the scales of the number ranges in the previous section do not accurately depict the magnitude of numbers that are representable with the different types and only serve as a visualization. We can represent twice as many numbers with only one additional bit, yet the uint256 domain has twice the number of bits compared to uint128.\n\nAfter subtracting `type(int128).min` (or adding $2^{127}$) and essentially shifting the domains to the right, we get the following, connected set of values.\n\n$$\n├\\underset{0}─────────────\\underset{\\hskip -2em 2^{128}-1}─┤\n\\phantom{───────────────}┆\n$$\n\n$$\n\\overset{\\hskip 1em negative}{├──────┤}\n\\overset{\\hskip 1em positive}{├──────┤}\n\\phantom{───────────────}┆\n$$\n\nIf we interpret the shifted value as an unsigned integer, we only need to check whether it exceeds the maximum unsigned integer `type(uint128).max`.\nThe corresponding check in Solidity is shown below.\n\n```solidity\nfunction overflowInt64_2(int256 value) public pure returns (bool overflow) {\n    unchecked {\n        overflow = uint256(value) - uint256(int256(type(int64).min)) > type(uint64).max;\n    }\n}\n```\n\nIn this case the verbose assembly code might actually be easier to follow than the Solidity code which sometimes contains implicit operations.\n\n```solidity\nint64 constant INT64_MIN = -0x8000000000000000;\nuint64 constant UINT64_MAX = 0xffffffffffffffff;\n\nfunction overflowInt64_2_yul(int256 value) public pure returns (bool overflow) {\n    assembly {\n        overflow := gt(sub(value, INT64_MIN), UINT64_MAX)\n    }\n}\n```\n\nAs mentioned earlier, this approach is only effective for negative numbers when all of their upper bits are set to `1`, allowing us to overflow back into the positive domain.\nAn alternative and more straightforward method would be to simply verify that all of the upper bits are equivalent to the sign bit for all integers.\n\n```solidity\nfunction overflowInt64_3(int256 value) public pure returns (bool overflow) {\n    overflow = value != int64(value);\n}\n```\n\nIn Yul, the equivalent resembles the following.\n\n```solidity\nfunction overflowInt64_3_yul(int256 value) public pure returns (bool overflow) {\n    assembly {\n        overflow := iszero(eq(value, signextend(7, value)))\n    }\n}\n```\n\nAnother way of extending the sign is to make use of `sar` (signed arithmetic right shift).\n\n```solidity\nfunction overflowInt64_4(int256 value) public pure returns (bool overflow) {\n    overflow = value != (value << 192) >> 192;\n}\n\nfunction overflowInt64_4_yul(int256 value) public pure returns (bool overflow) {\n    assembly {\n        overflow := iszero(eq(value, sar(192, shl(192, value))))\n    }\n}\n```\n\nFinally, a full example for detecting signed 64-bit integer overflow, implemented in Solidity can be seen below:\n\n```solidity\nfunction checkedAddInt64_2(int64 a, int64 b) public pure returns (int64 c) {\n    unchecked {\n        // Cast the first summand.\n        // The second summand is implicitly casted.\n        int256 uc = int256(a) + b;\n\n        // Check whether the result `uc` can be represented by 64 bits\n        // by shifting the values to the uint64 domain.\n        // This is done by subtracting the smallest value in int64.\n        if (uint256(uc) - uint256(int256(type(int64).min)) > type(uint64).max) arithmeticError();\n\n        // We can safely cast the result.\n        c = int64(uc);\n    }\n}\n```\n\nOne further optimization that we could perform is to add `-type(int64).min` instead of subtracting `type(int64).min`. This would not reduce computation costs, however it could end up reducing bytecode size. This is because when we subtract `-type(int64).min`, we need to push 32 bytes (`0xffffffffffffffffffffffffffffffffffffffffffffffff8000000000000000`), whereas when we add `-type(int64).min`, we only end up pushing 8 bytes (`0x8000000000000000`). However, as soon as we turn on compiler optimizations, the produced bytecode ends up being the same.\n\n## Arithmetic checks for multiplication with sub-32-byte types\n\nWhen the product `c = a * b` can be calculated in 256 bits without the possibility of overflowing, we can verify whether the result can fit into the anticipated data type. This is also the way Solidity handles the check in versions 0.8.17 and later.\n\n```solidity\n/// @notice version >= 0.8.17\nfunction checkedMulInt64(int64 a, int64 b) public pure returns (int64 c) {\n    unchecked {\n        int256 uc = int256(a) * int256(b);\n\n        // If the product can not be represented with 64 bits,\n        // there is overflow.\n        if (overflowInt64(uc)) arithmeticError();\n\n        c = int64(uc);\n    }\n}\n```\n\nHowever, if the maximum value of a product exceeds 256 bits, then this method won't be effective.\nThis happens, for instance, when working with int192. The product `type(int192).min * type(int192).min` requires 192 + 192 = 384 bits to be stored, which exceeds the maximum of 256 bits.\nOverflow occurs in 256 bits, causing a loss of information, and it won't be logical to check if the result fits into 192 bits.\nIn this scenario, we can rely on the previous checks and, for example, attempt to reconstruct one of the multiplicands.\n\n```solidity\nfunction checkedMulInt192_1(int192 a, int192 b) public pure returns (int192 c) {\n    unchecked {\n        c = a * b;\n\n        if (a != 0 && b != c / a) arithmeticError();\n        if (a = -1 && b == type(int192).min) arithmeticError();\n    }\n}\n```\n\nWe must consider the two special circumstances:\n\n1. When one of the multiplicands is zero (`a == 0`), the other multiplicand cannot be retrieved. However, this case never results in overflow.\n2. Even if the multiplication is correct in 256 bits, the calculation overflows when only examining the least-significant 192 bits if the first multiplicand is negative one (`a = -1`) and the other multiplicand is the minimum value.\n\nAn example might help explain the second case.\n\n```solidity\n  0xffffffffffffffff800000000000000000000000000000000000000000000000 // type(int192).min\n* 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff // -1\n= 0x0000000000000000800000000000000000000000000000000000000000000000 // type(int192).min (when seen as a int192)\n```\n\nA method to address this issue is to always start by sign-extending or cleaning the result before attempting to reconstruct the other multiplicand.\nBy doing so, it eliminates the need to check for the special condition.\n\n```solidity\n/// @notice version >= 0.8.17\nfunction checkedMulInt192_2(int192 a, int192 b) public pure returns (int192 c) {\n    unchecked {\n        bool overflow;\n\n        assembly {\n            // Extend the sign for int192 (24 = 23 + 1 bytes).\n            c := signextend(23, mul(a, b))\n\n            // Overflow, if `a != 0 && b != c / a`.\n            overflow := iszero(or(iszero(a), eq(b, sdiv(c, a))))\n        }\n\n        if (overflow) arithmeticError();\n    }\n}\n```\n\n## Conclusion\n\nIn conclusion, we hope this article has served as an informative guide on signed integer arithmetic within the EVM and the two's complement system.\nWe have explored:\n\n- the added complexity from handling signed over unsigned integers\n- the intricacies involved in managing sub 32-byte types\n- the significance of `signextend` and opcodes related to signed integers\n- the importance of bit-cleaning\n\nWhile low-level optimizations are attractive, they are also heavily error-prone. This article aims to deepen one's understanding of low-level arithmetic, to reduce these risks. Nevertheless, it is crucial to integrate custom low-level optimizations only after thorough manual analysis, automated testing, and to document any non-obvious assumptions.\n","title":"A Guide on Performing Arithmetic Checks in the EVM","date":"Feb 19, 2023","excerpt":"A post created during my time at Trail of Bits. It features the many ways that arithmetic checks can be performed in the EVM."}},"__N_SSG":true}