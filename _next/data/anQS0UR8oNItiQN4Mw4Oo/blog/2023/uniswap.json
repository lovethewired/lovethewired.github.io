{"pageProps":{"postData":{"slug":["blog","2023","uniswap"],"contentRaw":"\n## UniswapV2\n\nThe constant function AMM is defined through its invariant on the reserves. For Uniswap & co. the constant product formula $x \\cdot y = k$ is used.\n\n**Curve Invariant:**\n\n$$\nx \\cdot y = L^2\n$$\n\nOften liquidity $L$ or, in this case $L^2$ is used in the invariant formula instead. Generally, the liquidity reflects how \"liquid\" the pool is, i.e. how many assets can be swapped and what the price impact is of a trade - a pool with deeper liquidity will have a slower rate of change in price.\n\nConstant product AMMs are said to have \"infinite liquidity\", because the liquidity always remains the same during a swap. This means that it is always possible to swap with the pool, but the pool will return an increasingly smaller amount.\n\nI can't say exactly why $L^2$ instead of simply $L$ is used, buy it does seem to make sense, given that we are multiplying the amounts of two assets. And when providing liquidity, when keeping a constant price, the required tokens are proportional to $L$.\n\n**Price:**\n\n$$\nP = \\frac y x\n$$\n\nThe price $P$ is defined as the ratio between the two reserves. Often, the price of an asset will be denominated in stable units. Given the pair ETH-USD, the $x$ amount (`token0`) would reflect the ETH reserves and the $y$ amount (`token1`) the USD reserves of a pool. The price $P_{\\text{Eth}} = \\frac y x = \\frac {\\text{USD}} {\\text{ETH}}$ is the dollar per Ether rate.\n\n**Derived Formulas:**\n\nFrom these formulas, we can derive the amounts $x$ and $y$, given the liquidity $L$ and the price $P$ by multiplying or dividing the above formulas.\n\n<details>\n<summary> Derivation\n\n$$\nx = L \\cdot \\frac 1 {\\sqrt P} \\qquad\ny = L \\cdot \\sqrt P\n$$\n\n</summary>\n\n$$\n\\begin{aligned}\n     && x \\cdot y \\cdot \\frac 1 P &= L ^ 2  \\cdot \\frac 1 P \\qquad&\n        x \\cdot y \\cdot P &= L ^ 2  \\cdot P \\\\\n\\iff && x ^2 &= \\frac {L ^ 2} P  \\qquad&\n        y ^2 &= L ^ 2 \\cdot P  \\\\\n\\iff && x &= \\frac {L} {\\sqrt P}  \\qquad&\n        y &= L \\cdot {\\sqrt P}\n\\end{aligned}\n$$\n\n</details>\n\nThe price $P$ can also be discovered directly in the curve. When moving along the curve with constant liquidity (e.g. when performing a swap), the negative of the derivative $\\frac {\\partial y} {\\partial x}$ reflects the price.\n\n<details>\n<summary> Derivation\n\n$$P = - \\frac {\\mathrm d y} {\\mathrm d x}$$\n\n</summary>\n\n$$\ny = \\frac {L^2} x \\qquad\n\\frac {\\mathrm d y} {\\mathrm d x}\n= - \\frac {L^2} {x^2} = -P\n$$\n\nWe made use of the fact that the liquidity $L$ is constant.\n\n</details>\n\nThis can be thought of the sensitivity of the output of a swap $\\Delta y$ given an infinitesimal amount of input $\\Delta x$. If the price is low for example - this is when we are far right on the curve and the pool almost exclusively is comprised of $X$ assets - the output will not be very sensitive to changes in $x$. Whereas when the price is high and the pool is almost exclusively made up of $Y$ assets, we'll only need a small amount of input $\\Delta x$ for a big change in output $\\Delta y$.\n\n## UniswapV3\n\n![Uniswap Figure 1 - Simulation of virtual liquidity](/data/blog/2023/uniswap/figure-1.png)\n\n### Virtual liquidity\n\nThe innovation in UniswapV3 comes from being able to concentrate our liquidity to a limited price range $[p_a, p_b]$. The original formula $x \\cdot y = L^2$, allows anyone to trade with the pool at any price. By adjusting it, we can artificially inflate the assets, as if we had a deeper liquidity in a given price band. A deeper liquidity means that the rate of change of the price will be slower, but it also means that we are swapping more tokens when the price moves.\n\nThe way this is done is by adding constants to our real assets to make up our virtual assets. This corresponds to a translation/shift in the curve formula.\n\n$$\n(x_\\text {real} + s_x) \\cdot (y_\\text {real} + s_y) =\nx_\\text {virtual} \\cdot y_\\text {virtual}\n= L^2\n$$\n\n![Uniswap Figure 2 - Real reserves](/data/blog/2023/uniswap/figure-2.png)\n\nHere, $x_\\text {virtual}$ and $y_\\text {virtual}$ are the inflated, virtual assets and $x_\\text {real}$ and $y_\\text {real}$ reflect the real assets located in the pool.\n\nThe tradeoff for inflating our assets is that our liquidity is not infinite anymore - once we hit the upper or lower price limit, the liquidity for that range will be depleted and we will have entirely swapped one token for another. When working with the entire price range, there would always be assets left to swap.\n\nWhen all of our liquidity is made up of only $Y$ assets for example, the amount of $X$ assets will be zero $x_\\text {real} = 0$. The price of asset $Y$ per asset $X$ then reaches the upper limit $P=p_b$. Since we're using the inflated assets for our curve, the price is calculated using the virtual reserves $x_\\text {virtual}$ and $y_\\text {virtual}$.\n\n$$\nP = \\frac {y_\\text {virtual}} {x_\\text {virtual}} =\n\\frac {y_\\text {real} + s_y} {x_\\text {real} + s_x} \\;, \\text { where } P \\in [p_a, p_b]\n$$\n\nIn order to find $s_x$, we can insert $x_\\text {real} = 0$ into the curve formula. Note that in this case we also have $P = p_b$.\n\n<details>\n<summary> Derivation\n\n$$\ns_x = \\frac L {\\sqrt {p_b}}\n$$\n\n</summary>\n\n$$\n\\begin{aligned}\n    && (x_\\text {real} + s_x) \\cdot (y_\\text {real} + s_y) &= L ^2 \\\\\n\\iff && s_x \\cdot y_\\text {virtual} &= L ^2 \\\\\n\\iff && s_x \\cdot L \\sqrt {p_b} &= L ^2 \\\\\n\\iff && s_x &= \\frac L {\\sqrt {p_b}} \\\\\n\\end{aligned}\n$$\n\n</details>\n\nSimilarly, we can find $s_y = L {\\sqrt{p_a}}$.\n\n$$\nx_\\text {virtual} = x_\\text {real} + \\frac L {\\sqrt {p_b}} \\qquad\ny_\\text {virtual} = y_\\text {real} + L {\\sqrt {p_a}}\n$$\n\nThe **shifted invariant formula** - the formula used by Uniswap is\n\n$$\n(x_\\text {real} + \\frac L {\\sqrt {p_b}}) \\cdot (y_\\text {real} + L {\\sqrt{p_a}}) = L^2 \\;.\n$$\n\nNote how this formula approaches the original curve invariant $x \\cdot y = L^2$ as we expand the price range: $p_a \\to 0$ and $p_b \\to \\infty$.\n\nLike before, we can derive formulas for $x_{\\text{real}}$ and $y_{\\text{real}}$ given the liquidity $L$ and the price $P$ by multiplying the new invariant with the price formula.\n\n**Derived Formulas:**\n\n<details>\n<summary> Derivation\n\n$$\nx_\\text{real} = L \\cdot (\\frac 1 {\\sqrt P} - \\frac 1 {\\sqrt p_b}) \\qquad\ny_\\text{real} = L \\cdot (\\sqrt P - \\sqrt {p_a})\n$$\n\n</summary>\n\n$$\n\\begin{aligned}\n&& x_\\text{virtual} &= L \\cdot \\frac 1 {\\sqrt P} &\ny_\\text{virtual} &= L \\cdot \\sqrt P \\\\\n\\iff\n&& x_\\text{real} + \\frac L {\\sqrt {p_b}} &= L \\cdot \\frac 1 {\\sqrt P} &\ny_\\text{real} + L {\\sqrt{p_a}} &= L \\cdot \\sqrt P \\\\\n\\iff\n&& x_\\text{real} &= L \\cdot (\\frac 1 {\\sqrt P} - \\frac 1 {\\sqrt p_b}) &\ny_\\text{real} &= L \\cdot (\\sqrt P - \\sqrt {p_a})\n\\end{aligned}\n$$\n\n</details>\n\n### Providing Liquidity\n\nWhen providing liquidity, one condition we might want is for the price to remain constant. We can then easily express the change in tokens per change in liquidity $\\Delta L$, since the formulas are linearly dependent. A change in liquidity is proportional to a change in either $X$ or $Y$ assets and vice versa.\n\n<details>\n<summary> Derivation\n\n$$\n\\Delta x_\\text{real} = \\Delta L \\cdot (\\frac 1 {\\sqrt P} - \\frac 1 {\\sqrt p_b}) \\qquad\n\\Delta y_\\text{real} = \\Delta L \\cdot (\\sqrt P - \\sqrt {p_a}) \\;,\n$$\n\n</summary>\n\n$$\n\\begin{aligned}\n\\Delta x_\\text{real} &=\nx_\\text{real}^{(2)} - x_\\text{real}^{(1)} \\\\\n&=\nL^{(2)} \\cdot (\\frac 1 {\\sqrt P} - \\frac 1 {\\sqrt p_b}) -\nL^{(1)} \\cdot (\\frac 1 {\\sqrt P} - \\frac 1 {\\sqrt p_b}) \\\\\n&= (L^{(2)} - L^{(1)}) \\cdot (\\frac 1 {\\sqrt P} - \\frac 1 {\\sqrt p_b}) \\\\\n&= \\Delta L \\cdot (\\frac 1 {\\sqrt P} - \\frac 1 {\\sqrt p_b})\n\\end{aligned}\n$$\n\n</details>\n\nwhere $P \\in [p_a, p_b]$. We must **clamp the price** in the formula to the price range $[p_a, p_b]$ for which we want to provide liquidity, because as mentioned earlier, after we leave the range, the liquidity is depleted and we don't have any tokens left to swap in the same direction anymore.\n\nNotice that when we want to supply liquidity to the pool and the _current price is below_ our desired price range ($P \\leq p_a$), we are only required to provide $X$ assets. The formula then reads $\\Delta y_\\text{real} = 0$ and $\\Delta x_\\text{real} = \\Delta L \\cdot (\\frac 1 {\\sqrt {p_a}} - \\frac 1 {\\sqrt p_b})$. If we imagine someone swapping with the pool and moving the price from below into our range, then the amount of $Y$ assets is increasing (we see this from $P = \\frac y x$) and the amount of $X$ assets are decreasing in the pool. If the price is to increase any further in the same direction, the pool only needs $X$ assets.\n\nStill reflecting on the case when the $P \\leq p_a$, the change in assets $\\Delta x_\\text{real} = \\Delta L \\cdot (\\frac 1 {\\sqrt {p_a}} - \\frac 1 {\\sqrt p_b})$ reflects the assets required to cover a full price move from the lower range $p_a$ to the upper range $p_b$ with a change in liquidity $\\Delta L$ of the pool.\n\nConversely, when the _price is above_ our range ($P \\geq p_b$), we will only need to provide $Y$ assets to the pool. The formula then reads $\\Delta x_\\text{real} = 0$ and $\\Delta y_\\text{real} = \\Delta L \\cdot (\\sqrt {p_b} - \\sqrt {p_a})$.\n\n### Swapping\n\nWhen swapping, the price changes according to the curve invariant, while we would like the (virtual) liquidity to remain constant. Instead of expressing the change in one asset through a change in the other, we can express the change in assets through the change in price instead. This is more convenient, as Uniswap stores the liquidity and price (or square root price) of assets instead of the absolute amounts.\n\n$$\n\\Delta x = L \\cdot \\Delta \\frac 1 {\\sqrt P} \\qquad\n$$\n\n$$\n\\Delta y = L \\cdot \\Delta {\\sqrt P} \\qquad\n$$\n\n#### Swap $X$ for $Y$\n\nGiven the **exact input $\\Delta x$**, we want to compute the output $\\Delta y$. In order to calculate $\\sqrt{P_\\text{new}}$, we need to transform the above equation.\n\n<details>\n<summary> Derivation\n\n$$\n\\sqrt P_\\text{new} = \\frac  {L\\sqrt P} {\\Delta x \\sqrt P + L}\n$$\n\n</summary>\n\nWe can derive the formula by rearranging the formula above.\n\n$$\n\\begin{aligned}\n     && L \\cdot \\left ( \\frac 1 {\\sqrt P_\\text{new}} - \\frac 1 {\\sqrt P} \\right )&= \\Delta x  \\\\\n\\iff && \\frac 1 {\\sqrt P_\\text{new}} - \\frac 1 {\\sqrt P} &= \\frac {\\Delta x} L \\\\\n\\iff && \\frac 1 {\\sqrt P_\\text{new}} &= \\frac {\\Delta x} L + \\frac 1 {\\sqrt P} \\\\\n\\iff && \\sqrt P_\\text{new} &= \\left( \\frac {\\Delta x \\sqrt P + L} {L\\sqrt P} \\right)^{-1} \\\\\n\\iff && \\sqrt P_\\text{new} &= \\frac  {L\\sqrt P} {\\Delta x \\sqrt P + L}  \\\\\n\\end{aligned}\n$$\n\n</details>\n\nOnce we know the change in price $\\Delta P$, the change in the $X$ asset $\\Delta x$ is easy to compute.\n\n$$\n\\sqrt P_\\text{new} = \\frac  {L\\sqrt P} {\\Delta x \\sqrt P + L} \\qquad\n\\Delta y = L \\cdot (\\sqrt P_\\text{new} - \\sqrt P)\n$$\n\nNote that, if we want to specify the **exact output $\\Delta y$** instead, we need to compute\n\n$$\n\\sqrt P_\\text{new} = \\frac {\\Delta y + L \\cdot \\sqrt P} L \\qquad\n\\Delta x = L \\cdot \\left ( \\frac 1 {\\sqrt P_\\text{new}} - \\frac 1 {\\sqrt P}\\right ) \\;.\n$$\n\n#### Swap $Y$ for $X$\n\nWe have already computed the formulas for a general change in the assets (the $\\Delta$ can be positive or negative). Meaning that, in order to compute the new price $\\sqrt p _\\text{new}$ given the **exact input $\\Delta y$** we can just proceed with the formula above.\n\nThe same goes for when we want to compute the input $\\Delta y$, given the **exact output $\\Delta x$**.\n\n### Fees\n\n`feeGrowthGlobal` $f_{g}$ tracks the total amount of fees earned per unit of virtual liquidity for each token. These correspond to the fees earned for one unit of liquidity since the initialization of the protocol.\n\n`protocolFees` $f_p$ track the fees earned by the protocol (enabled and collected through governance). We'll ignore these for now.\n\nWhen a swap is performed, the fees are applied to the input and the accumulated fees are increased:\n\n$$\nf_g = y_{in} \\cdot \\gamma\n$$\n\n> NOTE: Shouldn't it be accounted per liquidity?\n\n$$\n\\Delta y = y_{in} \\cdot (1 - \\gamma)\n$$\n\nWhen calculating the fees owed to a liquidity provider's position, the delta in fee growth since the last update is multiplied by the liquidity size of the position. One thing to take into account is that a liquidity provider only earns fees for the range that they are providing liquidity for.\n\n### Ticks\n\nThe valid price ranges can be selected from a discrete set prices, represented by ticks.\n\n$$\np(i) = 1.0001^i\n$$\n\nFor technical reasons, the square root price is tracked.\n\n$$\n\\sqrt {p(i)} = 1.0001^{i / 2}\n$$\n\nGiven a price $P$, we can find the lower tick $i$ through the formula:\n\n$$\ni = \\lfloor \\log _{\\sqrt 1.0001} (\\sqrt P) \\rfloor\n$$\n\nAny provided ticks must be exactly `tickSpacing` apart from each other.\n\n## Code References\n\n### Pools\n\n**Immutable Parameters:**\n\n| Type    | Variable Name         | Notation | Description                                                                                         |\n| ------- | --------------------- | -------- | --------------------------------------------------------------------------------------------------- |\n| int24   | `tickSpacing`         |          | The fixed distance between ticks                                                                    |\n| uint24  | `fee`                 | $\\gamma$ | The liquidity provider fee charged on every swap                                                    |\n| uint128 | `maxLiquidityPerTick` |          | The maximum amount of liquidity that can be stored in a tick $\\frac {2^{128} - 1} {n_\\text{ticks}}$ |\n\n**Global state:**\n\n| Type    | Variable Name          | Notation  | Description                                                                                  |\n| ------- | ---------------------- | --------- | -------------------------------------------------------------------------------------------- |\n| uint128 | `liquidity`            | $L$       | Tracks total liquidity of current/active tick                                                |\n| uint160 | `sqrtPriceX96`         | $\\sqrt P$ | Stores $\\lfloor \\sqrt P \\cdot 2^{96}\\rfloor$                                                 |\n| int24   | `tick`                 | $i_c$     | The current active tick $i_c = \\lfloor \\log _{\\sqrt 1.0001} (\\sqrt P) \\rfloor$               |\n| uint256 | `feeGrowthGlobal0X128` | $f_{g,0}$ | Tracks accumulated fees per liquidity for asset $X$. Grows with $\\gamma \\cdot (1 - \\phi)$    |\n| uint256 | `feeGrowthGlobal1X128` | $f_{g,1}$ |                                                                                              |\n| uint128 | `protocolFees.token0`  | $f_{p,0}$ | Tracks accumulated protocol fees per liquidity for asset $X$. Grows with $\\gamma \\cdot \\phi$ |\n| uint128 | `protocolFees.token1`  | $f_{p,1}$ |                                                                                              |\n\n### Tick Information\n\n#### Conversion\n\n<!-- gh-embed:Uniswap:v3-core:d8b1c635c275d2a9450bd6a78f3fa2484fef73eb:contracts/libraries/TickMath.sol:18:23 -->\n\n**[TickMath.sol](https://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/contracts/libraries/TickMath.sol#L18-L23)**\n\n```sol\n/// @notice Calculates sqrt(1.0001^tick) * 2^96\n/// @dev Throws if |tick| > max tick\n/// @param tick The input tick for the above formula\n/// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n/// at the given tick\nfunction getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n```\n\n<!-- gh-embed:Uniswap:v3-core:d8b1c635c275d2a9450bd6a78f3fa2484fef73eb:contracts/libraries/TickMath.sol:56:61 -->\n\n**[TickMath.sol](https://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/contracts/libraries/TickMath.sol#L56-L61)**\n\n```sol\n/// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n/// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n/// ever return.\n/// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n/// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\nfunction getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n```\n\n#### State\n\nThe tick information is stored in mappings in a pool.\n\n<!-- gh-embed:Uniswap:v3-core:d8b1c635c275d2a9450bd6a78f3fa2484fef73eb:contracts/UniswapV3Pool.sol:92:95 -->\n\n**[UniswapV3Pool.sol](https://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/contracts/UniswapV3Pool.sol#L92-L95)**\n\n```sol\n/// @inheritdoc IUniswapV3PoolState\nmapping(int24 => Tick.Info) public override ticks;\n/// @inheritdoc IUniswapV3PoolState\nmapping(int16 => uint256) public override tickBitmap;\n```\n\n`tickBitMap` simply keeps track of whether a particular tick has been initialized.\n`ticks` stores all the information related to a ticks liquidity and fees.\n\n<!-- gh-embed:Uniswap:v3-core:d8b1c635c275d2a9450bd6a78f3fa2484fef73eb:contracts/libraries/Tick.sol:16:37 -->\n\n**[Tick.sol](https://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/contracts/libraries/Tick.sol#L16-L37)**\n\n```sol\n// info stored for each initialized individual tick\nstruct Info {\n    // the total position liquidity that references this tick\n    uint128 liquidityGross;\n    // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),\n    int128 liquidityNet;\n    // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n    // only has relative meaning, not absolute — the value depends on when the tick is initialized\n    uint256 feeGrowthOutside0X128;\n    uint256 feeGrowthOutside1X128;\n    // the cumulative tick value on the other side of the tick\n    int56 tickCumulativeOutside;\n    // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n    // only has relative meaning, not absolute — the value depends on when the tick is initialized\n    uint160 secondsPerLiquidityOutsideX128;\n    // the seconds spent on the other side of the tick (relative to the current tick)\n    // only has relative meaning, not absolute — the value depends on when the tick is initialized\n    uint32 secondsOutside;\n    // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0\n    // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks\n    bool initialized;\n}\n```\n\n## Flows\n\n### Providing Liquidity\n\n<!-- gh-embed:Uniswap:v3-core:d8b1c635c275d2a9450bd6a78f3fa2484fef73eb:contracts/UniswapV3Pool.sol:457:463 -->\n\n**[UniswapV3Pool.sol](https://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/contracts/UniswapV3Pool.sol#L457-L463)**\n\n```sol\nfunction mint(\n    address recipient,\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 amount,\n    bytes calldata data\n) external override lock returns (uint256 amount0, uint256 amount1) {\n```\n\n**requires**\n\n- `amount != 0`\n- `TickMath.MIN_TICK <= tickLower < tickUpper <= TickMath.MAX_TICK`\n- `tickUpper - tickLower % tickSpacing == 0`\n- `liquidityGrossAfter <= maxLiquidity`\n\n**steps**\n\n- updates position `[tickLower, tickUpper]` of `recipient` by `liquidityDelta`\n  - update {lower,upper} tick info\n    - STORE initial tick params\n      - from current global state params if {lower,upper} tick < current tick\n        -       info.feeGrowthOutside0X128 = feeGrowthGlobal0X128;\n                info.feeGrowthOutside1X128 = feeGrowthGlobal1X128;\n                info.secondsPerLiquidityOutsideX128 = secondsPerLiquidityCumulativeX128;\n                info.tickCumulativeOutside = tickCumulative;\n                info.secondsOutside = time;\n      - else default (0)\n    - STORE `tick.liquidityGross += liquidityDelta`\n    - STORE `tick.liquidityNet += liquidityDelta` if lower tick\n    - STORE `tick.liquidityNet -= liquidityDelta` if upper tick\n  - STORE activated state for {lower,upper} tick in `tickBitmap` depending on change in `liquidityGross`\n  - compute `feeGrowthInside0X128`, `feeGrowthInside1X128`\n  - update recipient position\n    - sd\n- calculate `amount0` and `amount1` required from `recipient`\n  - if `currentTick < tickLower`, then `amount0 = amount`\n\n**Questions**\n\n- is `tick.liquidityNet = +/- tick.liquidityGross`? Why is it being tracked separately\n","title":"UniswapV3","date":"Apr 5, 2023","excerpt":"Auditor Notes on UniswapV3"}},"__N_SSG":true}