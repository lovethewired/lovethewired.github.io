{"pageProps":{"allPostsData":[{"slug":"blog/2022/clones-with-immutable-args-comparison","contentRaw":"\n[Clones with immutable args](https://github.com/wighawag/clones-with-immutable-args) (CWIA) aim to save gas by avoiding storage reads and writes. \n\n\nClones - and proxies alike - usually contain a initializer function to set parameters specific to the clone. This is due to the nature of contracts that function as proxies. Typically they use standardized and optimized implementations that contain minimal logic and forward all calls to an contract that handles the implementation logic. \n\nImmutable variables are useful, because instead of writing these variables into the contract's storage space, they are directly included in the contract's runtime bytecode. They work in a similar way as variables that are declared to be constant, but they are evaluated and inserted during contract creation - in the constructor.\n\nSince solidity does not allow for dynamic type immutable variables, it's not that straightforward to write a clone/proxy contract that will just take in a immutable string of bytes to be easily accessed in the implementation contract.\n\nAnother reason for the slow adoption of clones that use immutable args is that they are often heavily optimized. [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167) formalizes the specs for minimal proxy clones. \n\n```ERC1167Clone.evm\n0x363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3\n```\n\nBecause EIP-1667 clones can easily be identified by checking their bytecode, services such as [etherscan](https://etherscan.io) are able to detect these. \nIf the contract were to include immutable args however, this would require more rules in order to identify such contracts, because the immutable args must be included in the contract's runtime code.\n\n<!-- Clones, much like proxies typically only contain minimal logic and use the `delegatecall` opcode to refer to another contract for the implementation details. Because solidity does not allow for dynamic type immutable variables, it is not possible to pass arbitrary bytes to the clone contract to store these in the contract code versus the contract storage.\nEven if we were to use a specialized clone that is able to set immutable variables in its constructor, this could be problematic. Clones are heavily optimized (and written in bytecode) to contain minimally required bytes in order to reduce gas costs when deploying and when interacting with these contracts.\n\n[EIP-1167](https://eips.ethereum.org/EIPS/eip-1167) formalizes the spec for minimal proxy clones. Because they always have the same bytecode, they can easily be detected as clones by services such as [etherscan](https://etherscan.io). \nImmutable variables are similar to constants, except for that they are evaluated during constructor call and replaced in the contract runtime code.\nThis means that they actually end up in the contract's runtime code. Two contracts initialized with different immutable variables will end up having a different runtime code. \nIt would be possible to \nAnd since there has not been any spec to account for \n\nNormally, if one wants to pass data to when using [EIP-1167 Minimal Proxy Clones](https://eips.ethereum.org/EIPS/eip-1167)clones, a clone will contain an `init()` function which is called upon construction with parameters that end up getting stored in the clone's contract storage.\nwould be required \n\nCWIA work by appending the immutable args -->\n\n\n# Clones with immutable args - via `CALL`\n\nTo illustrate some of the ideas behind clones with immutable args, we \ncan think of a minimal clone contract that takes in an immutable arg as a parameter.\n\n```CloneWithImmutableArgsVer1.sol\ncontract CloneWithImmutableArgsVer1 {\n    address private immutable logic;\n    uint256 public immutable immutableArg0;\n\n    constructor(address logic_, uint256 immutableArg0_) payable {\n        logic = logic_;\n        immutableArg0 = immutableArg0_;\n    }\n\n    fallback() external payable {\n        address logic_ = logic;\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n\n            let success := delegatecall(gas(), logic_, 0, calldatasize(), 0, 0)\n\n            returndatacopy(0, 0, returndatasize())\n\n            if success {\n                return(0, returndatasize())\n            }\n\n            revert(0, returndatasize())\n        }\n    }\n}\n```\n\nThis contract takes in a `address logic_` to which all calls are delegated to and a `uint256 immutableArg0_` that is accessible to the clone as a public function.\n\n<!-- While writing the contracts in solidity makes it easy to follow along and understand the ideas, the resulting bytecode ends up being much bigger compared to the optimized EIP-1167 clones.\n\n```CloneWithImmutableArgsVer1.evm\n0x608060405260043610601c5760003560e01c80634134658c146060575b7f000000000000000000000000ce71065d4017f316ec606fe4422e11eb2c47c2463660008037600080366000845af43d6000803e8015605a573d6000f35b503d6000fd5b348015606b57600080fd5b5060927f000000000000000000000000000000000000000000000000000000000000133781565b60405190815260200160405180910390f3fea164736f6c634300080f000a\n```\n\nClones are often used in clone factories where many hundred or thousand clones are created - such as AMM pools. The logic thus has to be heavily optimized to reduce deployment costs and gas costs when interacting with the contracts.\n\nThe consequences are that \n1) deploying these clones will have a higher cost - due to increased bytecode size\n2) Calling such a clone will have a higher cost - due to the increased bytecode size and due to having 2 function dispatchers now, one in the clone and one in the logic -->\n\nThere is still one problem, however. We usually will want to access `immutableArg0` from within the logic contract. Since the logic contract does not know about `immutableArg0` - let alone the clone contract itself - it is not directly available to the implementation.\nAlthough, since we know that we will be calling the logic contract via `delegatecall`, we can call back into the clone contract via `CloneWithImmutableArgsVer1(address(this)).immutableArg0()` to access the variable.\n\n> Essentially this method will result in an additional `call` operation and a `codecopy` operation once the context is set back to the clone contract. `staticcall` could also be used instead to ensure that no persistent changes are being made.\n\nAnother problem is that the current contract only works for one fixed 32 bytes word. \nIdeally, we would be able to store and access arbitrary byte strings.\nA way to get around this is shown in the next possible method that uses `extcodecopy`.\n\n\n# Clones with immutable args - via `EXTCODECOPY`\n\nInstead of calling back into the clone contract, we could also directly access the bytes via `extcodecopy` while remaining in the context of the implementation contract.\nThis example will work with immutable args that can be bytes of arbitrary lengths.\n\n```ClonesWithImmutableArgsVer2.sol\ncontract CloneBase {\n    fallback() external payable {\n        address logic = ImmutableArgsVer2Lib.getLogicAddress();\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n\n            let success := delegatecall(gas(), logic, 0, calldatasize(), 0, 0)\n\n            returndatacopy(0, 0, returndatasize())\n\n            if success {\n                return(0, returndatasize())\n            }\n\n            revert(0, returndatasize())\n        }\n    }\n}\n\ncontract ClonesWithImmutableArgsVer2 {\n    constructor(address logic, bytes memory immutableArgs) payable {\n        bytes memory code = abi.encodePacked(\n            type(CloneBase).runtimeCode,\n            immutableArgs,\n            uint16(immutableArgs.length),\n            logic\n        );\n\n        assembly {\n            return(add(code, 0x20), mload(code))\n        }\n    }\n}\n```\n\nThe delegatecall logic in the fallback function remains the same, except that we are now reading the address of the logic contract using a library function `ImmutableArgsVer2Lib.getLogicAddress()` - which we'll get into in a bit. \n \nOut goal is to append additional data - the immutable args - to the contract bytecode so that we can cheaply access these later. \n`ClonesWithImmutableArgsVer2` acts as a kind of \"wrapper\" contract that returns the code of the underlying contract - `CloneBase` - with additional data appended - the immutable args, the length of the immutable args and the logic contract. \n\nSince we're accessing `type(CloneBase).runtimeCode` we need to avoid any `immutable` keywords, because these would not be available in the runtime code. That's why we also append the `logic` address to the contract code to be able to access this in the fallback function of the clone.\n\nWe now need to write the functions that will make it possible to retrieve `address logic` and `bytes immutableArgs` from the contract code.\n\n```ImmutableArgsVer2Lib.sol\n library ImmutableArgsVer2Lib {\n    function getLogicAddress() internal returns (address logic) {\n        assembly {\n            // `address logic` is encoded into bytecode at last position.\n            // Load 20 bytes (0x14) starting from end - 20 bytes.\n            let offsetLogic := sub(codesize(), 0x14)\n            // Store in scratch space in first slot at 12 bytes (0x0c = 32 - 20) offset.\n            codecopy(0x0c, offsetLogic, 0x14)\n            // Load first memory slot to retrieve the address.\n            logic := mload(0)\n        }\n    }\n\n    function getImmutableArgs() internal returns (bytes memory args) {\n        assembly {\n            // Clear dirty scratch space.\n            mstore(0, 0)\n\n            let codeSize := extcodesize(address())\n            // The offset for the length of the args is stored\n            // at `codeSize - 20 - 2` (20 bytes address + 2 bytes length)\n            let argsLenOffset := sub(codeSize, 0x16)\n\n            // Load length of immutable args from contract bytecode.\n            extcodecopy(address(), 0x1e, argsLenOffset, 0x02)\n\n            let argsLen := mload(0)\n            let argsOffset := sub(argsLenOffset, argsLen)\n\n            // Place `args` at free memory position.\n            args := mload(0x40)\n            // Store length of `args` bytes-array.\n            mstore(args, argsLen)\n\n            // Copy immutable args to `args` memory offset.\n            extcodecopy(address(), add(args, 0x20), argsOffset, argsLen)\n\n            // Advance the `memPtr` by `argsLen + 0x20`,\n            // rounded up to the next multiple of 32.\n            mstore(0x40, shl(5, shr(5, add(add(args, argsLen), 0x3f))))\n        }\n    }\n}\n```\n\nNotice how `getLogicAddress()` uses `codecopy` and how `getImmutableArgs()` uses `extcodecopy`.\nThis is because `getLogicAddress()` will be executed in the context of the clone - meaning the address is stored in the current runtime code - whereas `getImmutableArgs()` will be executed in the context of the logic contract, which is unable to access the immutable args stored in the runtime code and thus must use `extcodecopy`.\n\n# Clones with immutable args - via `CALLDATA`\n\nThe [original clones with immutable args](https://github.com/wighawag/clones-with-immutable-args) uses another trick. The immutable args are directly appended to the calldata of the delegatecall in the clone's fallback function.\n\n`CloneWithImmutableArgsVer3`'s constructor code remains the same as `CloneWithImmutableArgsVer2`.\n\n```CloneWithImmutableArgsVer3.sol\ncontract CloneWithImmutableArgsVer3 {\n    constructor(address logic, bytes memory immutableArgs) payable {\n        bytes memory code = abi.encodePacked(\n            type(CloneBaseVer3).runtimeCode,\n            immutableArgs,\n            uint16(immutableArgs.length),\n            logic\n        );\n\n        assembly {\n            return(add(code, 0x20), mload(code))\n        }\n    }\n}\n```\n\nNow when we make the delegatecall, we need to concatenate the the following data in memory: calldata + immutable args + uint16 length of immutable args. Retrieving and copying the immutable args works exactly the same as with the previous version, except that, since we're in the clone's context, we can use `codesize` and `codecopy` instead of `extcodesize` and `extcodecopy`.\n\n```CloneWithImmutableArgsVer3.sol\ncontract CloneBaseVer3 {\n    fallback() external payable {\n        address logic = ImmutableArgsVer2Lib.getLogicAddress();\n\n        assembly {\n            // Clear dirty scratch space.\n            mstore(0, 0)\n\n            // Get length and offset of immutable args.\n            let argsLenOffset := sub(codesize(), 0x16)\n            codecopy(0x1e, argsLenOffset, 0x02)\n\n            let argsLen := mload(0)\n            let argsOffset := sub(argsLenOffset, argsLen)\n\n            calldatacopy(0, 0, calldatasize())\n\n            // Copy immutable args to end of calldata in memory.\n            codecopy(calldatasize(), argsOffset, argsLen)\n            // Append the length of the immutable args to the end.\n            mstore8(add(calldatasize(), argsLen), shr(8, argsLen))\n            mstore8(add(add(calldatasize(), argsLen), 1), argsLen)\n\n            let success := delegatecall(gas(), logic, 0, add(add(calldatasize(), argsLen), 2), 0, 0)\n\n            returndatacopy(0, 0, returndatasize())\n\n            if success {\n                return(0, returndatasize())\n            }\n\n            revert(0, returndatasize())        \n        }\n    }\n}\n```\n\nNow the implementation contract will have direct access to the immutable args via calldata. This part is left out, because it works in pretty much the same way as retrieving immutable args from the contract code.\n\nThis method has the benefit that it doesn't need to make another external call or copy external code (since it uses `codecopy` instead). \nAccessing the immutable args via calldata is cheap and almost practically negligible - except for when this is run on rollups that commit calldata to the root chain (here calldata makes up for over 50% of the transaction cost). Yet, unlike before, where we only access the immutable args when needed, these are always appended to any function call - no matter if they are required or not.\n\n\n# Tradeoffs and Gas Comparisons\n\nThe full code for all comparisons can be found here https://github.com/0xPhaze/clones-with-immutable-args-comparison (though method 1 and method 3 are swapped here).\nThe clone implementations are written in pure bytecode to better understand the limits.\nThe methods that use `codecopy` could however, still be further optimized to not use `codecopy` at all, but to loop over `push` opcodes that push the data directly onto the stack and store it in memory.\n\n|  | Relevant Opcodes | Notes |\n|:--:  | :--: | :--: \n| Method 1 | `call` + `codecopy` | Calls back into clone contract to retrieve immutable arg. |\n| Method 2 | `extcodecopy` | Loads external code from clone contract. |\n| Method 3 | `codecopy` + `calldataload` | Adds a gas overhead to EVERY function call |\n\nI ran multiple tests and plotted the results to get a better feel for the behavior of the gas costs. Below is a comparison between method 2 and method 3. Method 1 was left out, as it behaved much like method 2, but slightly worse.\n\n![gas-cost-comparison](/data/blog/2022/clones-with-immutable-args-comparison/gas-cost-comparison.png)\n\nThe plot shows the gas costs for reading x bytes from the immutable args from immutable args with varying lengths. In most cases, using method 3, i.e. reading args from calldata will be cheaper. Using `extcodecopy` (method 2) becomes cheaper after a certain amount of bytes (1.5k-2k).\n\nThe aforementioned gas overhead (for method 3) can be seen for the purple line - reading 0 bytes is the overhead added to any other call that does not need to read immutable bytes. Here, method 2 is cheaper and stays pretty much constant, while it increases linearly with the length of the stored immutable args for method 3 - when the args are appended to the calldata.","title":"Clones With Immutable Args","suptitle":"Gas Comparisons","date":"23 Oct 2022","excerpt":"Clones with immutable args aim to save gas by avoiding storage reads and writes."},{"slug":"blog/2022/abi-decoding-calldata","contentRaw":"\n`abi.decode(data, (type))` can be used to decode abi-encoded bytes located in memory and calldata. Currently, it's only possible to assign dynamic types to memory. Decoding to calldata is not supported yet, however, this can still be achieved manually.\n\nSay we wanted to send a NFT cross-chain. For this we have have to encode a message that could look like this.\n\n```FxERC721Root.sol\nbytes4 constant REGISTER_ERC721_IDS_SELECTOR = \n    bytes4(keccak256(\"registerERC721IdsWithChild(address,uint256[])\"));\n\n    function _registerERC721IdsWithChild(address to, uint256[] calldata ids) internal virtual {\n        bytes memory message = abi.encodeWithSelector(REGISTER_ERC721_IDS_SELECTOR, to, ids); // highlight-line\n\n        _sendMessageToChild(message);\n    }\n```\n\nThe child chain can receive the full message as `calldata`, run some security checks and then process it in another function.\n\n\n```FxERC721Child.sol\n    function processMessageFromRoot(\n        uint256 stateId,\n        address rootMessageSender,\n        bytes calldata message // highlight-line\n    ) external {\n        if (msg.sender != fxChild) revert CallerNotFxChild();\n        if (rootMessageSender == address(0) || rootMessageSender != s().fxRootTunnel) revert InvalidRootSender();\n\n        _processMessageFromRoot(stateId, rootMessageSender, message);\n    }\n```\n\nSolidity does not allow us to decode the ids as a `uint256[] calldata` array directly yet. I.e. the following \n```solidity\n    (address to, uint256[] calldata ids) = abi.decode(message[4:], (address, uint256[]));\n```\nwould fail with the message:\n`\"TypeError: Type uint256[] memory is not implicitly convertible to expected type uint256[] calldata.\"`\n\nHowever, by declaring `uint256[] calldata ids;` and manually setting `ids.offset` and `ids.length` via assembly, we can manually decode the data.\nFor more on the abi encoding spec, read up on the [docs](https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#argument-encoding).\n\n```FxERC721Child.sol\n    function _processMessageFromRoot(\n        uint256,\n        address,\n        bytes calldata message\n    ) internal virtual override {\n        bytes4 selector = bytes4(message);\n\n        if (selector != REGISTER_ERC721_IDS_SELECTOR) revert InvalidSelector();\n\n        address to = address(uint160(uint256(bytes32(message[4:36]))));\n\n        uint256[] calldata ids;\n        // abi-decode `ids` directly in calldata.\n        assembly {\n            // Skip bytes4 selector + bytes32 encoded address\n            // starting from message's offset in calldata\n            // to get the relative offset of the uint256[] encoded array's size.\n            let idsLenOffset := add(add(message.offset, 0x04), calldataload(add(message.offset, 0x24)))\n            ids.length := calldataload(idsLenOffset)\n            ids.offset := add(idsLenOffset, 0x20)\n        }\n\n        _registerIds(to, ids);\n    }\n\n    function _registerIds(address to, uint256[] calldata ids) internal virtual {\n        for (uint256 i; i < ids.length; ++i) {\n            _registerId(to, ids[i]);\n        }\n    }\n```\n\nHere's an example of a call to the function `processMessageFromRoot()`.\n\n```sol\n    child.processMessageFromRoot(\n        1,\n        address(this),\n        abi.encodeWithSelector(REGISTER_ERC721_IDS_SELECTOR, address(0xbabe), 31.range(34))\n    );\n```\n\nIn this case, the calldata would look like this.\n\n```sol\n  [selector] 0x9a7c4b71 // processMessageFromRoot.selector\n  [0x00] 0000000000000000000000000000000000000000000000000000000000000001 // stateId\n  [0x20] 000000000000000000000000b4c79dab8f259c7aee6e5b2aa729821864227e84 // rootMessageSender\n  [0x40] 0000000000000000000000000000000000000000000000000000000000000060 // message.length offset\n  [0x60] 00000000000000000000000000000000000000000000000000000000000000c4 // message.length\n  [0x80] 4d26d408000000000000000000000000000000000000000000000000000000000000babe00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000001f0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002100000000000000000000000000000000000000000000000000000000 // encoded message\n```\n\n> Note: Even though the message length is located at message[0x64:0x84] the offset (of message.length) is set to 0x60, since the selector is not counted.\n\nBecause the message is abi-encoded separately, the offsets in the encoded bytes are relative to the start of the message after the selector.\n\n```sol\n  [selector] 0x4d26d408 // REGISTER_ERC721_IDS_SELECTOR\n  [0x00] 000000000000000000000000000000000000000000000000000000000000babe // address to\n  [0x20] 0000000000000000000000000000000000000000000000000000000000000040 // ids.length relative offset\n  [0x40] 0000000000000000000000000000000000000000000000000000000000000003 // ids.length\n  [0x60] 000000000000000000000000000000000000000000000000000000000000001f // ids[0]\n  [0x80] 0000000000000000000000000000000000000000000000000000000000000020 // ids[1]\n  [0xa0] 0000000000000000000000000000000000000000000000000000000000000021 // ids[2]\n  [0xc0] 00000000000000000000000000000000000000000000000000000000 // padded zeros\n```\n\nThis means that, if we want to get the correct calldata offset for `ids.offset`, we need\nto load the word located at 0x20 in the encoded message. In order to get the absolute position in the calldata, we thus need to add the offset of the message in the calldata to 0x24 - the 4 bytes selector from the message must be taken into account, since the message is embedded into the calldata as bytes.\n\n```sol\n    let idsOffsetRel := calldataload(add(message.offset, 0x24))\n```\n\nNow to get the absolute offset of `ids.length` we need to add the position of where the relative offset in the message starts: `message.offset + 0x04` - the starting location of the message + the encoded selector.\n\n```sol\n    let idsLenOffset := add(add(message.offset, 0x04), idsOffsetRel)\n```\n\nNow that we have the offset of the length, we just need to load it from the calldata. By looking at the encoding we can also see that we simply need to add one word (0x20) to find the start of the `uint256[]` data - `ids.offset`.\n\n```sol\n    ids.length := calldataload(idsLenOffset)\n    ids.offset := add(idsLenOffset, 0x20)\n```\n\n## Why not just hardcode the offset?\n\nWe could also simply hardcode the values for `ids.length` and `ids.offset` after we have calculated them once. \n\n```sol\n    ids.offset := 0xe8\n    ids.length := calldataload(sub(ids.offset, 0x20))\n```\n\nThis works as long as the function signature won't change (so that the offset of `message` doesn't change) and the calldata is encoded in a standard way.\n\nWe can create a non-standard encoding by adding useless filler data for example and we quickly see why the hardcoded version will not work anymore.\n\n```sol\n    address(child).call(\n        hex\"9a7c4b71\"                                                         // processMessageFromRoot.selector\n        hex\"0000000000000000000000000000000000000000000000000000000000000001\" // stateId\n        hex\"000000000000000000000000b4c79dab8f259c7aee6e5b2aa729821864227e84\" // rootMessageSender\n        hex\"0000000000000000000000000000000000000000000000000000000000000080\" // message.length offset\n        hex\"ccaaffeeccaaffeeccaaffeeccaaffeeccaaffeeccaaffeeccaaffeeccaaffee\" // ??\n        hex\"00000000000000000000000000000000000000000000000000000000000000e4\" // message.length\n        hex\"4d26d408\"                                                         // REGISTER_ERC721_IDS_SELECTOR\n        hex\"000000000000000000000000000000000000000000000000000000000000babe\" // address to\n        hex\"0000000000000000000000000000000000000000000000000000000000000060\" // ids.length relative offset\n        hex\"ccaaffeeccaaffeeccaaffeeccaaffeeccaaffeeccaaffeeccaaffeeccaaffee\" // ??\n        hex\"0000000000000000000000000000000000000000000000000000000000000003\" // ids.length\n        hex\"000000000000000000000000000000000000000000000000000000000000001f\" // ids[0]\n        hex\"0000000000000000000000000000000000000000000000000000000000000020\" // ids[1]\n        hex\"0000000000000000000000000000000000000000000000000000000000000021\" // ids[2]\n        hex\"00000000000000000000000000000000000000000000000000000000\"         // padded zeros\n    );\n```\n\nWithout hardcoding the offsets, reading the `uint256[] calldata` from the above encoding will still be possible.\n\n\n\n\n# Gas Savings\n\nAbi-decoding directly to calldata can avoid copying data to memory.\nThis saves us a few `mstore` and `mload` operations.\nBelow is a comparison of the gas savings for encoding a certain number of ids.\n\n\n| #ids | Calldata | Memory | Difference |\n| --- | --- | --- | ---- |\n| 0 | 1125 |1552 | 427 |\n| 1 | 2271 |2775 | 504 |\n| 2 | 3197 |3781 | 584 |\n| 3 | 4126 |4790 | 664 |\n| 4 | 5050 |5794 | 744 |\n| 5 | 5977 |6801 | 824 |\n| 6 | 6904 |7809 | 905 |\n| 7 | 7835 |8820 | 985 |\n| 8 | 8760 |9825 | 1065 |\n| 9 | 9694 |10839 | 1145 |\n\n\nIn this case, using calldata over memory can save us 427 gas + roughly an additional 80 gas per extra word.","title":"ABI-Decoding Calldata","date":"22 Oct 2022","excerpt":"Abi-decode directly in calldata without using memory."},{"slug":"audit/2022/haki-audit","contentRaw":"\n\n# Table of Contents\n\n# Context\n\nThe audit was performed as a \"non-extensive review\".\nThis means that solely the code is reviewed as is\nand no further tests have been prepared for this review.\nUnit-tests are essential for ensuring correct behavior and calculations.\n\nThis audit is a review of the [Haki staking contracts](https://github.com/rekttdoteth/haki-staking-contract)\n(private)\nand was performed at commit\n[77865daafe1311dd45ad29bb8087f55fdc660c54](https://github.com/rekttdoteth/haki-staking-contract/commit/77865daafe1311dd45ad29bb8087f55fdc660c54).\n\nThe given repository itself contains no tests.\n\n**Focus:**\n\nGas optimizations (specifically storage accesses) \non `TheShrine.sol` (to be deployed on Ethereum) are highlighted, whereas they are largely ignored for `ShrineToken.sol` (to be deployed on Polygon).\n\nSpecial attention was given to unauthorized access-control and exploitability. Logical errors were covered as best as possible,\nalthough these require extensive unit-testing to cover appropriately.\n\n# Overview\n\nThe client has designed contracts that allow for staking of ERC721 NFTs.\nWhile the staking itself will be performed on Ethereum, \nstaking rewards are emitted as ERC20 tokens on Polygon.\nThe communication between the chains is done using Polygon's \n[flexible portal contracts](https://github.com/fx-portal/contracts).\nStaking on Ethereum is handled by\n`TheShrine.sol` which is designed to be able to handle multiple ERC721 contracts.\n`ShrineToken.sol` is an ERC20 token on Polygon that contains logic\nto handle state updates from the root contract `TheShrine.sol`.\n`SekiraVerifier.sol` acts as a simple \"proxy\" that allows counting owned and staked NFT balances for the _Sekira_ contract.\n\n\n# Scope\n\nThe repository contains the following contracts\n```ml\n└── contracts\n    ├── ERC20.sol\n    ├── ExitPayloadReader.sol\n    ├── FxBaseChildTunnel.sol\n    ├── FxBaseRootTunnel.sol\n    ├── Merkle.sol\n    ├── MerklePatriciaProof.sol\n    ├── RLPReader.sol\n    ├── SekiraVerifier.sol\n    ├── ShrineToken.sol\n    └── TheShrine.sol\n```\n\nAs a basis for the ERC20 contract, `ShrineToken.sol` uses Rari-Capital solmate's [ERC20 implementation](https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol) `ERC20.sol`.\nNo noteworthy differences to the [latest commit](https://github.com/Rari-Capital/solmate/commit/25015a1d18e75921f8cb1bacd4beb9f364e788a9) exist.\n\nPolygon's [flexible portal contracts](https://github.com/fx-portal/contracts)\nare being used for message passing between Ethereum and Polygon.\nNo noteworthy differences to the [latest commit](https://github.com/fx-portal/contracts/commit/baed24d22178201bca33140c303e0925661ec0ac) exist.\n\nThese external contracts are out of scope.\nThe focus of the review is narrowed down to the following contracts.\n\n```ml\n└── contracts\n    ├── SekiraVerifier.sol\n    ├── ShrineToken.sol\n    └── TheShrine.sol\n```\n\n# Summary\n\nNo critical errors were identified.\n\nThe contracts could benefit from simplification\nto reduce complexity, computation and storage access.\nFurthermore, although not explicitly detailed,\nrepetition of contract logic/functions can be avoided.\nThis would also help validate logic and improve readability.\nIt is further noted that the use of custom errors vs. require-statements could chosen consistently and docstring comments could be standardized.\n\n# Audit Findings Classifications\n\n# Medium Findings\n\n## :zap: [ShrineToken.sol] State-Desync Possible\n\nCurrently `ShrineToken.sol` gets relative balance updates from the root contract `TheShrine.sol` on Ethereum.\nA complete synchronization between the two chains is not guaranteed and incoming tokens are not validated to be uniquely counted in \n`userInfo.stakedBalance` and `userInfo.stakedIds`. \n\nSetting the child contract `ShrineToken.sol` to be paused\nwould lead to failed transactions and a state-desync when `_processMessageFromRoot` is called.\nThis would mean that, for example, unstaking on Ethereum L1\nwould not be updated on L2.\n\nThe results of this effect, however, are minimized due to the way \nrewards are being calculated.\nWhen claiming rewards, the ids found in `userInfo.stakedIds`\nare iterated over and the reward is calculated based on the\n`record` found for each individual id. The individual id is immediately \"marked\" as claimed by updating `stakeRecord.lastClaimed`.\n\nThis does, however, still mean that it could be possible for a user to claim\nrewards for an NFT no longer owned, even if it is currently being\nstaked by someone else. Additionally, this could lead to a higher `multipleStakedBoostThreshold`.\n\n**Mitigation:**\nNew token ids being registered in the `ShrineToken` contract could\ncheck whether they are currently still attributed to someone else\nin the system. If they are, they should be removed from that user's\nbalance/stake.\n\n\n## :zap: [TheShrine.sol] Hardcoded Testnet Address \n\n```TheShrine.sol\n    function balanceOf(address owner) external view returns (uint256) {\n        address hakiContract = 0xd053b4FdbC3470E6aAF9f65ED13AFDaA5af0d7E5; //highlight-line\n        return\n            addressToContractStakedIds[owner][hakiContract].length +\n            ERC721(hakiContract).balanceOf(owner);\n    }\n```\n\n`TheShrine.sol` contains a hardcoded `address hakiContract` which does not correspond to `address hakiERC721` of the constructor. This address currently only contains code on test-nets.\n\n**Mitigation:**\nUpdate address pointing to the correct ERC721 contract on Ethereum or declare a variable that is set\nby the constructor parameter.\n\n**Update:**\nThe client has responded that this address will be updated accordingly.\n\n\n# Minor Findings\n\n## :zap: [FxBaseRootTunnel.sol] Unprotected Function\n\n_Note: Originally declared as out of scope._\n\n```FxBaseRootTunnel.sol\n    function setFxChildTunnel(address _fxChildTunnel) public virtual { //highlight-line\n        require(fxChildTunnel == address(0x0), \"FxBaseRootTunnel: CHILD_TUNNEL_ALREADY_SET\");\n        fxChildTunnel = _fxChildTunnel;\n    }\n```\n\n`setFxChildTunnel` does not contain any access-control. Anyone is able to call this function. Although, once set, it cannot be changed due to the contract logic. Any malicious address is able to call this and essentially void the full contract if accidentally left unset.\nThis generally should be seen as bad practice, even if introduced by the Matic-Team.\n\n**Mitigation:**\nOverride function in inheriting contract `TheShrine.sol` and add the `onlyOwner` modifier.\nA check for whether it has been set already is not strictly necessary, otherwise this could be marked as immutable, furthermore ensuring that it is set and reducing gas costs.\n\n```TheShrine.sol\n    function setFxChildTunnel(address _fxChildTunnel) public override onlyOwner { //highlight-line\n        fxChildTunnel = _fxChildTunnel;\n    }\n```\n\n_Note:_\nThe same holds for `setFxRootTunnel` in `FxBaseChildTunnel.sol`.\n\n\n## :recycle: [ShrineToken.sol] Reduce Use of Permits\n\n`gaslessHarvest` and `gaslessHarvestByNFT` allow an authorized party\nto distribute pending rewards to a user.\nThese function are currently guarded by the `onlyHarvester` modifier\nonly allowing calls by previously authorized accounts.\n\n**Mitigation:**\nSince `_harvestReward` does not contain any security-critical\nlogic, this extra authorization could be foregone to increase simplicity.\n\n\n## :recycle: [ShrineToken.sol] Reduce Logic for Tracking Staked Contracts\n\n`_processMessageFromRoot` keeps track contracts a user\nhas any staked balances separately through the use of an 'enumerable set'\nstructure. This is done via the mapping `addressToContractIndex`\nthat keeps track of multiple values, including an index to `userInfo.stakedContract`. There are multiple variables that are being tracked\nthat could be redundant.\n\n\n**Mitigation:**\nTo reduce complexity, `addressToContractIndex` and `userInfo.stakedContract` could be removed and logic could be simplified:\nInstead of iterating over the `userInfo.stakedContract` array,\nlooping over both contracts and checking `userInfo.stakedIds[collection].length` would reduce complexity.\n\nA lot of the \"messy\" logic for enumerable sets can be hidden by using\ntrusted libraries, like [OpenZeppelin's Enumerable Set](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol).\n\n## :recycle: [TheShrine.sol] Nearly Identical Logic\n\n`stake` & `stakeMultiple` (and `unstake` & `unstakeMultiple`) largely contain the same code.\nThere is very little gas overhead involved when simply using `stakeMultiple`, `unstakeMultiple`,\nas these would likely involve only a few more stack-operations.\nRemoving duplicate code, reduces maintenance work and \nsimplifies interfacing the contract on a frontend\ndue to multiple choices of functions being considered.\n\n**Mitigation:**\nConsider removing `stake` and `unstake` functions.\n\n## :recycle: [TheShrine.sol] Reduce External Calls\n\n`_sendMessageToChild` is being called in a loop requiring multiple external calls (& memory accesses, event emissions).\n\n**Mitigation:**\nConsider directly encoding an array of token ids thus only requiring one message to be sent.\n\n```TheShrine.sol\n    _sendMessageToChild(\n        abi.encode(\n            msg.sender,\n            collection,\n            tokenIds[i], //del-line\n            tokenIds, //add-line\n            lockupDelta,\n            true\n        )\n    );\n```\n\n## :recycle: [TheShrine.sol] Optimize Storage Reads/Writes\n\nCurrently `TheShrine.sol` keeps track of token ownerships through the use of 3 mappings:\n- `contractToTokenStaker` (tracks token ownership)\n- `addressToContractStakedIds` (enumerable list of ids per user)\n- `contractToTokenIndex` (tracks indices in enumerable list)\n\nThis is comparable to `ERC721Enumerable` vs. `ERC721` (logic-wise and storage cost-wise). Reducing these mappings to one would simplify logic\nand lower gas costs.\n\n**Mitigation:**\nThe contract could simply track `contractToTokenStaker` (token ownerships) and balances.\n\n*Note:*\nBecause `contractToTokenIndex` is a mapping to a list, keeping track of ownerships\nin the `stake` function update involves 4 distinct storage slots,\nwhereas, if optimized, it would only involve one.\nThis would also remove the complexity of keeping track of and re-arranging indices.\n\n*Further Note:*\nBecause `contractToTokenIndex` and `unlockOn` share the same mapping keys, these\ncould further be combined into one packed storage slot instead of taking up 2 separate slots.\n\n\n\n## :recycle: [SekiraVerifier.sol] Remove Unused Logic\n\n`SekiraVerifier.sol`'s code size can be significantly reduced. This contract acts as a simple proxy that propagates owned balances and staked balances of the _Sekira_ ERC721. It does not require any of the existing ERC721 logic, as it is never expected to be called (there exists no logic for minting tokens).\nThe only function that is necessary (for collab.land) is `balanceOf`.\n\n**Mitigation:**\nConsider removing the ERC721 logic in order to save gas costs for deployment.\n\n**Update:**\nThe client has noted that they will be using *Whop* which requires some additional logic.\n\n\n## ️️:recycle: [FxBaseRootTunnel.sol] Make Non-Changing Variables Immutable\n\n_Note: Originally declared as out of scope._\n\n```FxBaseRootTunnel.sol\n    // state sender contract\n    IFxStateSender public fxRoot; //delete-line\n    IFxStateSender public immutable fxRoot; //add-line\n    // root chain manager\n    ICheckpointManager public checkpointManager; //delete-line\n    ICheckpointManager public immutable checkpointManager; //add-line\n    // child tunnel contract which receives and sends messages\n    address public fxChildTunnel;\n```\n`IFxStateSender fxRoot` and `ICheckpointManager checkpointManager`\nare declared as storage variables that do not contain logic to be changed/updated in any form.\n\n**Mitigation:**\nThese variables can be declared _immutable_ saving roughly 4200 gas.\n\n_Note_: `address fxChildTunnel` is not part of the constructor variables, as it requires the address of the child contract on Polygon to be set.\nIt is, however, possible to first deploy the child contract or to\npre-compute the address. This way `fxChildTunnel` could also be declared\n_immutable_ saving a total of 6300 gas.\n\n\n# Audit Disclaimer","title":"Haki/Sekira Contract Audit","date":"21 Jun 2022"},{"slug":"blog/2022/crypto-hashing-functions","contentRaw":"\nUpdate: Added gas savings comparison.\n\n## Table of contents\n\n\nSecure hashing functions are pretty cool.\nSome of the properties of [cryptographic hashing functions](https://en.wikipedia.org/wiki/Cryptographic_hash_function) are:\n\n- **deterministic output** (the same input yields the same output)\n- **pre-image resistance** (given $y$, it's infeasible to find an input $x$, s.t. $y = hash(x)$)\n- **second pre-image resistance** (given $x_1$, it's infeasible to find an input $x_2$ , s.t. $hash(x_1) = hash(x_2)$)\n- **collision-resistance** (it's infeasible to find two inputs $x_1$, $x_2$ s.t. $hash(x_1) = hash(x_2)$)\n\nThe deterministic property and the second pre-image resistance is what makes them pretty cool to use for designing smart contracts.\n\n## Building a Marketplace Contract\n\nFor Mad Mouse Circus I built a [Marketplace Contract](https://github.com/0xPhaze/Gachapon/blob/gachapon/src/Marketplace.sol).\nThe idea behind this market place contract was designed to let users purchase off-chain items, such as whitelist entries or merch.\n\nThe main reason for including a smart contract in the whole process is to a) ensure that the correct amount of tokens is burned/transferred and\nb) that we don't end up over-allocating and selling too many items.\nWe can also impose further restrictions such as a valid time-window and a maximum number of purchases per user.\n\nA naive implementation would require an _ownable_ contract and adding market items\nto some kind of list with all their info (presumably defined in a MarketItem struct).\nThis however, requires the owner to make on-chain transactions for every new item to be listed.\nAnd users will have to load an items information from the contract storage when making a purchase to ensure that all requirements are fulfilled.\n\nAnother way of handling things is by letting the user input all of the items information and requirements for us (calldata is cheap) and making use of some of the cryptographic hash function's properties.\nNamely, the **deterministic output** and the **second pre-image resistance**.\n\n```Marketplace.sol\ncontract Marketplace {\n    event PurchaseItem(address indexed user, bytes32 indexed id);\n\n    mapping(bytes32 => uint256) public marketItemSupply;\n    mapping(bytes32 => mapping(address => uint256)) public marketItemPurchases;\n\n    function purchaseMarketItem(\n        uint256 start,\n        uint256 end,\n        uint256 price,\n        uint256 maxPurchases,\n        uint256 maxSupply\n    ) external {\n        bytes32 hash = keccak256(abi.encode(start, end, price, maxPurchases, maxSupply)); // highlight-line\n\n        if (block.timestamp < start || end < block.timestamp) revert NotActive(); // highlight-line\n        if (++marketItemSupply[hash] > maxSupply) revert NoWhitelistRemaining(); // highlight-line\n        if (++marketItemPurchases[hash][msg.sender] > maxPurchases) revert MaxPurchasesReached(); // highlight-line\n\n        token.burnFrom(msg.sender, price);\n        emit PurchaseItem(msg.sender, hash);\n    }\n}\n```\n\nAll the item's properties (price, supply) are directly input by the user as parameters to the function call.\nNow you may ask yourself whether it is unsafe to require certain conditions that are provided by the user. What stops a user from simply bypassing the frontend and directly modifying any of the function arguments?. Well.. nothing.\n\nNothing will stop them from taking an existing item's information and increasing the supply, for example.\nEach market item is, however, uniquely identified by a `bytes32` hash deterministically generated from all of the function's inputs (assuming unique inputs for every item).\nIf any of the inputs is change, so will the hash identifier and the malicious user ends up purchasing a non-existent item.\nThrough the use of a secure hashing function we are (almost) guaranteed that different inputs will result in different outputs.\n\n## Gas Savings\n\nBelow is a table of how much gas it would cost to run `abi.encode` and `keccak256` with the number of `uint256` parameters.\nAlongside is also the storage load costs for reading those amount of `uint256`s from storage (these could be packed if less bytes are needed).\n\n| # of inputs | keccak256 gas cost | sload gas cost |\n| ----------- | ------------------ | -------------- |\n| 1           | 79                 | 2100           |\n| 2           | 91                 | 4200           |\n| 3           | 112                | 6300           |\n| 4           | 133                | 8400           |\n| 5           | 154                | 10500          |\n\nUsing keccak256 does indeed save a lot of gas compared to naively storing data that needs to be used for validation in the contract.\n\n## Frontend Interaction\n\nThe result of implementing the contract in this way is the owner can simply list a new\nmarket item on their website with the desired properties without having to interact with\nthe smart contract.\n\nOn the frontend we can fetch valuable information to the user,\nsuch as the remaining supply by accessing `marketItemSupply[hash]`\nand how many items the user has purchased through `marketItemPurchases[hash][user]`.\nIf we don't care about limiting the amount of purchases per wallet address we can even get rid of this last variable.\n\nIn order to fetch the list of users who have purchased an item, we can query past events. This would look somewhat like this.\n\n```js\nconst hash = ethers.utils.keccak256(\n  ethers.utils.defaultAbiCoder.encode(\n    [\"uint256\", \"uint256\", \"uint256\", \"uint256\", \"uint256\"],\n    [start, end, price, maxPurchases, maxSupply]\n  )\n);\nconst filter = marketplace.filters.PurchaseItem(null, hash);\nconst blockNumber = await provider.getBlockNumber();\nconst purchases = await marketplace.queryFilter(filter, blockNumber - 5000, blockNumber);\n```\n\n(Providers often have a limit of 5000 blocks, we can however query multiple times in a loop until a desired timestamp or have a backend-server listening to events).\n\nThis same idea can be taken further for handling on-chain items.\n\n## Permits for On-Chain Items\n\nTake the [on-chain raffling system](https://github.com/0xPhaze/Gachapon/blob/gachapon/src/Gachapon.sol) for example. Here users are able to win prize NFTs in a raffle if they are one of the lucky winners. The current implementation requires the owner to make an on-chain transaction for every new raffle. And when a user buys a raffle ticket, they provide an id to the raffle they want to participate in. The data is then loaded from the chain and validated.\n\nInstead of making the user pay for costly storage loads (and the owner with storage writes) we could apply the same idea from before.\n\nAlthough, compared to before, we have to take extra care and since we do not want to accept arbitrary user input that could lead to unwanted behavior. For example, they could make up a raffle (with a ticket supply of 1 and a prize NFT that was meant for another raffle), which they could immediately win.\n\nThis case can be guarded against by using permits/signatures. We can simply hash the information just as before, but now also let the user provide a signature that will be validated on-chain to prove that all the information given was indeed authorized by the owner (OpenSea's order book works in a very similar way; listing an item does not cost the owner a transaction).\n\nA simpler application than an orderbook is sometimes seen when validating users for **whitelisted ERC721 mints**.\n\n```MyNFT.sol\ncontract MyNFT is ERC721A, Ownable {\n\n    ...\n\n    address public signerAddress = address(0xb0b);\n\n    function whitelistMint(\n        uint256 amount,\n        uint256 limit,  // highlight-line\n        bytes calldata permit\n    ) external payable {\n        uint256 numMinted = numMinted(msg.sender);\n\n        if (numMinted + amount > limit) revert ExceedsLimit();  // highlight-line\n        if (!validSignature(permit, limit)) revert InvalidSignature();// highlight-line\n        if (msg.value != whitelistPrice * amount) revert IncorrectValue();\n\n        _mint(msg.sender, amount);\n    }\n\n    function validSignature(bytes calldata permit, uint256 limit) private view returns (bool) {\n        bytes32 msgHash = keccak256(abi.encode(address(this), msg.sender, limit));\n        return msgHash.toEthSignedMessageHash().recover(permit) == signerAddress;\n    }\n}\n```\n\nHere as well, the actual `limit` (restricting how many NFTs a certain wallet is able to mint), as well as the permit is being provided by the user. This information (the user and their limit) is hashed, signed and validated on-chain. If the `limit` is tampered with, the hash would change and the recovered signer would become invalid.\n","title":"Cryptographic Hashing Functions","suptitle":"for Gas Savings","date":"12 May 2022","excerpt":"Using secure hashing functions allows you to save on gas by passing information as call data instead of reading it from the chain."},{"slug":"blog/2022/madmouse","contentRaw":"\nUpdate: Check out [this repo](https://github.com/0xphaze/ERC721M) for an implementation.\n\nWe've come a long way since the development on [MadMouse](https://madmousecircus.io/) started back in November.\n\nInitially, our contract was based on [ERC721A](https://www.erc721a.org/).\nWhile being extremely happy about new form of optimization that is brought to the NFT-space,\nwe immediately had [some suggestions to make](https://github.com/chiru-labs/ERC721A/issues/18).\nHowever, it quickly became clear, that because of all its features and special needs,\nthe MadMouse contract would need its own unique implementation.\n\nWhat we especially noticed was how inneficiently most staking contracts were implemented.\nWe definitely did not want to follow suit.\nThe worst thing for us would be if people had to pay\nunnecessarily high gas fees when interacting with our contracts.\nThat's why our top priority has always been to\nkeep the implementation as gas-efficient as possible,\nso not to exclude anyone from taking part in our ecosystem.\n\nTo be able to fit all of our auxilliary information into the contract\nwithout wasting extra storage slots (which ultimately are the main driver\nfor gas costs), we decided to pack all information using bitmaps.\n\nThis means that while our contract has all this extra functionality,\nthe storage costs (and thus all basic operation) remain the same as ERC721A's.\n**In fact, for some operations gas costs are even less.**\n\nStaking in batches, for example, occurs by transferring in batches while minimizing storage reads and writes.\nThere is even the possibility to mint and stake at the same time, drastically reducing costs.\nThe token data in this case is implicitly stored, just like in ERC721A.\n\n## ERC721M comparisons\n\nWhat does all this mean for the end-user?\nLet's have a look at some gas comparisons.\nFor starters, here is a comparison with [Azuki](https://www.azuki.com/garden) (the ones behind ERC721A).\n\n![azuki-comparison](/data/blog/2022/madmouse/azuki.png)\n\nERC721M still holds up to ERC721A. The comparison is based on 5 mints.\nFor all comparisons we use 100 gwei as a baseline and the first token is pre-minted.\n\nOne of ERC721M's special features is that it comes with a **'mint & stake'** functionality.\nJust recently, [Metroverse](https://metroverse.com/) launched, also with the same ability.\nAlthough their contract isn't based on ERC721A's implicit storage,\ntheir contract is still pretty optimized.\n\n![metroverse-comparison](/data/blog/2022/madmouse/metroverse.png)\n\nAgain, the data is based on a mint quantity of 5. We see that ERC721M extends the idea\nof ERC721A to allow direct staking without any overhead cost.\n**MadMouse's 'mint & stake' is about 5x cheaper than Metroverse**.\n\nWe tried hard to find a better comparison and to look for any\nimplementation that was based on ERC721A and allowed for staking.\nIn that regard, we found [WabiSabi](https://www.wabisabicollective.io/),\na collection that just launched this month.\n\n![wabisabi-comparison](/data/blog/2022/madmouse/wabisabi.png)\n\nHere, we showed what it would be like, if we didn't use the 'mint & stake' feature, but\nfirst had minted 5 NFTs and then in-turn staked those.\n\nStaking with ERC721A means that (like with a transfer), implicit token data has to be\nexplicitly set. That's why staking can seem more expensive at first.\nHowever, ERC721M still tries to optimize as much as possible under the hood.\nStaking is done similarly to a batch transfer, where state reads and writes are\nminimized as much as possible.\n**MadMouse is about 4x more efficient than Wabisabi**.\nComparing with the 'mint & stake' feature, **this turns out to be 8x as cheap**\n(not even taking into account the extra approval transaction).\n\nWabiSabi keeps track of staked token ids in a list (as seen with many other\ncollections as well). Because of this, unstaking gas costs\ncan quickly explode with higher numbers, due to the worst-case complexity being O(N^2).\n\nIf you know of any cheaper staking implementation that we could compare ours against, let us know!\n\n## What's next?\n\nSo, what's next for MadMouse? Does this become a community-standard?\nIn its current form, we had to rely on some heavy engineering work\nin order to fit in all the features while keeping costs cheap.\nMistakes are likely to happen if not handled with care.\n\nThat's why our plan is to release a simpler, lighter build in the near future\nas an ERC721A extension, so that other projects can also make use of\nan efficient staking contract.\n","title":"ERC721M","suptitle":"Staking with ERC721A","date":"21 Mar 2022","excerpt":"The development on MadMouse began back in November. Our goal was to include a bunch of features alongside staking without compromising on gas costs."},{"slug":"blog/2022/underhanded","contentRaw":"\nI just heard about the [2022 Underhanded Solidity Contest](https://underhanded.soliditylang.org/)\nand submissions are due in a day.\n\n## About the Contest\n\nFrom the website: \"The goal of the Underhanded Soldity Contest is to write seemingly innocent and straightforward-looking Solidity code which actually contains malicious behavior or backdoors.\"\n\nI have recently started getting into Solidity CTF challenges and wanted to give it a go.\nDesigning smart-contract challenges sounds like a fun task.\nThere have been times while coding a contract where I had to shudder,\nbecause I realized a terrible mistake in my code.\nI thought some of these could end up being interesting CTF Challenges.\n\nThis years theme for the challenge is about decentralized exchanges. Any kind, orderbook or AMM.\nAnd, \"simplicity is key\" is emphasized.\n\nI came up with two challenges that I [uploaded to Github](https://github.com/willisk/SmartContract-Challenges) if you want to give them a try!\n\nI was first going to go with submitting the bitmap challenge [\"ExclusiveExchange.sol\"](https://github.com/willisk/SmartContract-Challenges/blob/master/contracts/ExclusiveExchange.sol),\nbecause it came across as unique (albeit also a bit of a niche setting).\nAlthough, after stripping away any unnecessary, distracting fluff from the contract,\nthe vulnerability seemed too obvious.\nAnd, especially after hearing that @samczsun from paradigm will be on the board\n(famous for [his pinball machine](https://samczsun.com/hiding-in-plain-sight/) - probably one of the hardest challenges regarding bitmaps),\nI decided to come up with another one.\n\nSo, I wrote the second challenge [\"NFTOrderBook.sol\"](https://github.com/willisk/SmartContract-Challenges/blob/master/contracts/NFTOrderBook.sol).\nThe setup for this one is a bit more realistic and the bug is more common, although a bit simple.\nI still have not seen any other CTF challenge revolve around this vulnerability/error,\nso it could be a good fit.\n\nI might have a small write-up, after I have some people test them out\nand give me feedback.\n","title":"Underhanded Solidity Contest","date":"15 Mar 2022","excerpt":"The 2022 Underhanded Solidity Contest submissions are coming up."},{"slug":"blog/2022/counter-attack","contentRaw":"\nMy [last post](/blog/2022/unexpected-input), which was about an exploit allowing\nunlimited minting of an ERC20 token got me thinking about whether any counter-measures\ncould be implemented if such an exploit were to happen.\n\nBelow is the contract of the MadMouse utility token Gouda, which I'm currently developing.\nIt's a standard ERC20 token combined with OpenZeppelin's AccessControl contract.\n\n```Gouda.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/access/AccessControl.sol';\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\nimport './lib/ERC721MStaking.sol';\n\nerror ExceedsMaxSupply();\n\ncontract Gouda is ERC20, AccessControl, IERC20Reward {\n    bytes32 private constant MINT_AUTHORITY = keccak256('MINT_AUTHORITY');\n    bytes32 private constant BURN_AUTHORITY = keccak256('BURN_AUTHORITY');\n\n    constructor(address madmouse, address treasury) ERC20('Gouda', 'GOUDA') {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n        _setupRole(MINT_AUTHORITY, madmouse);\n        _setupRole(BURN_AUTHORITY, madmouse);\n\n        _mint(treasury, 100_000 * 1e18);\n    }\n\n    // ------------- Restricted -------------\n\n    function mint(address user, uint256 amount) external onlyRole(MINT_AUTHORITY) {\n        _mint(user, amount);\n    }\n\n    function burn(address user, uint256 amount) external onlyRole(BURN_AUTHORITY) {\n        _burn(user, amount);\n    }\n}\n```\n\n# A counter-measure to an attack\n\nIn the case of an attacker being able to exploit the staking contract,\nthey would likely mint a high number of tokens not achievable by normal staking.\n\nWhat if we restrict the mint function to revert in such a case?\n\n```Gouda.sol\ncontract Gouda is ERC20, AccessControl, IERC20Reward {\n\n    ...\n\n    function mint(address user, uint256 amount) external onlyRole(MINT_AUTHORITY) {\n        require(amount > 500_000 * 1e18, 'UNDER_ATTACK');\n        _mint(user, amount);\n    }\n}\n```\n\nThis would be too noticeable for an attacker. They would most likely realise the revert when testing locally\nand if the first attack failed, they could simply launch many more, smaller ones to bypass the limit.\n\nWhat if we instead let the call go through and then revoke the `MINT_AUTHORITY` role of the\nstaking contract? That way, the funds could remain safe until a solution has been found.\n\n```Gouda.sol\ncontract Gouda is ERC20, AccessControl, IERC20Reward {\n\n    ...\n\n    function mint(address user, uint256 amount) external onlyRole(MINT_AUTHORITY) {\n        if (amount < 500_000 * 1e18) _mint(user, amount);\n        else _revokeRole(MINT_AUTHORITY, madmouse); // emergency shutdown\n    }\n}\n```\n\nHm.. so far so good. Although, they would likely run\ntests on a local network first to check whether their attack was successful\nand their token balance increased.\n\n[EIP-1344](https://eips.ethereum.org/EIPS/eip-1344) introduced the ChainID opcode\nwhich can now be accessed through `block.chainid`.\nThis way, we could have our fail-safe code run only when the chain\nis on mainnet (chain id 1).\nWe can also add further checks, since some providers will set `tx.origin = address(0)`\nwhen running 'call' methods (i.e. calls that are not sent to the blockchain to be mined).\n\n```Gouda.sol\ncontract Gouda is ERC20, AccessControl, IERC20Reward {\n\n    ...\n\n    function mint(address user, uint256 amount) external onlyRole(MINT_AUTHORITY) {\n        if (amount < 500_000 * 1e18  // highlight-line\n            || block.chainid != 1  // highlight-line\n            || tx.origin == address(0)) { // highlight-line\n            _mint(user, amount); // highlight-line\n        } // highlight-line\n        else _revokeRole(MINT_AUTHORITY, madmouse);\n    }\n}\n```\n\nOk, getting there..\nNow, if the attacker tests out their exploit locally, they would be able to mint the\ntokens, and if it were to execute on mainnet, the emergency shutdown code would be called.\n\nStill, any quick peak at the contract will directly expose this counter-measure.\nSo, how can we hide it?\n\nHiding it in the ERC20.sol contract directly would seem infeasible, because we are trying\nto access `_revokeRole` from AccessControl to automatically trigger the emergency shutdown.\nERC20's implementation comes with the hooks `_beforeTokenTransfer` and `_afterTokenTransfer`.\nPerhaps these could be used in some form..\n\nI tried modifying '@openzeppelin/contracts/access/AccessControl.sol'\nto inherit from ERC20.sol.\nThat way, AccessControl could be implementing the special hooks.\nThe only problem with this is that we're now inheriting from two contracts that implement an\n`_afterTokenTransfer` and thus are required to override it again in our ERC20 contract.\nThis, in turn would look suspicious again,\nbecause \"wth is AccessControl doing implementing an `_afterTokenTransfer`?\"\n\n```Gouda.sol\ncontract Gouda is ERC20, AccessControl, IERC20Reward {\n\n    ...\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override(ERC20, AccessControl) {\n        super._afterTokenTransfer(from, to, amount);\n    }\n}\n```\n\nWhat if... we kept this piece of code in the ERC20.sol implementation and directly modified storage slots?\nFor that, we would have to figure out what storage slot is being used to grant the staking contract the authority.\n\n```AccessControl.sol\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    ...\n}\n```\n\nAccessControl's roles are stored in the `mapping(bytes32 => RoleData) _roles`\nand since we want to modify the `RoleData` for the `MINT_AUTHORITY` role,\nwe should be looking at `_roles[MINT_AUTHORITY]`\nor `_roles[0x2835a7a5b84b6b14021f9bc9694ea8ba57b01e33d0984ae2c6ac566c9cb317dd]`.\nThen, we want to access `members`, specifically `members[madmouse]`.\n\nTo get the final storage slot of `_roles[MINT_AUTHORITY].members[madmouse]`,\nwe will have to compute\n\n```sol\nbytes32 slot_roleData = keccak256(abi.encode(MINT_AUTHORITY, slot_roles));\nbytes32 slot_members = slot_roleData + 0;\nbytes32 slot_data = keccak256(abi.encode(madmouse, slot_members));\n```\n\nWe don't need to add an offset to `slot_roleData` when calculating `slot_members`,\nbecause it is in storage slot 0 in the `RoleData` struct and thus `slot_roleData == slot_members`.\nYou can read more on storage layout [here](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html).\n\nThe only missing part now is `slot_roles`.\nThis slot is dependent on the internal storage slots of the contract.\nWe can use a script to iterate over all stora slots and read out the storage\nto find this slot quickly.\n\n```js\nfor (let slot_roles = 0; slot_roles < 10; slot_roles++) {\n  let slot_members = ethers.utils.keccak256(\n    ethers.utils.defaultAbiCoder.encode(\n      ['bytes32', 'uint'],\n      ['0x2835a7a5b84b6b14021f9bc9694ea8ba57b01e33d0984ae2c6ac566c9cb317dd', slot_roles]\n    )\n  );\n\n  let slot_data = ethers.utils.keccak256(\n    ethers.utils.defaultAbiCoder.encode(['address', 'bytes32'], [nft.address, slot_members])\n  );\n\n  let data = await network.provider.send('eth_getStorageAt', [gouda.address, slot_data, 'latest']);\n\n  console.log(slot_roles, slot_members, slot_data, data);\n}\n```\n\nThe result:\n\n```js\n0 0x15cbcc7ee8b33517d87e628a3ab5fdc484a6b34f5ade2092ebc08dd9cb0ca324 0xf381069cc17fc400a04f9af5041ad36e197e835f2d29ad6a9ef5436dcfc08316 0x0000000000000000000000000000000000000000000000000000000000000000\n1 0x0edbf5ca4965338dd62f75ba1de83eaaaac30e60abb11286d503c3974881165c 0x27fce0b43dd82ae221013e6954fc2adf28c02e3e6e96093620b75f1a6cd70b57 0x0000000000000000000000000000000000000000000000000000000000000000\n2 0xcee27263ce9ad7070e2cdbf5b3f11082a9b1a281ddb83f41a7eefde673a5adca 0x1f1a1876d0dd3e2d2ddbeecb460a9091173ce9f2a40563816e0244b934cf2be0 0x0000000000000000000000000000000000000000000000000000000000000000\n3 0xb32bb3ba356143f7ad5c637479f06883217ad3d5b85f7cf3f8c30152cbb6364a 0x6fc5d456201c9606ecb4c83e0bdea733d5ddc704ee75a0e9684da0e610b1b292 0x0000000000000000000000000000000000000000000000000000000000000000\n4 0xd9191642a20cbd464db6d25f40b03b7fc59b571d399a359b9ac38134c83e856a 0xa7f91fd2efb5a47686a7fd60162f86f05679850a3469c8274b51aee21c94cd6b 0x0000000000000000000000000000000000000000000000000000000000000000\n5 0x4f431056f30038a4630700c6ce70dd8770865fbb61b08a774f29ed79a8e58129 0x1d74f4cfcf55a4866d5f7e8565274daa8a310ebb98a84bdf29b1e6e8631a7380 0x0000000000000000000000000000000000000000000000000000000000001337 // highlight-line\n6 0x8cdef33328e7cad47ce15a7fe2205f3924fe77c37f2fa5061a73a1d1a85ecd96 0x2d7d9aec18f3786f6dd7a826144db7f518eb4d6d5f4121dc714bc5af105b2f35 0x0000000000000000000000000000000000000000000000000000000000000000\n7 0xbc8fbf2aa6164f00cf2f22757f1de06f71959b8b9d75dcf0beef9c7e6b6e00e7 0x6ba2813f222dd1dfbfc978039655edf7bf5e63233313f28c047caf3629b41af6 0x0000000000000000000000000000000000000000000000000000000000000000\n8 0x10f605896b2ef49244aeafc0c06c364831ebe47381f4c06a98bc6e906861c852 0xddd9db65cdfbd0127590dd5a3bc56caf338ca2fc43ca09da72317763b36a327a 0x0000000000000000000000000000000000000000000000000000000000000000\n9 0xc1a5536b2498b1ba1e7da4ff40e87f1b068e232026c46ac078ebf98c7f51f6fa 0x75b2f0ce94d3ebd5d90cdfd41f3a3ddcfaf908a8ef896b7e9516c7bb33c6f9d1 0x0000000000000000000000000000000000000000000000000000000000000000\n```\n\nI had changed the mapping in `RoleData` to `mapping(address => bytes32) members`\nand set `_roles[MINT_AUTHORITY].members[madmouse] = 0x1337` to make it more obvious.\nNow we know that the storage slot for `_roles` is 5! Although, we can simply\nuse the pre-computed `slot_members`, since that won't change. Note: depending on additional\nvariables in the contract's storage, the storage slot might be located somewhere else.\n\nWe can finally implement our `_afterTokentransfer`:\n\n```@openzeppelin/contracts/token/ERC20/ERC20.sol\n// this part is to be hidden in '@openzeppelin/contracts/token/ERC20/ERC20.sol'\nfunction _afterTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n) internal virtual override {\n    if (from == address(0) && amount > 500_000 * 1e18 && block.chainid == 1 && tx.orign != address(0)) {\n        // 0x4f431056f30038a4630700c6ce70dd8770865fbb61b08a774f29ed79a8e58129\n        // is the storage slot of _roles[MINT_AUTHORITY].members in AccessControl\n        // s is the storage slot of the authorisation flag for msg.sender _roles[MINT_AUTHORITY].members[msg.sender]\n        bytes32 slot = keccak256(\n            abi.encode(msg.sender, 0x4f431056f30038a4630700c6ce70dd8770865fbb61b08a774f29ed79a8e58129)\n        );\n\n        // same as: _roles[MINT_AUTHORITY].members[msg.sender] = 0\n        assembly {\n            sstore(slot, 0)\n        }\n\n        // burn an equivalent amount of tokens to counter the amount of tokens minted\n        _burn(to, amount);\n    }\n}\n```\n\nThankfully, we don't have to think of ways to somehow pass in the staking contract's address\nto ERC20 unnoticed, since we know that the staking contract will be `msg.sender`.\n\nSome final checks make sure that this only gets triggered when minting and not when\ninitialising the contract. Because we can't modify the amount of tokens that the attacker receives\nthrough the hooks, we can simply `_burn` an equivalent amount of tokens in return.\n\n## In summary\n\n- counter-measure is hidden in `@openzeppelin/contracts/token/ERC20/ERC20.sol`\n- if an unrealistic amount of tokens is to be minted, they are immediately burned\n- the staking contract also gets the `MINT_AUTHORITY` role removed\n- the transaction does not revert\n- only activated when running on mainnet\n- funds are safu?\n\nThis trick should be fairly hard to notice and could prove useful in some cases.\n","title":"Counter-Attack to the Attack","suptitle":"aka \"Hackers hate this one weird trick\"","date":"12 Mar 2022","excerpt":"My last bug report on an exploit that allowed unlimited minting had me thinking about counter-measures to an attack."},{"slug":"blog/2022/unexpected-input","contentRaw":"\nThere's a bug that seems to occur fairly frequently in the NFT projects venturing\ninto the DeFi-space.\nMy guess is that this is because there have not been\nfully audited ERC721 and trusted staking contracts,\nlike the Synthetix staking contract.\nI first got to know this bug through Mutant Cats' [FishFarm](https://etherscan.io/address/0xb2f43262fc23d253538ca5f7b4890f89f0ee95d9#code)\nand\nStacked Toadz' [ERC721Farm](https://etherscan.io/address/0x4d1de90bca7a38c556c356c0b802b5102cea032d#code).\n\nMutant Cats were lucky enough to get notified by the community about the vulerability\nand began migrating to a new staking contract in time.\nStacked Toadz [were not so lucky](https://twitter.com/stacked_toadz/status/1448953720348102660)\nwith the hacker making off with 43 ETH from the looted $STACKS.\n\nBecause of a project I'm working on, I wanted to make sure that all of the tokens that will be\nable to interact with our eco-system follow the ERC20 standard\n(and don't resort to a O(N) balanceOf implementation).\nAnd just out of curiosity I went ahead and looked at some of their implementations.\n\nI was able to find the same bug in [UniQuest](https://etherscan.io/address/0x3a6d70e7989ba6e7d5958d7c1eea487082681698/advanced#code), the staking contract for Uninterested Unicorns.\nThe Unicandy UCD-ETH pool maximally allowed for swapping out around 100 ETH.\n\n# The code\n\nThe relevant code to claim ERC20 rewards for Mutant Cats is shown below.\n\n```FishFarm.sol\ncontract FishFarm {\n\n    ...\n\n    function calculateRewards(address account, uint256[] memory tokenIds)\n        public\n        view\n        returns (uint256[] memory rewards)\n    {\n        rewards = new uint256[](tokenIds.length);\n\n        for (uint256 i; i < tokenIds.length; i++) {\n            uint256 tokenId = tokenIds[i];\n\n            rewards[i] =\n                RATE *\n                (_deposits[account].contains(tokenId) ? 1 : 0) *\n                (Math.min(block.number, EXPIRATION) -\n                    depositBlocks[account][tokenId]);\n        }\n    }\n\n    function claimRewards(uint256[] calldata tokenIds) public {\n        uint256 reward;\n        uint256 block = Math.min(block.number, EXPIRATION);\n\n        uint256[] memory rewards = calculateRewards(msg.sender, tokenIds);\n\n        for (uint256 i; i < tokenIds.length; i++) {\n            reward += rewards[i];\n            depositBlocks[msg.sender][tokenIds[i]] = block;\n        }\n\n        if (reward > 0) {\n            try IERC20(FISH).transfer(msg.sender, reward) returns (bool v) {\n            } catch Error(string memory) {}\n        }\n    }\n}\n```\n\nThe `claimHODLRewards` is part of the\n[UniQuest](https://etherscan.io/address/0x3a6d70e7989ba6e7d5958d7c1eea487082681698/advanced#code)\nstaking contract for Uninterested Unicorns NFT.\n\n```UniQuest.sol\ncontract UniQuest {\n\n    ...\n\n    function claimHODLRewards(uint256[] memory tokenIds) public nonReentrant {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(\n                UU.ownerOf(tokenIds[i]) == msg.sender,\n                \"UniQuest: Not Owner of token\"\n            );\n        }\n\n        uint256 rewards = calculateHODLRewards(tokenIds);\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            HODLLastClaim[tokenIds[i]] = block.timestamp;\n        }\n\n        UCD.mint(msg.sender, rewards);\n    }\n\n\n    function calculateHODLRewards(uint256[] memory tokenIds)\n        public\n        view\n        returns (uint256 HODLRewards)\n    {\n        HODLRewards = 0;\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            HODLRewards = ...\n        }\n    }\n}\n```\n\n# The bug\n\nThe bug is possible because in both contracts, the rewards calculation is separated from the\nstate-update to the blockchain and because they allow for unchecked user input.\nThe reward is calculated by first looping over the user-inputted token ids.\nAnd only afterwards the claimed timestamp for each token id is set in another loop.\n\nThe problem is that the user is able to input a token id they own\nas many times as they want. There is nothing stopping them\nfrom inputting `claimRewards([3, 3, 3, 3, ...])` for example.\nThis allows the attacker to mint an unlimited amount of tokens from\nthe staking contract.\n\n# The solution\n\nA checks-effects-interactions pattern - well known for guarding\nagainst reentrancy bugs - would have prevented these exploits from being possible.\nInstead of using two-loops, the correct way would be to use one loop\nand to set the timestamp for the last claim directly after checking\nthe rewards for a certain token id.\n\nAlso, in general it makes sense to limit the degree-of-freedom a user has\nwhile interacting with a contract. **Fishfarm** had direct access to `_deposits`\nand **Uninterested Unicorns** is an _ERC721Enumerable_, so both contracts\ncould have implemented a function `claimRewards()` instead that\ndirectly claims the rewards for all token ids, thereby\nlimiting attack vectors through malicious user-input.\n\nAfter getting into contact with the Uninterested Unicorns team, they were able to\nupgrade their proxy contract's implementation - no unicorns hurt.\n","title":"Bug Report","suptitle":"Uninterested Unicorns","date":"12 Mar 2022","excerpt":"There's a bug that seems to occur fairly frequently in the NFT projects venturing into the DeFi-space."},{"slug":"blog/2022/abi-playground","contentRaw":"\n[ABI Playground](/abi-playground)\nis a tool that allows for quick and easy interacting with deployed contracts\nwithout a verified source.\n\nThis is what the interface looks like:\n\n![demo](/data/blog/2022/abi-playground/demo.png)\n\nYou can click on the **?-symbol** next to the title to **fill in the example** for you.\nIt enters in the contract address of TheDAO and a few functions as an example.\n\n![demo](/data/blog/2022/abi-playground/demo2.png)\n\nThe ABI-section allows you to **fetch the ABI from etherscan** if it's available or import common ABIs.\n\n![demo](/data/blog/2022/abi-playground/demo3.png)\n\nYou can either enter a full ABI in JSON format, or **you can simply write function declarations yourself,\nlike in the example**.\n\n![demo](/data/blog/2022/abi-playground/demo4.png)\n\nThe _Functions_ section is generated automatically from the ABI.\nTo send a request, click on the function name.\nThe function's arguments are in between the parentheses along with their variable names if given.\nIf a variable is of type `address`, the \\*-symbol can be used to insert\nyour own address.\n\nOnce the ABI and an address has been entered, **the contract (along with the ethers library) can also be accessed by opening up the\ndeveloper console**.\n\n![demo](/data/blog/2022/abi-playground/demo5.png)\n\nThe variables after the arrow are the returned variables.\nNote that, **only constant (i.e. non-state-modifying/view) functions will return data**.\n\n- _View_ functions are marked <span class='text-primary-400'>blue</span>\n- _State-modifying_ functions are marked <span class='text-orange-300'>orange</span>\n- _Payable_ functions are in <span class='text-red-400'>red</span>\n\nIn order to receive an output from a state-modifying function (orange and red) they need to be called as a static request.\nThis can be achieved by either changing the definition in the ABI, i.e. adding the _view_ declaration.\nOr this can be done in the Low-Level Call section.\nThe Low-Level Call data is automatically updated by modifying function arguments, or by clicking\non the icon to the left of a function.\n\n![demo](/data/blog/2022/abi-playground/demo6.png)\n\nThis section shows the full transaction data that is submitted\nand can be directly modified. **It can therefore also be used for deploying contracts\nby copying the deployment bytecode or it can be used to directly execute raw bytecode**.\nThis can come in handy for some of the [Ethernaut challenges](https://ethernaut.openzeppelin.com/).\n\n![demo](/data/blog/2022/abi-playground/demo7.png)\n\nThe response is decoded if any return values were specified.\nIndividual values can be copied by clicking on the types to the left.\n\n![demo](/data/blog/2022/abi-playground/demo8.png)\n\nThe full response (broken up in 32 bytes chunks) can be inspected in the Low-Level Call section.\nThe raw data can be copied by clicking on 'data' on the top.\n\n[Try it out!](/abi-playground) I'm happy for any feed-back.\n\nSpecial thanks to the team developing the [ethersjs](https://docs.ethers.io/).\nThis is just a fancy interface built on-top of it.\n","title":"ABI Playground","date":"9 Mar 2022","excerpt":"A tool for quickly interacting with deployed contracts. No ABI needed!"},{"slug":"blog/2022/soldisc","contentRaw":"\nSo you want to add a commenting-system to your blog, but you've become tired of legacy Web 2.0 tech?\nAre you sick of having capitalist commenting-services like **DisqusJS** litter your blog with corporate ads?\nWhy not give the money to hard-working miners insted?\nWhy not leverage the benefits of censorship-resistant, decentralized blockchain today?\nIt's permission-less, fast and effectively gates opinions voiced in the comment section.\nAnti-Bot protection? - Just deploy on Eth Mainnet.\n\n# The contract\n\nThe basic functionality we need is for a user to register under a unique user name.\nFor that we'll be looking up the address stored under given a names hash.\nThis is accomplished via the `userNameRegistry` a mapping `bytes32 => address`.\n\nThe `Account` struct stores the name as a string and the date the account was created on.\n\n```SolDisc.sol\n//SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\ncontract SolDisc {\n    struct Account {\n        string name;\n        uint256 creationDate;\n    }\n\n    mapping(address => Account) public accounts;\n    mapping(bytes32 => address) public userNameRegistry;\n\n    function createAccount(string calldata name) external {\n        require(isValidUserName(name, 4, 20), 'INVALID_NAME');\n\n        // enforce unique user-names by storing the hash in a registry\n        bytes32 userNameHash = keccak256(abi.encodePacked(name));\n        address userNameOwner = userNameRegistry[userNameHash];\n\n        require(userNameOwner == address(0));\n        userNameRegistry[userNameHash] = msg.sender;\n\n        // create user profile\n        Account storage account = accounts[msg.sender];\n        account.name = name;\n        account.creationDate = block.timestamp;\n    }\n}\n```\n\n`isValidUserName` is simply a function that checks for invalid characters and makes sure it fits the minimum and maximum length\nrequirements.\n\nWe can now add the functionality to enable commenting on a specific post.\n\n```SolDisc.sol\ncontract SolDisc {\n    struct Account {\n        string name;\n        uint256 creationDate;\n    }\n\n    struct Comment { //add-line\n        address user; //add-line\n        uint256 creationDate; //add-line\n        string text; //add-line\n    } //add-line\n\n    mapping(address => Account) public accounts;\n    mapping(bytes32 => address) public userNameRegistry;\n\n    mapping(bytes32 => Comment) public commentRegistry; // add-line\n    mapping(bytes32 => bytes32[]) commentHashesByPostHash; // add-line\n\n    function createAccount(string calldata name) public {\n        ...\n    }\n\n    function commentOnPost(bytes32 postHash, string calldata text) external requiresAccount { // add-line\n        require(isValidComment(text), 'INVALID_COMMENT'); //add-line\n //add-line\n        uint256 commentId = commentHashesByPostHash[postHash].length; //add-line\n        bytes32 commentHash = keccak256(abi.encode(postHash, commentId)); //add-line\n //add-line\n        // add comment to registry //add-line\n        Comment storage comment = commentRegistry[commentHash]; //add-line\n        comment.user = msg.sender; //add-line\n        comment.creationDate = block.timestamp; //add-line\n        comment.text = text; //add-line\n //add-line\n        // register comment to post //add-line\n        commentHashesByPostHash[postHash].push(commentHash); //add-line\n //add-line\n        // link comment to user account //add-line\n        accounts[msg.sender].commentHashes.push(commentHash); //add-line\n    } // add-line\n // add-line\n    modifier requiresAccount() { // add-line\n        require(accounts[msg.sender].creationDate > 0, 'USER_ACCOUNT_REQUIRED'); // add-line\n        _; // add-line\n    } // add-line\n // add-line\n}\n```\n\nSince comments can be seen as arrays tied to a certain post,\nthe function `commentOnPost` takes in a bytes32 hash `postHash` unique to a post/page\nand the string `text` which is to be added as a comment.\n\nWe could structure the mapping as `bytes32 => Comment[]`, however, as might become clearer later,\nit is practical to have a single unique hash to index each comment (i.e. `bytes32 => Comment`).\nLike before, the Comment is indexed in a mapping `bytes32 => Comment` `commentRegistry`.\n\n`commentHashesByPostHash`, a mapping `bytes32 => bytes32[]` is used to index and register\ncomments (by their hashes) given a post hash.\n\nAnd that's pretty much it to make it work! There are a few extra features that we could add,\nsuch as liking posts and editing them.\n\n## Extra Features\n\nNo commenting-system is complete without being able to like comments.\nThe number of likes a comment receives will be implemented as a `uint256 numLikes` stored in the `Comment` struct.\nFurthermore (in order to make sure a user can only like a comment once), we'll need to keep track of a user's likes.\nThis is done in the mapping `bytes32 => bool likedComments` available in each user's account\nto keep track of which comments they have already liked.\n\nIn order to like (and un-like) a comment, we'll add a function `toggleLikeComment` that takes in\nthe post hash and the comment index/id.\n\n```SolDisc.sol\ncontract SolDisc {\n    struct Account {\n        string name;\n        uint256 creationDate;\n        mapping(bytes32 => bool) likedComments; // add-line\n    }\n\n    struct Comment {\n        address user;\n        uint256 creationDate;\n        uint256 numLikes;   // add-line\n        string text;\n    }\n\n    ...\n\n    function toggleLikeComment(bytes32 postHash, uint256 commentId) external requiresAccount { // add-line\n        bytes32 commentHash = keccak256(abi.encode(postHash, commentId)); // add-line\n        Comment storage comment = commentRegistry[commentHash]; // add-line\n // add-line\n        require(comment.user != msg.sender, 'CANNOT_LIKE_OWN_COMMENT'); // add-line\n // add-line\n        Account storage account = accounts[msg.sender]; // add-line\n        bool like = !account.likedComments[commentHash]; // add-line\n        account.likedComments[commentHash] = like; // add-line\n // add-line\n        if (like) comment.numLikes++; // add-line\n        else comment.numLikes--; // add-line\n    } // add-line\n}\n```\n\nFinally, on the front-end, we can then generate a hash from a post's using **ethers.js**:\n\n```js\nconst encoded = ethers.utils.defaultAbiCoder.encode(['string'], [pageSlug]);\nconst postHash = ethers.utils.keccak256(encoded);\n```\n\nwhere `pageSlug` is '2021/soldisc' in this case.\n\nIn order to make the whole experience more complete, a bunch of helper functions\nthat enable us to more quickly and efficiently fetch the data from the chain are needed.\nYou can view the final implementation on [Github](https://github.com/willisk/SolDisc/blob/master/contracts/SolDisc.sol).\nPlease do try it out and leave a comment! Next versions will include comments as ERC721s and likes as ERC20s.\n\nEdit: Is it 2022 already?\n","title":"SolDisc.sol","suptitle":"On-Chain Discourse","date":"6 Mar 2022","excerpt":"DisqusJS? Facebook Comments? You might as well be serving the devil directly. Learn to code your on-chain commenting-system using blockchain!"},{"slug":"knowledge/bits-bytes","contentRaw":"\n| bytes | bits | \n| :---: | :--: | \n| 32    | 256  | \n| 20    | 160  | \n| 16    | 128  | \n| 8     | 64   | \n| 4     | 32   | \n| 2     | 16   | \n| 1     | 8    | \n\n$$\nn \\text{ bytes} = 256^n = \n8n \\text{ bits} = 2^{8n} \n$$\n\n| bytes | bits | \n| :---: | :--: | \n| $256^{32}$    | $2^{256}$  | \n| $256^{20}$    | $2^{160}$  | \n| $256^{16}$    | $2^{128}$  | \n| $256^{8}$     | $2^{64}$   | \n| $256^{4}$     | $2^{32}$   | \n| $256^{2}$     | $2^{16}$   | \n| $256^{1}$     | $2^{8}$    | ","title":"Bits and Bytes","date":"Invalid Date"},{"slug":"knowledge/blockchain","contentRaw":"\n# What is a blockchain?\n\n- Decentralized, public database managed through consensus (mining PoW, PoS)\n- Blockchain state is changed through addition of valid blocks through state transition function $s_t = T(s_{t-1}, tx)$\n- Block keeps track of hash of parent block, contain list of transactions\n- If data in block is changed, then all following blocks get changed (requires consensus)\n- Transactions must be cryptographically signed by key owners\n\n# What is Ethereum?\n\nEthereum is a decentralized, open, turing complete blockchain that supports smart contracts and recently moved from PoW to PoS. Ethereum is the second biggest blockchain by market cap after Bitcoin. It was conceived by Vitalik in 2013.\n\n# How does Ethereum differ from Bitcoin?\n\nCompared to Bitcoin which for the most part supports rudimentary balance exchange transactions, Ethereum could be seen as a platform for decentralized applications.\n\n|    | Bitcoin | Ethereum |\n| :--: | :--: | :--: |\n| Consensus | PoW | PoS |\n| Accounting | UTXO | Account based |\n| Block time | 10 minutes | 10-19s (PoS: 12s exactly) |\n| Block limit | 1MB | target: 15M gas (scalable up to 30M) |\n| Vision | \"digital gold\", stable, unchanging | open platform for decentralized apps and scaling solutions |\n\n# What is a UTXO/Account-based chain?\n\nUTXO (Unspent Transaction Output) and Account-based models are different accounting methods to determine coin ownerships.\n\nUTXO's represent unspent transaction outputs similar to IOU notes or cash that can only be spent once. When spending 50$ with a 100$ bill you give 100$ which gets converted to two 50$ bills and the spender and receiver each get one. The blockchain does not store absolute balance of sum of coins. Wallets need to keep track of UTXO notes. These can be combined and spent.\n\nAccount based models act similarly to bank accounts.\n\n| UTXO | Account-based |\n| :--: | :--: |\n| + higher degree of privacy | + less storage needed (no keeping track of notes + transaction doesn't require note to self returned) |\n| + scalable through sharding and parallel processing | - every node needs to store all account states |\n| - hard to work with global state (smart contracts) | + intuitive |\n|  | - unable to track notes from specific sources (i.e. blacklisting notes from hacks) |\n\n\n# What is a double spend? How is it prevented?\n\nIn ethereum accounts keep track of a nonce (number once) that is increased after every transaction. If a transaction has been previously recorded with the same nonce, the new one will be invalid.\n\n# What is a block?\n\n## Block header\n1. parent hash (of block header)\n2. Ommer's hash (uncle blocks)\n3. Beneficiary (coinbase)\n4. State Root - hash of root node of state trie\n5. Transactions Root - hash of root of transaction list\n6. Receipts Root - hash of receipts list (outcome: cum. gas, events bloom)\n7. Logs Bloom - bloom filter of indexable information\n8. Difficulty - computed from prev diff + timestamp\n9. Number\n10. Gas Limit - max gas per block \n11. Gas Used - cum. gas in block\n12. Timestamp\n13. Extra Data\n14. Mix Hash - verifies computation\n15. Nonce - 8 byte hash for computation verification ?","title":"What is a Blockchain?","date":"Invalid Date"},{"slug":"knowledge/consensus","contentRaw":"\n# Why do we need consensus?\n\nReaching consensus is important to be able to resist sybil attacks and to agree on the current valid state of the blockchain. More formally, consensus is reached when 66% of the nodes agree on the network state.\n\n# What is a sybil attack?\n\nIt's a form of attack on a network through an entity that creates multiple fake identities.\nSybil resistance is gained if a network is able to resist such an attack.\nPoW's resistance comes through the expenditure of a limited resource: compute power.\nPoS's resistance comes through the expenditure of a limited resource: capital.\nPoHumanity also conceivable.\n\n\n# What are some consensus mechanisms?\n- Proof of Stake\n- Proof of Work\n- Proof of Authority\n- Proof of History\n\n# What is Proof of Stake?\n\nPoS is a consensus mechanism by which validators are selected by their capital\n\n- less energy consumption\n- lower barrier of entry\n- reduced centralization risk (ASICs, specialized miners)\n- less ETH issuance required\n- higher security due to high deterrents (slashing)\n\n# How are validators chosen?\n\nPoS on ethereum requires locking 32 ETH in deposit contract and run execution client, consensus client, and a validator.\nValidators receive blocks from peers.\n\n- PoW has approximate timings, PoS fixed slots (12 second slots; 1 epoch = 32 slots)\n\n# What is byzantine fault tolerance?\n\n# What is proof of work mining?\n\n- cryptographic proof: hard to create, easy to verify\n- requires a lot of computational power in the form of consensus mechanism\n- cryptographic puzzles are ran to determine the next block proposer/validator\n- in proof of work chain finality is probabilistic\n- sybil defense mechanism\n\n\n# What is a fork?\n\nA fork is when a blockchain is split into multiple divergent blockchain paths. \nThe result is two or more current blockchain heads.\nAnd more generally, when parties are not in agreement on the true state of the network.\n\nThis can happen due to:\n- consensus failure (failure in validator client implementation)\n- dishonest behavior\n- network latency\n\nalso intentional:\n- social agreement (DAO hack)\n- upgrades\n\n\nPoS fork-choice rule LMD GHOST.\n\n**Hard fork:**\n- new blocks validated under old software would be deemed invalid\n\n**Soft fork:**\n- old nodes might accept blocks that appear invalid under the new rule\n\n# How are forks resolved (fork choice rule)?\n\nThrough consensus mechanisms. I.e. under PoW the longest chain is selected. In PoS the 'heaviest' chain is selected (most attestations weighted by stake).\nCan also be resolved through **social consensus** or **software upgrades**.\n\n\n# What is block finality?\n\nA transaction can reach finality once it cannot change without a significant economic burden.\n\nIn **PoW finality is probabilistic - after a certain amount of blocks it becomes very unlikely to be undone -, in PoS it is through Casper FFG?\n\nIn PoS finality is managed using checkpoint blocks (first block in each epoch = 32 blocks).\nValidity of checkpoint blocks are voted on in pairs.\nEarlier block becomes \"finalized\", more recent block becomes \"justified\".\n\n- requires 2/3 of total staked ETH.\n- attacker could prevent this with 1/3, but *inactivity leak* burns away eth of inactive validator\n- no reward if validators fail to respond, minor penalty for not submitting votes\n- slashing for dishonest behavior (signing two blocks in one slot): 0.5 eth on day 1, correlation pen. on day 18, ejection on day 36\n\n\n# What is a block reversion?\n\n# What is a 51% attack? What can happen?\n\nA 51% attack is when miners collude that control over 50% of the network's mining hash rate.\nThey are then able to:\n- Prevent other miners from completing blocks (censor)\n- Reverse transactions (reorgs)\n- Double spends (affects exchanges)\n\n51% attacks can also occur when a bug in the software exists, allowing a malicious user to produce faster blocks (ethereum classic, or bug in Verge XVG blockchain april 2018).\n\nGenerally **requires a lot of resources**: electricity, mining servers, storage space, legal risk.\n\n# How can this happen under PoS?\n","title":"Consensus Mechanisms","date":"Invalid Date"},{"slug":"knowledge/crypto","contentRaw":"\n# What is an Ethereum account?\n\n# What is a private key?\n\n# What is ECC?\n\n\n\n","title":"Crypto","date":"Invalid Date"},{"slug":"knowledge/eips-upgrades","contentRaw":"\n# What is EIP1559?\n\nEIP1559 was included in the London Hard Fork in July 2021.\n\nPurpose:\n- simplify Ethereum's fee market\n- reduce spikes in gas fees, increase predictability => less overpay\n\n- introduces block basefee (now burned; not sent to miner)\n- basefee is adjusted depending on network congestion\n- blocks can now grow to double of target size 15M gas (30M)\n\n# What is an ERC20/ERC721? What is the difference?\n\nERC20 and ERC721 define the fungible token and non-fungible token standard. They are designed as smart contract standards that define interfaces and specifications of virtual tokens that can be traded.\nBoth token standards allow approvals to other accounts and contracts for handling token balances. This enables composable automated markets to exist.\n\n# What are some important upgrades to the network?\n\n| Name | Date| Notes |\n| :- | :- | :- |\n| Frontier | Jul 2015 | \"thawing\" period for early adopters |\n| Frontier Thawing | Sep 2015 | lift of 5k gas limit per block |\n| | | allowed for transactions (min. 21k) |\n|  |  | difficulty bomb set to enable PoS |\n| Homestead | Mar 2016 | |\n| DAO Fork | Jul 2016 | response to DAO hack to make users whole |\n| | | Ethereum Classic remains |\n| Tangerine Whistle | Oct 2016 | response to DoS attacks due to underpriced opcodes |\n| Spurious Dragon | Oct 2016 | state trie clearing |\n| | | EIP 155 Replay attack protection (introduces chainid) |\n| | | introduces contract size limit (24k bytes) |\n| Byzantinum | Oct 2017 | adds staticcall, revert, ECC functionalities |\n| Constantinople | Feb 2019 | ability to interact with addresses that haven't been created yet |\n| Istanbul | Dec 2019 | |\n| Muir Glacier | Jan 2020 | |\n| Beacon Chain genesis | Dec 2020 | |\n| Berlin | Apr 2021 | Optional Access lists |\n| Altair | Oct 2021 | Beacon chain upgrade |\n| Arrow Glacier | Dec 2021 | |\n| Gray Glacier | Jun 2022 | |\n| Bellatrix | Sep 2022 | Beacon chain upgrade |\n| Paris (Merge) | Sep 2022 | Switch to PoS |\n\n**Difficulty Bomb:**\n- difficulty increases every 100k blocks\n- was pushed back with almost every major hard fork\n","title":"EIPS & Upgrades","excerpt":"Historical EIPS & Upgrades","date":"Invalid Date"},{"slug":"knowledge/evm","contentRaw":"\n# What is the EVM?\n\n# What is EVM equivalence?\n\n# What is your favorite opcode?\n\n# How is gas measured?","title":"EVM","date":"Invalid Date"},{"slug":"knowledge/hacks","contentRaw":"\n# Name a common vulnerability.\n\n**Reentrancy:**\n- program control is handed over to external contract (typically through ether transfers, but also flashloans)\n- prevented through re-entrancy guards, checks-effects-patterns\n\n**Uninitialized Implementation:**\n- malicious takeover through calling `init()` on implementation contract\n- Parity-multisig hack: \"oops I killed it\". Possible through general contract execution\n- Wormhole 10M$ bounty\n- bricked all proxies that pointed to implementation\n- prevented by calling `init()` on implementation\n- OZ `_disableInitializers()` in constructor prevents `init() initializer` functions from being called\n- other `initializer` modifiers that check `code.length`\n\n# Explain a recent hack\n\n**Nomad's** cross-chain messaging protocol was attacked.\n\nInitializer allows for setting a `_committedRoot` after which message tree's history begins receiving updates and `confirmAt[_committedRoot]` is set to 1 so that message can be received and processed.\nDue to upgrading Replica at same time as Home is deployed, home contains no messages and has merkle root `bytes32(0)` and thus `confirmAt[0] = 1`.\n\nThis allowed unproven messages that hash to 0 i.e. `messages[_messageHash] = 0` to be falsely processed.\nPreviously the status of a message had to be explicitly set. The update was introduced to prevent valid messages being blocked by invalid attestations.\n\nAnyone could simply replay a malicious transaction.\n\n**BNB Bridge** IAVL tree hack. Multiple valid proofs generated by inserting empty nodes in the tree. Binance has a special precompile for verifying IAVL trees\n\n**Transit Swap** vulnerability due to unverified code and insufficient message checks that allowed arbitrary token transfers from users that gave permission.\n","title":"Hacks","date":"Invalid Date"},{"slug":"knowledge/motivation","contentRaw":"\n# What excites you about Ethereum?\n\nOpen, permissionless and automated protocols are exciting.\n\n# What protocol do you find most interesting?\n\nUniswap AMM..\nPolymarket prediction markets. Uses ERC1155 conditional tokens. Able to deposit collateral to mint all possible outcomes (A, B, C, ...). These can be traded on the open markets. Once the question result is in, only the outcome can be exchanged for collateral.\n\n# What are some of the projects you've worked on?\n**CRFTD:** No-code platform for NFT projects. Allows for token creation, cross-chain staking, marketplace.\n**GMC:** NFT project on ethereum, with FxERC721M cross-chain staking. On-chain game on Polygon. Contains many components (64 transactions setup). Developed UpgradeScripts to automate and keep track of deployments. Test-setup should be as close to possible as deployment. Same setup for testing, deployment, interactions & integration tests.\n\n# Where do you see the space of security research evolving towards? What will blockchain security look like 5-10 years from now?\n\nLots of increased automation. Automatic vulnerability detection through static analysis, automatic contract type detection, contract invariant monitoring (FORTA), AI. Also automatic defenses.\n\n# What do you think are some of the most important open research questions related to blockchain security?\n\n# What is a research question that you have thought of yourself? How would you approach it?\n\n# What is your motivation for doing security research?\n\nHacking has always excited me. Felt like too far of a stretch & jump from my current field. More accessible, open playing field once I got into Ethereum. One and the same language.\nLove sifting through code, understanding new concepts. Also understanding the way another person thinks. I often rewrite code myself multiple times when I think there is a better/cleaner solution. I love discussing and optimizing code (also for simplicity and auditability). Smart contracts require high standards, diligent testing and full immersion into code.","title":"Motivation","date":"Invalid Date"},{"slug":"knowledge/open","contentRaw":"\n\n# How is metering measured? \nXXX\n\n# What is turing completeness?\n\nSystem/Program has enough power of expression to be equivalent to a turing machine.\n\n**Turing machine:** Mathematical model describing an abstract machine that can change symbols on a strip of tape according to a table of rules. Capable to implement every computer program.\n\nSome requirements:\n- supports input/output\n- conditional branching\n- infinite loops\n- can use infinite memory (memory limitations often ignored for computer languages)\n- halting problem is unavoidable\n\n# What is the halting problem?\n\nTuring used the turing machine to answer the question of whether an algorithm could exist that is able to determine whether a computer program stops at some point or continues on for ever.\n\nExample:\nChecker app checks whether program M halts\n- approve if M halts\n- reject if M loops\n\nConstruct Paradox app:\nRun Checker app on Paradox app and loop if Check(M) = good. Halt if Check(M) = bad.\n- if Paradox halts => Check(P) = bad, but that means that P should have looped\n- if Paradox loops => Check(P) = good, but that means that P should have halted\n\n\n\n# What is the DAO hack?\n\n# Explain UTXO account structure. \n\n2. Explain proof of stake. How are validators selected in the network (Ethereum)? \n3. Explain other consensus mechanisms and how they work\n----- Solidity -------\n1. Name a common vulnerability\n2. How would you mitigate it\n3. What are potential attack vectors for (here they listed of random shit, eg reentrancy, tx.origin phising, unitialized storage pointer pre 0.8.1, safemath, etc) and how would you mitigate them?\n4. Questions on defi attack vectors (eg DoS through strict equalities, flash loan attacks, uniswap invariant maintenance,  how to get the price of an LP token correctly (warp finance hack)) \n5. Explain one recent defi hack and what you thought about it (I chose cream finance hack, big fucking mistake since it's probably one of the hardest, should have chose something basic like visor finance hack)\n---- EVM----\n1. contract creation, explain it, runtime vs init bytecode, create2 intricacies,\n2. EVM storage (data areas eg stack storage memory and differences)\n3. L2 intricacies\n4. Proxies (I did not do well on this one lol particularly ERC1967 proxy storage layout)\n5. what can/can't you do in a constructor\nobviously I'm missing a lot since I didn't memorize a 2 hour interview but these are probably fairly common questions you'd expect for a junior sec engineer position","title":"Unordered Notes","date":"Invalid Date"},{"slug":"knowledge/questions","contentRaw":"# How do you approach an audit? How do you start and tackle an audit?\n\n# What tools do you use?\n\n# Do you know how slither works?\n\n# Do you know what an intermediate representation?\n\n# Do you know what fuzzing is?\n\n# Do you use fuzzing yourself?\n\n# What fuzzer do you use?\n\n# What is difficult about fuzzing?\n\n# What is something new that you have seen / been following?\n\n# What do you mean by automated defending / attacking systems?\n\n# What is the difference to Bitcoin?\n\n# What do you know about smart contracts on Bitcoin?\n\n# What is proof of work?\n\n# What is it for?\n\n# What happens if two blocks are proposed at the same time?\n\n# What can a block proposer decide on?\n\n# Can a block proposer censor transactions?\n\n# Can a block proposer change transaction data?\n\n# What about the block timestamp?\n\n# What happens if I change the block timestamp to 10 days in the future? What happens if I make the change in GETH?\n\n# What are uncle blocks?\n\n# Why is this incentive for uncle blocks in Ethereum but not Bitcoin?\n\n# Why do I have to spend gas for transactions?\n\n# What is re-entrancy?\n\n# Does it have to re-enter through the same function?\n\n# How would you detect these?\n\n# Can these be detected automatically?\n\n# How can you mitigate this?\n\n# Is every external call vulnerable to re-entrancy?\n\n# How would you check for overflow in a code base?\n\n# Can you explain overflow?\n\n# What is unchecked used for?\n\n# Is every overflow bad and needs to be flagged? Is every overflow critical?\n\n# How would you prevent overflow? How do you recommend guarding against it?\n\n# How can you test for overflow?\n\n# Where can gas limits for come into play?\n\n# Is always unlimited gas forwarded?\n\n# What is the 1/64 rule?\n\n# How would you prevent a unlimited storage array from grieving a contract?\n\n# Say it's used for a lookup, how would you mitigate the issue of an unbounded array?\n\n# What is ecrecover?\n\n# What are some pitfalls to look out for with ecrecover?\n\n# How do you prevent replays from happening across chains?\n\n# What do you think is cool about solidity?\n\n# What are some things to look out for with storage pointers?\n\n# What are some main mistakes that you see developers doing?\n\n# What is a flashloan?\n\n# Is there something controversial about flashloans?\n\n# Are flashloans a bug?\n\n# Could disallowing flashloans have prevented defi hacks?\n\n# What is an AMM?\n\n# How are assets priced in AMMs?\n\n# Does k ever change? Does it change during a swap?\n\n# What does it mean if k increases? Is it a bad thing?\n\n# Why does k increase over time?\n\n# Can it happen that you get a less optimal price for a swap?\n\n# What kind of risks exist for liquidity providers?\n\n# Can you explain impermanent loss?\n\n# What is there to look out for when dealing with ERC20 tokens as a protocol developer?\n\n# Do you need to check for code size before calling .transferFrom?\n\n# Do certain tokens need to be disallowed?\n\n# What is included in a transaction?\n\n# What is a nonce?\n\n# How does a contract know what function is being called?\n\n# Is there anything bad about the design? Could you improve it?\n\n# Can two functions have the same name?\n\n# Could function selectors include a return type?\n\n# Where can a variable be located in solidity's memory model?\n\n# How does create/create2 work?\n\n# Is there anything interesting that can happen with create2?\n\n# How can a upgradeable contract be created with this?\n\n# How can create2 be used to deploy different code at the same location?\n\n# What happens at a low level during create/constructor?\n\n# Is there anything wrong with checking address(this)?\n\n# What can you say about upgradeable contracts?\n\n# Can you have upgradeability without proxies?\n\n# Is there some other way of having upgradeability?\n\n# What is important to remember about upgradeable contracts?\n\n# What would you check in a contract audit that uses upgradeable contracts?\n\n# Is there something to be aware of during an upgrade from contract A to B?\n\n# How are arrays stored?\n\n# Does every opcode cost the same?\n\n# If you were trying to come up with the pricing for opcodes, how would you approach this?\n\n# What kind of hardware would you run these tests on?\n","date":"Invalid Date"},{"slug":"knowledge/storage","contentRaw":"\n# How is Data in Ethereum stored?\n\n# What is a Merkle Patricia Tree/Trie?\n\n# What kind of storage locations are available in a function?\n\n# How are events stored?","title":"Ethereum Storage","date":"Invalid Date"},{"slug":"unpublished/rsa","contentRaw":"\n*Notes taken from the [RSA paper](https://people.csail.mit.edu/rivest/Rsapaper.pdf)*.\n\n## Table of Contents\n\n## RSA\n\n$$\ndec(enc(M)) = M\n$$\n\n\nA *trap-door one-way function* allows a message $M$ to be encrypted as cyphertext $C$\ngiven a public (known) key / encryption method ($enc$).\n$C$ is only able to be deciphered in a reasonable time if the private key ($dec$) is known.\n\nFirst, assume that $M$ can be represented as an integer $\\in [0, n-1]$ (if not, break it into blocks).\nEncrypting/Decrypting $M$ with the public key ($e$, $n$) $\\in \\mathbb N^+$ works by:\n\n### Encrypting $M$\n$$\nC = enc(M) = M ^e \\quad (\\text {mod} \\; n)\n$$\n\n### Decrypting $C$\n$$\ndec(C) = C ^d \\quad (\\text {mod} \\; n)\n$$\n\n### Steps\n| Steps                                      | Variables                   |\n| ------------------------------------------ | --------------------------- |\n| find $p$ and $q$ two large prime numbers   | $p$, $q$ prime              |\n| calculate $n=pq$                           | $n = pq$                    |\n| calculate $\\phi (n) = (p - 1)(q - 1)$      | $\\phi (n) = (p - 1)(q - 1)$ |\n| pick $e$ relatively prime to $\\phi (n)$    | $e$                         |\n| pick $d$ mul inverse of $e$ mod $\\phi (n)$ | $d$                         |\n\nTo use RSA, one must find $p$ and $q$, two very large, random prime numbers.\n\nTheorem states\n\nThe security of the scheme relies on the fact that it is computationally infeasible to derive $p$ and $q$ from $n$.\n\n*Public key*: $[e, n]$\n*Private key*: $[d, n]$\n\n\n## Why does this work?\n\n$$\ndec(enc(M)) = (M^e)^d = M ^{ed} \\quad (\\text {mod} \\; n)\n$$\n\nWe would like to show that $M^{ed} \\; (\\text {mod} \\; n) \\overset ! = M$.\nWe know that $e$ and $d$ are multiplicative inverses ($\\text {mod} \\; \\phi (n)$):\n$$\ned \\equiv 1 \\quad (\\text{mod} \\; \\phi (n))\n$$\n\nThis means that there exists some $k \\in \\mathbb N^+$ s.t.\n$$\ned = k \\phi(n) + 1\n$$\n\nThis leads us to\n$$\n\\begin{equation}\n\\begin{align*}\nM^{ed} = M^{k \\phi(n) + 1} \n&= M^{k (p - 1)(q -1 ) + 1} \\\\\n&= M(M^{k(q - 1)})^{(p - 1)}\n\\end{align*}\n\\end{equation}\n$$\n\n\n### Fermat's little theoreom\n\n[Fermat's little theoreom](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem) states that \n$$\na^p \\equiv a \\quad (\\text {mod} \\; p)\n$$\nfor any integer $a$ and prime $p$.\n\nIf $a \\not\\equiv 0 \\ (\\text {mod} \\; p)$, then\n$$\na^{(p - 1)} \\equiv 1 \\quad (\\text {mod} \\; p)\n$$\n\nUsing Fermat's little theorem in equation $(1)$, we can conclude that\n\n$$\n\\begin{align*}\nM^{ed} \n&= M(M^{k(q - 1)})^{(p - 1)} \\\\\n&\\equiv M \\quad (\\text{mod} \\; p)\n\\end{align*}\n$$\n\nUsing the same logic, we can show that \n\n$$\nM^{ed} \\equiv M \\quad (\\text{mod} \\; q)\n$$\n\n### Chinese remainder theoreom\n\nThe [Chinese remainder theorem](https://en.wikipedia.org/wiki/Chinese_remainder_theorem) (adapted to this case) states that:\n\nIf \n$x \\equiv M \\; (\\text{mod} \\; p)$\nand\n$x \\equiv M \\; (\\text{mod} \\; q)$\nfor two co-prime integers $p$, $q$\nthen\n$x \\equiv M \\; (\\text{mod} \\; pq)$\n\nUsing these two theorems, we conclude that \n$$\nM^{ed} \\equiv M \\; (\\text{mod} \\; n)\n$$\n\n\nQuestions:\n- why $\\phi$\n- Why $e$ relatively prime\n\n$$\n\\phi(n) = n \\prod _{p | n}(1 - \\frac 1 p) \n= n ( 1 - \\frac 1 p)(1 - \\frac 1 q)\n= n ( \\frac {p - 1}  p)(\\frac {q - 1} q)\n= (p - 1)(q - 1)\n$$\n\n\nhttps://eli.thegreenplace.net/2019/rsa-theory-and-implementation/","title":"RSA","date":"12 May 2022","excerpt":"Taking a look at RSA","suptitle":"\"The era of 'electronic mail' may soon be upon us\"\n"}]},"__N_SSG":true}