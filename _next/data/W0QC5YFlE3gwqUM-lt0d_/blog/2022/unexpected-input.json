{"pageProps":{"postData":{"slug":["2022","unexpected-input"],"contentRaw":"\nThere's a bug that seems to occur fairly frequently in the NFT projects venturing\ninto the DeFi-space.\nMy guess is that this is because there have not been\nfully audited ERC721 and trusted staking contracts,\nlike the Synthetix staking contract.\nI first got to know this bug through Mutant Cats' [FishFarm](https://etherscan.io/address/0xb2f43262fc23d253538ca5f7b4890f89f0ee95d9#code)\nand\nStacked Toadz' [ERC721Farm](https://etherscan.io/address/0x4d1de90bca7a38c556c356c0b802b5102cea032d#code).\n\nMutant Cats were lucky enough to get notified by the community about the vulerability\nand began migrating to a new staking contract in time.\nStacked Toadz [were not so lucky](https://twitter.com/stacked_toadz/status/1448953720348102660)\nwith the hacker making off with 43 ETH from the looted $STACKS.\n\nBecause of a project I'm working on, I wanted to make sure that all of the tokens that will be\nable to interact with our eco-system follow the ERC20 standard\n(and don't resort to a O(N) balanceOf implementation).\nAnd just out of curiosity I went ahead and looked at some of their implementations.\n\nI was able to find the same bug in [UniQuest](https://etherscan.io/address/0x3a6d70e7989ba6e7d5958d7c1eea487082681698/advanced#code), the staking contract for Uninterested Unicorns.\nThe Unicandy UCD-ETH pool maximally allowed for swapping out around 100 ETH.\n\n# The code\n\nThe relevant code to claim ERC20 rewards for Mutant Cats is shown below.\n\n```js\ncontract FishFarm {\n    ...\n\n    function calculateRewards(address account, uint256[] memory tokenIds)\n        public\n        view\n        returns (uint256[] memory rewards)\n    {\n        rewards = new uint256[](tokenIds.length);\n\n        for (uint256 i; i < tokenIds.length; i++) {\n            uint256 tokenId = tokenIds[i];\n\n            rewards[i] =\n                RATE *\n                (_deposits[account].contains(tokenId) ? 1 : 0) *\n                (Math.min(block.number, EXPIRATION) -\n                    depositBlocks[account][tokenId]);\n        }\n    }\n\n    function claimRewards(uint256[] calldata tokenIds) public {\n        uint256 reward;\n        uint256 block = Math.min(block.number, EXPIRATION);\n\n        uint256[] memory rewards = calculateRewards(msg.sender, tokenIds);\n\n        for (uint256 i; i < tokenIds.length; i++) {\n            reward += rewards[i];\n            depositBlocks[msg.sender][tokenIds[i]] = block;\n        }\n\n        if (reward > 0) {\n            try IERC20(FISH).transfer(msg.sender, reward) returns (bool v) {\n            } catch Error(string memory) {}\n        }\n    }\n}\n```\n\nThe `claimHODLRewards` is part of the\n[UniQuest](https://etherscan.io/address/0x3a6d70e7989ba6e7d5958d7c1eea487082681698/advanced#code)\nstaking contract for Uninterested Unicorns NFT.\n\n```js\n\ncontract UniQuest {\n    ...\n\n    function claimHODLRewards(uint256[] memory tokenIds) public nonReentrant {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(\n                UU.ownerOf(tokenIds[i]) == msg.sender,\n                \"UniQuest: Not Owner of token\"\n            );\n        }\n\n        uint256 rewards = calculateHODLRewards(tokenIds);\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            HODLLastClaim[tokenIds[i]] = block.timestamp;\n        }\n\n        UCD.mint(msg.sender, rewards);\n    }\n\n\n    function calculateHODLRewards(uint256[] memory tokenIds)\n        public\n        view\n        returns (uint256 HODLRewards)\n    {\n        HODLRewards = 0;\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            HODLRewards = ...\n        }\n    }\n}\n```\n\n# The bug\n\nThe bug is possible because in both contracts, the rewards calculation is separated from the\nstate-update to the blockchain and because they allow for unchecked user input.\nThe reward is calculated by first looping over the user-inputted token ids.\nAnd only afterwards the claimed timestamp for each token id is set in another loop.\n\nThe problem is that the user is able to input a token id they own\nas many times as they want. There is nothing stopping them\nfrom inputting `claimRewards([3, 3, 3, 3, ...])` for example.\nThis allows the attacker to mint an unlimited amount of tokens from\nthe staking contract.\n\n# The solution\n\nA checks-effects-interactions pattern - well known for guarding\nagainst reentrancy bugs - would have prevented these exploits from being possible.\nInstead of using two-loops, the correct way would be to use one loop\nand to set the timestamp for the last claim directly after checking\nthe rewards for a certain token id.\n\nAlso, in general it makes sense to limit the degree-of-freedom a user has\nwhile interacting with a contract. **Fishfarm** had direct access to `_deposits`\nand **Uninterested Unicorns** is an _ERC721Enumerable_, so both contracts could\nhave restricted user-input by having a function `claimRewards()` instead that\ndirectly claims the rewards for all token ids.\n\nAfter getting into contact with the Uninterested Unicorns team, they were able to\nupgrade their proxy contract's implementation - no unicorns hurt.\n","title":"Bug Report","suptitle":"Uninterested Unicorns","date":"2022-3-12","excerpt":"There's a bug that seems to occur fairly frequently in the NFT projects venturing into the DeFi-space."}},"__N_SSG":true}