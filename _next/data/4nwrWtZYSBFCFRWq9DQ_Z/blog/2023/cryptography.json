{"pageProps":{"postData":{"slug":["blog","2023","cryptography"],"contentRaw":"\n_These are notes taken from [An Introduction to Mathematical Cryptography](https://link.springer.com/book/10.1007/978-0-387-77993-5) that I'll update every once in a while as I continue through the book. I've tried several books on cryptography, but this was the only one that felt right. I highly recommend buying it. It is filled with great examples, stories and exercises that you won't find in these notes._\n\n**Table of Contents**\n\n- [1. An Introduction to Cryptography](#1-an-introduction-to-cryptography)\n  - [1.2 Divisibility and greatest common divisors](#12-divisibility-and-greatest-common-divisors)\n  - [1.3 Modular arithmetic](#13-modular-arithmetic)\n    - [1.3.1 Modular arithmetic and shift ciphers](#131-modular-arithmetic-and-shift-ciphers)\n    - [1.3.2 The fast powering algorithm](#132-the-fast-powering-algorithm)\n  - [1.4 Prime numbers, unique factorization, and finite fields](#14-prime-numbers-unique-factorization-and-finite-fields)\n  - [1.5 Powers and primitive roots in finite fields](#15-powers-and-primitive-roots-in-finite-fields)\n  - [1.7 Symmetric and asymmetric ciphers](#17-symmetric-and-asymmetric-ciphers)\n    - [1.7.1 Symmetric ciphers](#171-symmetric-ciphers)\n    - [1.7.3 Symmetric encryption of encoded blocks](#173-symmetric-encryption-of-encoded-blocks)\n    - [1.7.4 Examples of symmetric ciphers](#174-examples-of-symmetric-ciphers)\n    - [1.7.6 Asymmetric ciphers make a first appearance](#176-asymmetric-ciphers-make-a-first-appearance)\n- [2 Discrete Logarithms and Diffie–Hellman](#2-discrete-logarithms-and-diffiehellman)\n  - [2.1 The birth of public key cryptography](#21-the-birth-of-public-key-cryptography)\n  - [2.2 The discrete logarithm problem](#22-the-discrete-logarithm-problem)\n  - [2.3 Diffie–Hellman key exchange](#23-diffiehellman-key-exchange)\n  - [2.4 The ElGamal public key cryptosystem](#24-the-elgamal-public-key-cryptosystem)\n  - [2.5 An overview of the theory of groups](#25-an-overview-of-the-theory-of-groups)\n  - [2.6 How hard is the discrete logarithm problem?](#26-how-hard-is-the-discrete-logarithm-problem)\n  - [2.7 A collision algorithm for the DLP](#27-a-collision-algorithm-for-the-dlp)\n  - [2.8 The Chinese remainder theorem](#28-the-chinese-remainder-theorem)\n\n# 1. An Introduction to Cryptography\n\n## 1.2 Divisibility and greatest common divisors\n\n> **Definition.** Let $a, b \\in \\mathbb Z$ and $a \\neq 0$.\n> Then $a \\mid b$ (\"$a$ divides $b$\"), if there exists $q \\in \\mathbb Z$ s.t.\n>\n> $$\n> q \\cdot a = b\n> $$\n\n> **Proposition 1.4** Let $a, b, c \\in \\mathbb Z$\n>\n> - If $a \\mid b$ and $b \\mid c$ $\\implies$ $a \\mid c$\n> - If $a \\mid b$ and $b \\mid a$ $\\implies$ $a = \\pm b$\n> - If $a \\mid b$ and $a \\mid c$ $\\implies$ $a \\mid (a + c)$ and $a \\mid (b - c)$\n\n> **Definition.** The _greatest common divisor_ of $a$ and $b$ is the largest positive integer $d$ such that $d \\mid a$ and $d \\mid b$.\n\n> **Definition.** (Euclidean Algoritm) Let $a, b \\in \\mathbb Z$. Then $a$ divided by $b$ has quotient $q$ and remainder $r$.\n>\n> $$\n> a = bq + r \\quad \\text{with } 0 \\leq r \\lt b\n> $$\n>\n> From this formula and Proposition 1.4 we get\n>\n> $$\n> \\gcd(a, b) = \\gcd(b, r)\n> $$\n>\n> Continuing this process with $\\gcd(b, r) = \\gcd(r', r)$ we eventually arrive at $\\gcd(s, 0) = s$ where $s = \\gcd(a, b)$.\n\n> **Theorem 1.11** (Extended Euclidean Algorithm). Let $a, b \\in \\mathbb N$. Then\n>\n> $$\n> au + bv = \\gcd(a, b) \\;, \\quad u, v \\in \\mathbb Z\n> $$\n>\n> always has a solution.\n>\n> If $(u_0, v_0)$ is one solution, then every solution has the form\n>\n> $$\n> u = u_0 + \\frac {bk} {\\gcd(a, b)}\n> \\quad \\text{and} \\quad\n> v = v_0 + \\frac {ak} {\\gcd(a, b)}\n> \\quad \\text{for some } k \\in \\mathbb Z\n> $$\n\n_Proof._\n\nSubstitute the remainder in each step of the Euclidean Algorithm into the equation of the next step\nin order to arrive at the expression.\n\n> **Definition.** Let $a, b \\in \\mathbb Z$. We say that $a$ and $b$ are _relatively prime_ or _coprime_ if $\\gcd(a, b) = 1$.\n>\n> More generally, any equation\n>\n> $$\n> au + bv = \\gcd(a, b)\n> $$\n>\n> can be reduced to the case of relatively prime numbers by dividing both sides by $\\gcd(a, b)$.\n>\n> $$\n> \\frac a {\\gcd(a, b)} u + \\frac b {\\gcd(a, b)} v = 1\n> $$\n\n## 1.3 Modular arithmetic\n\n> **Definition.** Let $m \\geq 1$ be an integer. We say that integers $a$ and $b$ are _congruent modulo m_ if their difference $a - b$ is divisible by $m$.\n>\n> $$\n> a \\equiv b \\pmod m\n> $$\n\n> **Proposition 1.13.** Let $m \\geq 1$ be an integer.\n> \\\n> \\\n> **(a)** If $a_1 \\equiv a_2 \\pmod m$ and $b_1 \\equiv b_2 \\pmod m$, then\n>\n> - $a_1 \\pm b_1 \\equiv a_2 \\pm b_2 \\pmod m$\n> - $a_1 \\cdot b_1 \\equiv a_2 \\cdot b_2 \\pmod m$\n>\n> \\\n> **(b)** Let $a \\in \\mathbb Z$. Then\n>\n> $$\n> \\exists b \\in \\mathbb Z :\\; a \\cdot b \\equiv 1 \\pmod m \\; \\iff \\gcd(a, m) = 1\n> $$\n\n_Proof._\n\n$\\implies:$\nAssume $g = \\gcd(a, m) \\neq 1$, then $g \\mid a$ and $g \\mid m$.\nNow let $b \\in \\mathbb Z$, then $ab = mk + r$.\nIt follows that $g \\mid (ab - mk)$ and thus $g \\mid r$. But if $g \\neq 1 \\mid r$, then $r \\neq 1$.\n\n$\\impliedby:$\nTheorem 1.11 says that $ab + mk = \\gcd(a, m) = 1$ has a solution for $b, k \\in \\mathbb Z$.\nBecause $ab - 1 = -mk$, $ab \\equiv 1 \\pmod m$.\n\n> **Definition.** Numbers that have multiplicative inverses modulo $m$ are called _units_.\n>\n> $$\n> \\begin{aligned}\n> (\\mathbb Z / m \\mathbb Z)^*\n> &= \\{a \\in \\mathbb Z / m \\mathbb Z : \\gcd(a, m) = 1\\} \\\\\n> &= \\{a \\in \\mathbb Z / m \\mathbb Z : a\\text{ has an inverse modulo }m\\}\n> \\end{aligned}\n> $$\n>\n> The set $(\\mathbb Z / m \\mathbb Z)^*$ is called the _group of units modulo m_.\n>\n> If $a_1$ and $a_2$ are units, then so is $a_1 \\cdot a_2$.\n> On the other hand, if we add two units, we do not always get a unit.\n\n> **Definition.** _Euler's phi function_ (or _Euler's totient function_) is the function $\\Phi(m)$ defined by\n>\n> $$\n> \\Phi(m) = \\#(\\mathbb Z / m \\mathbb Z) ^* = \\# \\{ 0 \\leq a \\lt m: \\gcd(a, m) = 1\\} \\;.\n> $$\n\n### 1.3.1 Modular arithmetic and shift ciphers\n\n_Encryption._\n\n$$\nc \\equiv p + k \\pmod {26}\n$$\n\n_Decryption._\n\n$$\np \\equiv c - k \\pmod {26}\n$$\n\n### 1.3.2 The fast powering algorithm\n\n$g^A \\pmod N$ can be computed by a succession of squarings and multiplications by using the binary expansion of the exponent, $A = A_0 + A_1 \\cdot 2^1 + \\cdots + A_r \\cdot 2^r$.\n\n_Example 1.19._\n\n$$\n3^{128}\n= 3^{2 + 2^3 + 2^4 + 2^6 + 2^7}\n= 3^{2^1} + 3^{2^3} + 3^{2^4} + 3^{2^6} + 3^{2^7}\n$$\n\n**Running Time.**\nIt takes at most $2r$ multiplications mod $N$ ($r$ multiplications for computing the squares and $r$ multiplications when computing the final result).\nBecause $A \\geq 2^r$, it takes at most $2\\log_2(A)$ multiplications to compute $g^A$.\nIf $A \\approx 2^{1000}$, this is about $2000$ multiplications.\n\n## 1.4 Prime numbers, unique factorization, and finite fields\n\n> **Definition.** An integer $p$ is called a _prime_ if $p \\geq 1$ and if the only positive divisors are $1$ and $p$.\n\n> **Proposition 1.20.** Let $p$ be a prime number that divides the product $ab$ of two integers.\n> Then $p$ divides at least one of $a$ and $b$.\n> More generally, if $p \\mid a_1a_2\\cdots a_n$, then $p$ divides at least one of the $a_i$.\n\n_Proof._\n\nLet $g = \\gcd (a, p)$. Then $g \\mid p$, so either $g = 1$ or $g = p$. If $g = p$, then $p \\mid a$ and we're done.\n\nOtherwise if $g = 1$, then Theorem 1.11 says that we're able to find $u$, $v$ satisfying $au + pv = 1$. Multiplying by $b$ gives\n\n$$\nabu + pbv = b\n$$\n\nSince $p \\mid ab$ and $p \\mid pbv$, $p$ divides the left-hand side and so $p \\mid b$.\n\n> **Theorem 1.21 (The Fundamental Theorem of Arithmetic).**\n> Let $a \\geq 2$ be an integer. Then $a$ can be factored as a product of prime numbers\n>\n> $$\n> a =\n> p_1^{e_1}\n>  \\cdot p_2^{e_2}\n>  \\cdot p_3^{e_3}\n>  \\cdots\n>   p_r^{e_r}\n>  \\; .\n> $$\n>\n> This factorization is unique.\n\n_Proof._\n\nA simple algorithm can be used to prove that every $a \\geq 2$ can be factored into primes.\nTo prove uniqueness of the factorization, let\n$a = p_1^{e_1} \\cdot p_2^{e_2} \\cdot p_3^{e_3} \\cdots p_r^{e_r} = q_1^{f_1} \\cdot q_2^{f_2} \\cdot q_3^{f_3} \\cdots q_r^{f_s}$\nbe two factorizations of $a$.\n\n$p_1$ is a factor of $a$, so by Proposition 1.20, it must divide the product $\\prod_{i=1}^s q_i^{f_i}$. Since $p_1$ is prime, it means that there is an $1 \\leq i \\leq s$ with $q_i = p_1$.\n\nNow, since $p_1^{e_1}$ divides the product, $p_1$ must also appear with the same exponent. This process can be repeated to show that $r = s$ and $\\prod_{i=1}^r p_i^{e_i} = \\prod_{i=1}^s q_i^{f_i}$.\n\n> **Definition.** The _order_ or _exponent_ of a prime $p$ in $a$ - $\\text {ord} _p (a)$ - is given by the power of $p$ in the factorization of $a$.\n>\n> $$\n> a = \\prod _{p \\text { prime}} p^{\\text {ord} _p (a)}\n> $$\n\n> **Proposition 1.22.** Every element $a \\neq 0$ in $\\mathbb Z / p \\mathbb Z$ has a multiplicative inverse for $p$ prime.\n>\n> $$\n> ab = 1 \\pmod p\n> $$\n>\n> We denote $b = a^{-1} \\pmod p$.\n\n_Proof._ This follows directly from Proposition 1.13 b)\n\nUsing the Euclidean Algorithm we can compute $a^{-1}$ efficiently by solving\n\n$$\nau + pv = 1 \\;.\n$$\n\nIf follows that $u = a^{-1}$.\n\nWith Proposition 1.22 we get that $(\\mathbb Z / p \\mathbb Z)^* = \\{1, 2, \\ldots, p-1\\}$.\n\n> **Definition.** $\\mathbb Z / p \\mathbb Z$ is a _field_. A field is a _Ring_ with the additional property that every nonzero element has a multiplicative inverse.\n>\n> We write $\\mathbb F_p = \\mathbb Z / p \\mathbb Z$ for the finite field of $p$ elements and $\\mathbb F_p^* = (\\mathbb Z / p \\mathbb Z)^*$ for its group of units with $p - 1$ elements.\n\n## 1.5 Powers and primitive roots in finite fields\n\n> **Theorem 1.25 Fermat's Little Theorem.** Let $p$ be a prime and $a$ an integer. Then\n>\n> $$\n> a^{p-1} \\equiv\n> \\begin{cases}\n> 1 \\pmod p \\quad \\text{if } p \\nmid a \\,, \\\\\n> 0 \\pmod p \\quad \\text{if } p \\mid a \\,,\n> \\end{cases}\n> $$\n\n_Proof._ If $p \\mid a$ (this means that $k \\cdot p = a$ for some $k \\in \\mathbb N$), then $(k \\cdot m) \\cdot p = m \\cdot a$ for any $m \\in \\mathbb N$. Thus $p$ divides any multiple $p \\mid m \\cdot a$ (and factor of $a$). It follows that $a^{p - 1} = 0 \\pmod p$.\n\nGiven $p \\nmid a$\n\n<!-- , there is an $r$, such that $k \\cdot p + r = a$. -->\n\n$$\n\\begin{aligned}\n&     & a^{p - 1} &\\equiv 1 \\\\\n&\\iff & a^{p - 1} (p-1)! &\\equiv (p-1)! \\\\\n&\\iff & a \\cdot 2a \\cdot 3a \\cdot \\ldots \\cdot (p - 1) a &\\equiv\n1 \\cdot 2 \\cdot 3 \\cdot \\ldots \\cdot (p - 1)\n\\end{aligned}\n$$\n\nIf we can show that $ka$, $k \\in [1..(p-1)]$ **generates all elements in** $\\mathbb F_p$, then we are done.\n\nTake any $k \\neq j \\in [1..(p-1)]$, then assume for the sake of contradiction, that $ka \\equiv ja \\iff (k - j) a \\equiv 0$. It would immediately follow that $p \\mid a$. Therefore, $k = j$ must be true.\n\n> **Remark.** From this theorem we immediately get that $a^{-1} \\equiv a^{p - 2} \\pmod p$, an algorithm for finding the inverse.\n\n> **Theorem 1.25 (Fermat's little theorem).** Let $p$ be a prime and $a$ an integer, such that $p \\nmid a$. Suppose that $a^n \\equiv 1 \\pmod p$, it follows that the order of $a \\pmod p$ divides $n$ and $p - 1$.\n\n_Proof_. Let $k$ be the order of $a \\pmod p$, i.e. $k$ is the smallest positive integer, such that $a^k = 1 \\pmod p$. We want to show that $k \\mid n$.\n\n$$\nkp + r = n\\,, \\quad 0 \\leq r \\lt k\n$$\n\n$$\n1 = a^n = a^{kp + r} = (a^k)^pa^r = a^r\n$$\n\nIt follows that $r = 0$, since $r \\lt k$.\n\n> **Theorem 1.31.** (Primitive Root Theorem). Let $p$ be a prime. There exists an element $g \\in \\mathbb F_p^*$ which generates $\\mathbb F_p^*$, i.e.\n>\n> $$\n> \\mathbb F_p^* = \\{1, g, g^1, g^2, \\ldots, g^{p-2}\\}\n> $$\n>\n> These elements are called _primitive roots_ of $\\mathbb F_p$, or _generators_ of $\\mathbb F_p^*$.\n\n## 1.7 Symmetric and asymmetric ciphers\n\n### 1.7.1 Symmetric ciphers\n\nSymmetric ciphers are when both parties share the same (or symmetric) knowledge of the secret key $k$. E.g. Bob and Alice both _encrypt_ and _decrypt_ a message using the same secret key.\n\nThe encryption function $e$ takes a secret key $k$ in the space of all possible keys $\\mathcal K$ and transforms a message $m$ from all possible messages $\\mathcal M$ to a ciphertext $c$ belonging to the space of all possible ciphertexts $\\mathcal C$.\n\n$$\ne: \\mathcal K \\times \\mathcal M \\to \\mathcal C\n$$\n\nDecrypting takes the same key $k$ and maps the ciphertext $c$ back to a message $m$.\n\n$$\nd: \\mathcal K \\times \\mathcal C \\to \\mathcal M\n$$\n\nThe decryption function should map back to the preimage of the encryption one-to-one.\n\n$$\nd(k, e(k, m)) = m \\quad \\forall k \\in \\mathcal K, m \\in \\mathcal M\n$$\n\nThe following notation will be used.\n\n$$\ne_k: \\mathcal M \\to \\mathcal C\n\\qquad\nd_k: \\mathcal C \\to \\mathcal M\n\\qquad\nd_k(e_k(m)) = m\n$$\n\n> _Kerckhoff's principle_. The security of a crypto system should only depend on the secrecy of the key and not the secrecy of the encryption algorithm itself.\n\nA few desirable properties are:\n\n1. $e_k(m)$ should be easy to compute.\n2. $d_k(m)$ should be easy to compute.\n3. Given $c_1, c_2, \\ldots, c_n \\in \\mathcal C$ it should be very difficult to compute any plaintext $d_k(c_1), \\ldots, d_k(c_n)$ without knowledge of $k$.\n\nAn additional stronger property would be:\n\n4. _Security against a chosen plaintext attack_: Given any number of pairs of plaintexts and their corresponding ciphertexts, $(m_1, c_1), (m_2, c_2), \\ldots, (m_n, c_n)$, it must also be difficult to decrypt any ciphertext $c$ that is not in the list without knowledge of $k$.\n\nAny substitution cipher does not satisfy property 4, since any plaintext-ciphertext pair reveals a lot about the encryption table.\n\n> **Definition.** An _encoding scheme_ transforms data, e.g. text to numbers, and consists of an _encoding_ and _decoding_ function which are publicly known, fast, and easy to compute.\n\n### 1.7.3 Symmetric encryption of encoded blocks\n\nAny message $m \\in \\mathcal M$ can be seen as a bit string of fixed length $B$ (_blocksize_). The encryption and decryption functions can then transform plaintext message blocks of fixed length to ciphertext blocks of fixed—but not necessarily the same—length. If a message is too short to fill out the block, it can be padded.\n\n$$\n\\begin{aligned}\n\\mathcal K &= \\{ k \\in \\mathbb Z: 0 \\le k \\lt 2^{B_k}\\} \\\\\n\\mathcal M &= \\{ m \\in \\mathbb Z: 0 \\le m \\lt 2^{B_m}\\} \\\\\n\\mathcal C &= \\{ c \\in \\mathbb Z: 0 \\le c \\lt 2^{B_c}\\}\n\\end{aligned}\n$$\n\nA key block size $B_k$ should be chosen large enough such that a _brute-force attack_ (_exhaustive search_) is infeasible.\n\n### 1.7.4 Examples of symmetric ciphers\n\nLet $p$ be a large prime (e.g. $2^{159} < p < 2^{160}$) and $\\mathcal K = \\mathcal M = \\mathcal C = \\mathbb F_p ^* = \\{1, 2, 3, \\ldots, p - 1\\}$ (the _group of units_ of $\\mathbb F_p$).\n\nAlice and Bob chose a key $k \\in \\mathcal K$, and define\n\n$$\n\\begin{aligned}\ne_k(m) &\\equiv k \\cdot m &&\\pmod p \\\\\nd_k(m) &\\equiv k^{-1} \\cdot m &&\\pmod p\n\\end{aligned}\n$$\n\nThis encryption scheme satisfies properties 1, 2 and 3, however it is missing property 4. The secret key $k$ can be recovered through $k \\equiv m^{-1} \\cdot c \\pmod p$.\n\nConsider a modification of the scheme where the reduction modulo $p$ is removed. This scheme would fail to satisfy property 3. In the case that Eve knows ciphertexts $c_1, c_2, \\ldots, c_n$, then with increasing $n$, there is a good chance that the $\\gcd$ of all ciphertexts equals $k$ or some small multiple of it.\n\n$$\n\\begin{aligned}\n&&& \\gcd (c_1, c_2, \\ldots, c_n) \\\\\n&&=& \\gcd (k \\cdot m_1, k \\cdot m_2, \\ldots, k \\cdot m_n) \\\\\n&&=& k \\cdot \\gcd (m_1, m_2, \\ldots, m_n)\n\\end{aligned}\n$$\n\nThe modification of this scheme to use addition instead of multiplication leads to a _Caesar cipher_. Further generalizations lead to an _affine_ or _Hill cipher_ (using matrix multiplications).\n\n_Example 1.35. (Vernam's one-time pad)._\n\nUsing the XOR operation $\\oplus$ a _one-time pad_ is generated by selecting a key $k$ which is as long as the message itself.\n\n$$\ne_k(m) = k \\oplus m \\qquad\nd_k(c) = k \\oplus c\n$$\n\nIf $k$ is random, then the scheme is provably secure, as long as the key is only used once. The biggest problem with this cipher is the key length requirement. It is possible to use a small length key $k$ to generate a one-time pad through a _pseudorandom number generator_ seeded with the key $R_k$: $R_k(1), R_k(2), \\ldots, R_k(B_M)$. This idea lies at the core for most practical symmetric ciphers of the Data Encryption Standard (DES) and the Advanced Encryption Standard (AES). However, the security guarantees are unclear. It is more desirable to create cipher schemes whose inversion relied on a well-known mathematical problem believed to be difficult to solve.\n\n### 1.7.6 Asymmetric ciphers make a first appearance\n\nAn _asymmetric cipher_ uses two keys $k = (k_\\text{priv}, k_\\text{pub})$, where $k_\\text{pub}$ is a publicly shared key used for encrypting and $k_\\text{priv}$ is kept private for decrypting messages.\n\n$$\ne_{k_\\text{pub}}: \\mathcal M \\to \\mathcal C \\qquad\nd_{k_\\text{priv}}: \\mathcal C \\to \\mathcal M\n$$\n\nWe require the decryption function to be difficult to compute even with knowledge of the public key $k_\\text{pub}$. The encryption function $e_{k_\\text{pub}}$ is referred to as a \"trapdoor\", as computing $d_{k_\\text{priv}}$ is hard without the knowledge of the trapdoor information—the private key $k_\\text{priv}$.\n\nDiffie and Hellman conjectured such a function without knowing its existence.\n\n# 2 Discrete Logarithms and Diffie–Hellman\n\n## 2.1 The birth of public key cryptography\n\n![Mermaid Trap Door](../../../public/data/blog/2023/cryptography/mermaid-trap-door.svg)\n\n<!-- ```mermaid\nflowchart LR\n\nDomain -- f <br> easy to compute --x Range\nRange ~~~ Domain\nRange -- f^-1 <br> hard to compute--x Domain\nRange ~~~ Domain\nRange -- f^-1 (with trapdoor information) <br> easy to compute--x Domain\n``` -->\n\nThe existence of any sound trapdoor function is unproven (this would also solve the $\\mathcal P = \\mathcal {NP}$ problem). The security of most modern crypto systems rest on the assumption that inverting the underlying function is a hard problem.\n\nAlthough Diffie and Hellman did not produce an example of a PKC (public key crypt system), they proposed a method for exchanging a secret key over an insecure channel—now known as the Diffie-Hellman key exchange.\n\n## 2.2 The discrete logarithm problem\n\n> **Definition.** The _Discrete Logarithm Problem_ (DLP) is the task of finding an exponent $x$ such that\n>\n> $$\n> g^x \\equiv h \\pmod p\n> $$\n>\n> The number $x$ is called the _discrete logarithm_ of $h$ to the base $g$ and is denoted by $x \\equiv \\log_g(h)$. The discrete logarithm $\\log_g: \\mathbb F_p^* \\to \\mathbb F_{p-1}^*$ is well defined.\n\n_Remark 2.3._ The discrete logarithm converts multiplication into addition the same way as the continuous logarithm.\n\n$$\n\\log_g(ab) = \\log_g(a) + \\log_g(b) \\qquad \\text{for all } a, b \\in \\mathbb F_p^*\n$$\n\n> **Definition.** Let $G$ be a group under the operator $\\star$. The _Discrete Logarithm Problem_ for $G$ is to, given $g, h \\in G$, find an $x$ satisfying\n>\n> $$\n> \\underbrace{g \\star g \\star \\cdots \\star g}_{x \\text{ times}} = h \\,.\n> $$\n\n## 2.3 Diffie–Hellman key exchange\n\nAlice and Bob can both agree to a shared secret without letting Eve discover its value.\n\n$$\n\\begin{array}{c}\n\\textbf{Public Parameters} \\\\\n\\hline\n\\text{large prime } p \\\\\ng \\in \\mathbb F_p \\text{ of large prime order} \\\\\n% \\hline\n\\end{array}\n$$\n\n$$\n\\begin{array}{lcl}\n\\bf Alice && \\bf Bob \\\\ \\hline\n\\text {Choose secret } a \\in \\mathbb Z &&\n\\text {Choose secret } b \\in \\mathbb Z \\\\\n\\text {Compute } A \\equiv g^a \\pmod p &&\n\\text {Compute } B \\equiv g^b \\pmod p \\\\\n&\\xrightarrow{\\text{Alice sends $A$ to Bob}} & \\\\\n&\\xleftarrow{\\text{Bob sends $B$ to Alice}} \\\\\n\\text {Compute } k \\equiv B^a \\pmod p &&\n\\text {Compute } k \\equiv A^b \\pmod p \\\\\n\\hline\n\\end{array}\n$$\n\nBoth end up with the same key, since\n\n$$\nB^a = (g^b)^a\n    = g^ab\n    = (g^a)^b\n    = A^b \\,.\n$$\n\n> **Definition.** Let $p$ be a prime number and $g$ an integer. The _Diffie–Hellman Problem_ (DHP) is the problem of computing $g^{ab} \\pmod p$ from the known values of $g^a \\pmod p$ and $g^b \\pmod p$.\n\nThe DLP is harder than the DHP, since being able to compute the logarithm would allow for direct computation of the either one of the secrets $a = \\log_g A$ and $b = \\log_g B$. However, knowing a solution to the DHP doesn't immediately present one to the DLP.\n\n## 2.4 The ElGamal public key cryptosystem\n\nThe ElGamal public key encryption algorithm is shown for $\\mathbb F_p^*$, however it can be constructed by the DLP in any group. It requires agreeing on a large prime $p$, such that the DLP in $\\mathbb F_p^*$ is hard, and an element $g \\in \\mathbb F_p$ of large (prime) order.\n\n$$\n\\begin{array}{c}\n\\textbf{Public Parameters} \\\\\n\\hline\n\\text{large prime } p \\\\\ng \\in \\mathbb F_p \\text{ of large prime order} \\\\\n\\end{array}\n$$\n\n$$\n\\begin{array}{lcl}\n\\bf Alice & & \\bf Bob \\\\\n% \\bf Alice &\\textbf{Public Parameters} & \\bf Bob \\\\\n% \\hline\n\\hline\n\\text {Choose } k_\\text{priv} \\in \\mathbb F_p^* && \\\\\n\\text {Compute } A \\equiv g^a \\pmod p && \\\\\n% \\hline\n% & \\textit{Encryption} & \\\\\n% \\hline\n&\\xrightarrow{\\text{Alice sends $A$ to Bob}} & \\\\\n&& \\text {Choose plaintext } m \\\\\n&& \\text {Choose ephemeral key } k \\\\\n&& \\text {Compute } \\\\\n&&\n\\quad\n\\begin{aligned}\nc_1 &= g^k && \\pmod p \\\\\nc_2 &= mA^k && \\pmod p\n\\end{aligned} \\\\\n&\\xleftarrow{\\text{Bob sends $(c_1, c_2)$ to Alice}} \\\\\n\\text {Compute} \\\\\\quad m = c_1^{-a} \\cdot c_2 \\pmod p && \\\\\n\\hline\n\\end{array}\n$$\n\nAlice is able to recover the message $m$, because\n\n$$\n\\begin{aligned}\n&  &&c_1^{-a} \\cdot c_2 \\\\\n&\\equiv &&g^{-ak} \\cdot mA^k \\\\\n&\\equiv &&g^{-ak} \\cdot m \\cdot g^{ak} \\\\\n&\\equiv &&m &\\;.\n\\end{aligned}\n$$\n\n_Remark 2.9._ ElGamal has a 2-to-1 message expansion, as the plaintext $m$ (an integer between $2$ and $p − 1$) is encrypted in two integers $c_1$ and $c_2$ of the same domain.\n\n> **Proposition 2.10.** The ElGamal system rests on the security of the DHP.\n\nImagine we have access to an oracle that could decrypt arbitrary ElGamal ciphertexts. We want to show that this, in turn, would mean being able to solve the DHP (computing $g^{ab}$ when given $g^a$ and $g^b$).\n\nGiven any prime $p$, base $g$ and public key $A$, and ciphertext $(c_1, c_2)$, the oracle will be able to decrypt the message $m$.\n\n$$\nm = c_1^{-a} \\cdot c_2 \\pmod p\n$$\n\nIf this were the case, then we could send the ciphertext $(g^{-b}, 1)$ to the oracle, along with the public parameters $g$ and $a$. This would return $m = (g^b)^{-a} = g^{ab}$ and solve the DHP.\n\n## 2.5 An overview of the theory of groups\n\n> **Definition.** A _group_ is the tuple $(G, \\star)$ of a set $G$ and an operator $\\star : G \\times G \\to G$ satisfying the first three properties.\n\n1. **Identity Existence.**\n   $$\\exists e \\in G:\\quad e \\star a = a \\star e = a \\quad \\forall a \\in G$$\n2. **Inverse Existence.**\n   $$\\forall a \\in G \\quad \\exists a^{-1} \\in G: \\quad a \\star a^{-1} = a^{-1} \\star a = e$$\n3. **Associative Law.**\n   $$(a \\star b) \\star c = a \\star (b \\star c) \\quad \\forall a, b, c \\in G$$\n\nA group that satisfies a fourth property is called a _commutative_ or _abelian_ group.\n\n4. **Commutative Law.**\n   $$a \\star b = b \\star a \\quad \\forall a, b \\in G$$\n\nIf the _order of_ $G$ (number of elements, denoted $|G|$ or $\\#G$) is finite, then $G$ is called a _finite group_.\n\nAn example of a group with infinite order is $(\\mathbb Z, +)$. However $(\\mathbb Z, \\cdot)$ is not a group. The _general linear group_ $GL_n(\\mathbb R) = \\{M \\in \\mathbb R^{n\\times n}: det(M) \\neq 0\\}$ with the matrix multiplication operation is non-abelian.\n\nGiven a group $(G, \\star)$, we can define _exponentiation_ by a positive integer $x$.\n\n$$\ng^x = \\underbrace{g \\star g \\star \\cdots \\star g}_{x \\text{ times}} \\;.\n$$\n\nWhen $x$ is negative, we can define $g^x = (g^{-1})^{|x|}$, and when $x = 0$ we can define $g^x = e$.\n\n> **Definition.** Given a group $(G, \\star)$, the _order of_ $a$ is the smallest integer $d$, such that $a^d = e$. If $d$ does not exist, the order is _infinite_.\n\n> **Proposition 2.13.** Let $G$ be a finite group. Then every element of $G$ has finite order and if $a^k = e$ for some $a \\in G$ with order $d$, then $d \\mid k$.\n\n_Proof._ As in Proposition 1.30.\n\n> **Proposition 2.14** (Lagrange’s Theorem). Let $G$ be a finite group and let $a \\in G$, and $d$ the order of $a$, and $n$ the order of $G$. Then $a^n = e$ and $d \\mid n$. The order of $a$ divides the order of $G$.\n\n_Proof._ As in Theorem 1.25 (Fermat's little theorem).\n\n## 2.6 How hard is the discrete logarithm problem?\n\n> **Definition** (Order Notation). Let $f$ and $g$ be positive functions $\\R \\to \\R$. We say that “f is big-O of g” and write\n>\n> $$\n> f = \\mathcal O(g)\n> $$\n>\n> If there exists $c, C \\in \\R$, such that\n>\n> $$\n> f(x) \\leq c \\cdot g(x) \\quad \\forall x \\geq C\n> $$\n\n> **Proposition 2.15.** If the limit\n>\n> $$\n> \\lim _{x \\to \\infty} \\frac {f(x)} {g(x)}\n> $$\n>\n> exists, then $f = \\mathcal O (g)$.\n\n_Proof._\n\nLet\n$$L := \\lim _{x \\to \\infty} \\frac {f(x)} {g(x)}$$\n\nBy definition, this means that\n\n$$\\forall \\epsilon > 0 \\quad \\exists C_\\epsilon: \\left | L - \\frac {f(x)} {g(x)} \\right| < \\epsilon \\quad \\forall x > C_\\epsilon \\;.$$\n\nIn particular this holds true for $\\epsilon = 1$. It follows that\n\n$$\\frac {f(x)} {g(x)} < L + 1 \\quad \\forall x > C \\;.$$\n\n> **Definition.** A _polynomial time_ problem can be solved in $\\mathcal O(k^A)$ steps for some constant $A$ independent of $k$, given that the input is $\\mathcal O(k)$.\n> The problem is said to be solvable in _linear time_ if $A = 1$, and _quadratic time_ for $A = 2$.\n> A problem is solvable in _exponential time_ in $\\mathcal O(e^{ck})$ steps for some constant $c >0$.\n> If $\\forall \\epsilon > 0$ the problem is solvable in $\\mathcal O_\\epsilon (e^{\\epsilon k)})$ steps, then it is considered solvable _subexponential time_. Here $\\mathcal O _\\epsilon$ means that the constants $c, C$ in the big-$\\mathcal O$ definition are allowed to depend on $\\epsilon$.\n\n_Example 2.18 (DLP)._ The DLP is stated in $G = \\mathbb F _p^*$ as $g^x = h$. The prime $2^k < p < 2^{k+1}$ requires $\\mathcal O(\\log_2 p) = \\mathcal O(k)$-bits.\n\nA naive exhaustive search requires $\\mathcal O (p) = \\mathcal O(2^k)$ steps—_exponential time_. The _Pohlig-Hellman_ algorithm solves the problem easily if $p$ is a product of small primes. The algorithm in Section 2.7 works in $\\mathcal O(\\sqrt p \\log p)$ time (still _exponential_). Index calculus described in Section 3.8 solves it in $\\mathcal O(e^{c\\sqrt {(\\log p)(\\log \\log p)}})$ (_subexponential_).\n\n_Example 2.19._ Consider the DLP in $(\\mathbb F_p, +)$.\n\n$$\nx \\cdot g \\equiv h \\pmod p\n$$\n\nThe extended Euclidean algorithm finds a solution in $\\mathcal O(\\log p)$ steps—_linear time_—by computing $g^{-1}$.\n\nThe DLP showcases different levels of difficulty depending on the chosen group.\n\n## 2.7 A collision algorithm for the DLP\n\n**Proposition 2.20 (Trivial Bound for DLP).** The DLP $g^x = h$ where $g \\in G$ is of order $N$ (i.e. $g^N  = e$) can be solved in $\\mathcal O(N)$ steps.\n\n> **Proposition 2.22 (Shanks’s Babystep–Giantstep Algorithm).** Let $G$ be a group and $g \\in G$ of order $N$. The following algorithm solves the DLP in $\\mathcal O (\\sqrt N \\cdot \\log N)$ steps.\n\n1. Let $n := 1 + \\lfloor \\sqrt N \\rfloor$\n2. Create two lists\n   1. $e, g, g^2, \\ldots, g^n$,\n   2. $h, h \\cdot g^{-n}, h \\cdot g^{-2n}, \\ldots, h \\cdot g^{-n^2}$.\n3. Find a match between the lists: $g^i = hg^{-jn}$.\n4. $x = i + jn$ solves $g^x = h$.\n\n_Proof._ Creating both lists takes approximately $2n$ multiplications. Finding a match takes about $\\log n$ steps. Thus the total time is $\\mathcal O (n \\log n) = \\mathcal O (\\sqrt N \\log N)$.\n\nBoth lists contain a match, as we know that for an unknown solution $x$ to $g^x = h$ with $x = nq + r$,\n\n$$q = \\frac {x - r} n < \\frac N n < n\\;,$$\n\nas $x < N$ and $0 \\leq r < n$.\n\n## 2.8 The Chinese remainder theorem\n\n> **Theorem 2.25 (Chinese Remainder Theorem).** Let $m_1, m_2, \\ldots, m_k$ be pairwise relatively prime integers, i.e.\n>\n> $$\n> \\gcd (m_i, m_j) = 1 \\quad \\forall i \\neq j\n> $$\n>\n> Let $a_1, a_2, \\ldots, a_k$ be arbitrary integers, then the system of simultaneous congruences\n>\n> $$\n> x \\equiv a_1 \\pmod {m_1}, \\quad\n> x \\equiv a_2 \\pmod {m_2}, \\quad\n> \\ldots, \\quad\n> x \\equiv a_k \\pmod {m_k},\n> $$\n>\n> has a solution $x=c$. Further, given two solutions $c$ and $c'$, then\n>\n> $$\n> c \\equiv c' \\pmod {m_1m_2\\cdots m_k} \\,.\n> $$\n\n_Proof._ By induction. Given a solution $x=c_i$ for the first $i$ simultaneous congruences,\n\n$$\nx \\equiv a_1 \\pmod {m_1}, \\quad\nx \\equiv a_2 \\pmod {m_2}, \\quad\n\\ldots, \\quad\nx \\equiv a_k \\pmod {m_i},\n$$\n\nwe can find another solution to the system containing the additional congruence $i+1$ by writing\n\n$$\nx = c_i + m_1 m_2 \\cdots m_i y \\;.\n$$\n\nA solution of this form will always solve the previous $i$ congruences. And $y$ can be chosen such that it solves $x \\equiv a_{i+1} \\pmod {m_{i+1}}$. This is possible given Proposition 1.13(b) and the precondition $\\gcd(m_{i+1}, m_1m_2 · · · m_i) = 1$. This theorem also provides an algorithm for calculating a solution to a system of congruences.\n\n<!--\n$$\nx = k_1m_1 + a_1 \\\\\nx = k_2m_2 + a_2 \\\\\n$$ -->\n\n<!-- TODO: Show uniqueness.\n\n### 2.8.1 Solving congruences with composite moduli -->\n\n<!-- X\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX -->\n","title":"An Introduction to Mathematical Cryptography","date":"Mar 9, 2023","excerpt":"Notes taken from \"An Introduction to Mathematical Cryptography - Hoffstein\"","suptitle":"Jeffrey Hoffstein"}},"__N_SSG":true}