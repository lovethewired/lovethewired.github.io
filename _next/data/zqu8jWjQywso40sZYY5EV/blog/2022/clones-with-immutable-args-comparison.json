{"pageProps":{"postData":{"slug":["blog","2022","clones-with-immutable-args-comparison"],"contentRaw":"\n[Clones with immutable args](https://github.com/wighawag/clones-with-immutable-args) (CWIA) aim to save gas by avoiding storage reads and writes. \n\n\nClones - and proxies alike - usually contain a initializer function to set parameters specific to the clone. This is due to the nature of contracts that function as proxies. Typically they use standardized and optimized implementations that contain minimal logic and forward all calls to an contract that handles the implementation logic. \n\nImmutable variables are useful, because instead of writing these variables into the contract's storage space, they are directly included in the contract's runtime bytecode. They work in a similar way as variables that are declared to be constant, but they are evaluated and inserted during contract creation - in the constructor.\n\nSince solidity does not allow for dynamic type immutable variables, it's not that straightforward to write a clone/proxy contract that will just take in a immutable string of bytes to be easily accessed in the implementation contract.\n\nAnother reason for the slow adoption of clones that use immutable args is that they are often heavily optimized. [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167) formalizes the specs for minimal proxy clones. \n\n```ERC1167Clone.evm\n0x363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3\n```\n\nBecause EIP-1667 clones can easily be identified by checking their bytecode, services such as [etherscan](https://etherscan.io) are able to detect these. \nIf the contract were to include immutable args however, this would require more rules in order to identify such contracts, because the immutable args must be included in the contract's runtime code.\n\n<!-- Clones, much like proxies typically only contain minimal logic and use the `delegatecall` opcode to refer to another contract for the implementation details. Because solidity does not allow for dynamic type immutable variables, it is not possible to pass arbitrary bytes to the clone contract to store these in the contract code versus the contract storage.\nEven if we were to use a specialized clone that is able to set immutable variables in its constructor, this could be problematic. Clones are heavily optimized (and written in bytecode) to contain minimally required bytes in order to reduce gas costs when deploying and when interacting with these contracts.\n\n[EIP-1167](https://eips.ethereum.org/EIPS/eip-1167) formalizes the spec for minimal proxy clones. Because they always have the same bytecode, they can easily be detected as clones by services such as [etherscan](https://etherscan.io). \nImmutable variables are similar to constants, except for that they are evaluated during constructor call and replaced in the contract runtime code.\nThis means that they actually end up in the contract's runtime code. Two contracts initialized with different immutable variables will end up having a different runtime code. \nIt would be possible to \nAnd since there has not been any spec to account for \n\nNormally, if one wants to pass data to when using [EIP-1167 Minimal Proxy Clones](https://eips.ethereum.org/EIPS/eip-1167)clones, a clone will contain an `init()` function which is called upon construction with parameters that end up getting stored in the clone's contract storage.\nwould be required \n\nCWIA work by appending the immutable args -->\n\n\n# Clones with immutable args - via `CALL`\n\nTo illustrate some of the ideas behind clones with immutable args, we \ncan think of a minimal clone contract that takes in an immutable arg as a parameter.\n\n```CloneWithImmutableArgsVer1.sol\ncontract CloneWithImmutableArgsVer1 {\n    address private immutable logic;\n    uint256 public immutable immutableArg0;\n\n    constructor(address logic_, uint256 immutableArg0_) payable {\n        logic = logic_;\n        immutableArg0 = immutableArg0_;\n    }\n\n    fallback() external payable {\n        address logic_ = logic;\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n\n            let success := delegatecall(gas(), logic_, 0, calldatasize(), 0, 0)\n\n            returndatacopy(0, 0, returndatasize())\n\n            if success {\n                return(0, returndatasize())\n            }\n\n            revert(0, returndatasize())\n        }\n    }\n}\n```\n\nThis contract takes in a `address logic_` to which all calls are delegated to and a `uint256 immutableArg0_` that is accessible to the clone as a public function.\n\n<!-- While writing the contracts in solidity makes it easy to follow along and understand the ideas, the resulting bytecode ends up being much bigger compared to the optimized EIP-1167 clones.\n\n```CloneWithImmutableArgsVer1.evm\n0x608060405260043610601c5760003560e01c80634134658c146060575b7f000000000000000000000000ce71065d4017f316ec606fe4422e11eb2c47c2463660008037600080366000845af43d6000803e8015605a573d6000f35b503d6000fd5b348015606b57600080fd5b5060927f000000000000000000000000000000000000000000000000000000000000133781565b60405190815260200160405180910390f3fea164736f6c634300080f000a\n```\n\nClones are often used in clone factories where many hundred or thousand clones are created - such as AMM pools. The logic thus has to be heavily optimized to reduce deployment costs and gas costs when interacting with the contracts.\n\nThe consequences are that \n1) deploying these clones will have a higher cost - due to increased bytecode size\n2) Calling such a clone will have a higher cost - due to the increased bytecode size and due to having 2 function dispatchers now, one in the clone and one in the logic -->\n\nThere is still one problem, however. We usually will want to access `immutableArg0` from within the logic contract. Since the logic contract does not know about `immutableArg0` - let alone the clone contract itself - it is not directly available to the implementation.\nAlthough, since we know that we will be calling the logic contract via `delegatecall`, we can call back into the clone contract via `CloneWithImmutableArgsVer1(address(this)).immutableArg0()` to access the variable.\n\n> Essentially this method will result in an additional `call` operation and a `codecopy` operation once the context is set back to the clone contract. `staticcall` could also be used instead to ensure that no persistent changes are being made.\n\nAnother problem is that the current contract only works for one fixed 32 bytes word. \nIdeally, we would be able to store and access arbitrary byte strings.\nA way to get around this is shown in the next possible method that uses `extcodecopy`.\n\n\n# Clones with immutable args - via `EXTCODECOPY`\n\nInstead of calling back into the clone contract, we could also directly access the bytes via `extcodecopy` while remaining in the context of the implementation contract.\nThis example will work with immutable args that can be bytes of arbitrary lengths.\n\n```ClonesWithImmutableArgsVer2.sol\ncontract CloneBase {\n    fallback() external payable {\n        address logic = ImmutableArgsVer2Lib.getLogicAddress();\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n\n            let success := delegatecall(gas(), logic, 0, calldatasize(), 0, 0)\n\n            returndatacopy(0, 0, returndatasize())\n\n            if success {\n                return(0, returndatasize())\n            }\n\n            revert(0, returndatasize())\n        }\n    }\n}\n\ncontract ClonesWithImmutableArgsVer2 {\n    constructor(address logic, bytes memory immutableArgs) payable {\n        bytes memory code = abi.encodePacked(\n            type(CloneBase).runtimeCode,\n            immutableArgs,\n            uint16(immutableArgs.length),\n            logic\n        );\n\n        assembly {\n            return(add(code, 0x20), mload(code))\n        }\n    }\n}\n```\n\nThe delegatecall logic in the fallback function remains the same, except that we are now reading the address of the logic contract using a library function `ImmutableArgsVer2Lib.getLogicAddress()` - which we'll get into in a bit. \n \nOut goal is to append additional data - the immutable args - to the contract bytecode so that we can cheaply access these later. \n`ClonesWithImmutableArgsVer2` acts as a kind of \"wrapper\" contract that returns the code of the underlying contract - `CloneBase` - with additional data appended - the immutable args, the length of the immutable args and the logic contract. \n\nSince we're accessing `type(CloneBase).runtimeCode` we need to avoid any `immutable` keywords, because these would not be available in the runtime code. That's why we also append the `logic` address to the contract code to be able to access this in the fallback function of the clone.\n\nWe now need to write the functions that will make it possible to retrieve `address logic` and `bytes immutableArgs` from the contract code.\n\n```ImmutableArgsVer2Lib.sol\n library ImmutableArgsVer2Lib {\n    function getLogicAddress() internal returns (address logic) {\n        assembly {\n            // `address logic` is encoded into bytecode at last position.\n            // Load 20 bytes (0x14) starting from end - 20 bytes.\n            let offsetLogic := sub(codesize(), 0x14)\n            // Store in scratch space in first slot at 12 bytes (0x0c = 32 - 20) offset.\n            codecopy(0x0c, offsetLogic, 0x14)\n            // Load first memory slot to retrieve the address.\n            logic := mload(0)\n        }\n    }\n\n    function getImmutableArgs() internal returns (bytes memory args) {\n        assembly {\n            // Clear dirty scratch space.\n            mstore(0, 0)\n\n            let codeSize := extcodesize(address())\n            // The offset for the length of the args is stored\n            // at `codeSize - 20 - 2` (20 bytes address + 2 bytes length)\n            let argsLenOffset := sub(codeSize, 0x16)\n\n            // Load length of immutable args from contract bytecode.\n            extcodecopy(address(), 0x1e, argsLenOffset, 0x02)\n\n            let argsLen := mload(0)\n            let argsOffset := sub(argsLenOffset, argsLen)\n\n            // Place `args` at free memory position.\n            args := mload(0x40)\n            // Store length of `args` bytes-array.\n            mstore(args, argsLen)\n\n            // Copy immutable args to `args` memory offset.\n            extcodecopy(address(), add(args, 0x20), argsOffset, argsLen)\n\n            // Advance the `memPtr` by `argsLen + 0x20`,\n            // rounded up to the next multiple of 32.\n            mstore(0x40, shl(5, shr(5, add(add(args, argsLen), 0x3f))))\n        }\n    }\n}\n```\n\nNotice how `getLogicAddress()` uses `codecopy` and how `getImmutableArgs()` uses `extcodecopy`.\nThis is because `getLogicAddress()` will be executed in the context of the clone - meaning the address is stored in the current runtime code - whereas `getImmutableArgs()` will be executed in the context of the logic contract, which is unable to access the immutable args stored in the runtime code and thus must use `extcodecopy`.\n\n# Clones with immutable args - via `CALLDATA`\n\nThe [original clones with immutable args](https://github.com/wighawag/clones-with-immutable-args) uses another trick. The immutable args are directly appended to the calldata of the delegatecall in the clone's fallback function.\n\n`CloneWithImmutableArgsVer3`'s constructor code remains the same as `CloneWithImmutableArgsVer2`.\n\n```CloneWithImmutableArgsVer3.sol\ncontract CloneWithImmutableArgsVer3 {\n    constructor(address logic, bytes memory immutableArgs) payable {\n        bytes memory code = abi.encodePacked(\n            type(CloneBaseVer3).runtimeCode,\n            immutableArgs,\n            uint16(immutableArgs.length),\n            logic\n        );\n\n        assembly {\n            return(add(code, 0x20), mload(code))\n        }\n    }\n}\n```\n\nNow when we make the delegatecall, we need to concatenate the the following data in memory: calldata + immutable args + uint16 length of immutable args. Retrieving and copying the immutable args works exactly the same as with the previous version, except that, since we're in the clone's context, we can use `codesize` and `codecopy` instead of `extcodesize` and `extcodecopy`.\n\n```CloneWithImmutableArgsVer3.sol\ncontract CloneBaseVer3 {\n    fallback() external payable {\n        address logic = ImmutableArgsVer2Lib.getLogicAddress();\n\n        assembly {\n            // Clear dirty scratch space.\n            mstore(0, 0)\n\n            // Get length and offset of immutable args.\n            let argsLenOffset := sub(codesize(), 0x16)\n            codecopy(0x1e, argsLenOffset, 0x02)\n\n            let argsLen := mload(0)\n            let argsOffset := sub(argsLenOffset, argsLen)\n\n            calldatacopy(0, 0, calldatasize())\n\n            // Copy immutable args to end of calldata in memory.\n            codecopy(calldatasize(), argsOffset, argsLen)\n            // Append the length of the immutable args to the end.\n            mstore8(add(calldatasize(), argsLen), shr(8, argsLen))\n            mstore8(add(add(calldatasize(), argsLen), 1), argsLen)\n\n            let success := delegatecall(gas(), logic, 0, add(add(calldatasize(), argsLen), 2), 0, 0)\n\n            returndatacopy(0, 0, returndatasize())\n\n            if success {\n                return(0, returndatasize())\n            }\n\n            revert(0, returndatasize())        \n        }\n    }\n}\n```\n\nNow the implementation contract will have direct access to the immutable args via calldata. This part is left out, because it works in pretty much the same way as retrieving immutable args from the contract code.\n\nThis method has the benefit that it doesn't need to make another external call or copy external code (since it uses `codecopy` instead). \nAccessing the immutable args via calldata is cheap and almost practically negligible - except for when this is run on rollups that commit calldata to the root chain (here calldata makes up for over 50% of the transaction cost). Yet, unlike before, where we only access the immutable args when needed, these are always appended to any function call - no matter if they are required or not.\n\n\n# Tradeoffs and Gas Comparisons\n\nThe full code for all comparisons can be found here https://github.com/0xPhaze/clones-with-immutable-args-comparison (though method 1 and method 3 are swapped here).\nThe clone implementations are written in pure bytecode to better understand the limits.\nThe methods that use `codecopy` could however, still be further optimized to not use `codecopy` at all, but to loop over `push` opcodes that push the data directly onto the stack and store it in memory.\n\n|  | Relevant Opcodes | Notes |\n|:--:  | :--: | :--: \n| Method 1 | `call` + `codecopy` | Calls back into clone contract to retrieve immutable arg. |\n| Method 2 | `extcodecopy` | Loads external code from clone contract. |\n| Method 3 | `codecopy` + `calldataload` | Adds a gas overhead to EVERY function call |\n\nI ran multiple tests and plotted the results to get a better feel for the behavior of the gas costs. Below is a comparison between method 2 and method 3. Method 1 was left out, as it behaved much like method 2, but slightly worse.\n\n![gas-cost-comparison](/data/blog/2022/clones-with-immutable-args-comparison/gas-cost-comparison.png)\n\nThe plot shows the gas costs for reading x bytes from the immutable args from immutable args with varying lengths. In most cases, using method 3, i.e. reading args from calldata will be cheaper. Using `extcodecopy` (method 2) becomes cheaper after a certain amount of bytes (1.5k-2k).\n\nThe aforementioned gas overhead (for method 3) can be seen for the purple line - reading 0 bytes is the overhead added to any other call that does not need to read immutable bytes. Here, method 2 is cheaper and stays pretty much constant, while it increases linearly with the length of the stored immutable args for method 3 - when the args are appended to the calldata.","title":"Clones With Immutable Args","suptitle":"Gas Comparisons","date":"Oct 23, 2022","excerpt":"Clones with immutable args aim to save gas by avoiding storage reads and writes."}},"__N_SSG":true}