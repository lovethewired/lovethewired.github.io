{"pageProps":{"postData":{"slug":["unpublished","0xSettler"],"contentRaw":"\n- [Intro](#intro)\n- [Overview](#overview)\n- [The sequencer](#the-sequencer)\n- [Before the malicious transaction](#before-the-malicious-transaction)\n\n# Intro\n\nArbitrum is an optimistic rollup on Ethereum. An optimistic rollup is a layer 2 scaling solution where transactions are posted in batches to a base layer—Ethereum. Ignoring the problem of decentralized sequencing—Rollup solutions build on some of Ethereum's safety guarantees through its consensus mechanism, data availability and finality. In an optimistic scenario where every node participant is honest the optimistic rollup protocol requires minimal work and intervention, since every proposed rollup block can simply be accepted as canonical after passing its confirmation delay. However, in the case that a malicious actor is involved, the protocol must be prepared to efficiently determine the correct state all the while protecting itself from DoS attacks and finally punishing bad actors and reward the good. We will inspect this fraud proof mechanism in detail while looking at the source code.\n\nSo what happens exactly when, for example, Eve proposes a block that ends with her balance having increased by 100 Ether coming out of thin air? How does Arbitrum Nitro catch such an act and punish Eve?\n\nIt's clear that any deviation resulting in the processing of transaction outcomes should be caught. Since computing the transaction results happens in [Arbitrum Nitro](https://github.com/OffchainLabs/nitro)—which builds on top of [Go-Ethereum](https://github.com/ethereum/go-ethereum)—another approach is to simply punish any deviation from running the Nitro node client. One problem to address for this approach is that the exact instructions being executed in the compiled binaries will vary depending on the target architectures (x86, ARM, ...). For this reason we need another layer of abstraction that will produce consistent outcomes independent of the machine. This is where WebAssembly (WASM) comes into play.\n\n[rec][./recommendations.md]\n\nI always wanted to write a book with [markdown][mkdnlink].\n\n[mkdnlink]: http://daringfireball.net/projects/markdown\n\n# Overview\n\nGithub repositories:\n\nDeployed to Ethereum:\n\n| Description                                                | Nitro                                                              | Stylus                                                               |\n| ---------------------------------------------------------- | ------------------------------------------------------------------ | -------------------------------------------------------------------- |\n|                                                            | [nitro](https://github.com/OffchainLabs/nitro)                     | [stylus](https://github.com/OffchainLabs/stylus)                     |\n| Core rollup contracts in _Solidity_ deployed to _Ethereum_ | [nitro-contracts](https://github.com/OffchainLabs/nitro-contracts) | [stylus-contracts](https://github.com/OffchainLabs/stylus-contracts) |\n\n- Nitro's core rollup contracts (Solidity)\n- [token-bridge-contracts](https://github.com/OffchainLabs/token-bridge-contracts): ERC20 token bridge contracts (Solidity)\n\nRun by validators:\n\n- (fork of ):\n\n# The sequencer\n\nThe sequencer is the currently centralized entity that determines an order for incoming L2 transactions into L2 blocks. This order is committed to the parent chain (Ethereum) to ensure data availability and finality of the ordering. From here on, the state transition of the rollup is determined deterministically. This means that anyone can process and simulate the sequencer transactions locally to calculate the future state of the rollup without waiting the full 7 day finality period for proposed L2 blocks. This also means that it's not required for Arbitrum nodes to communicate with each other, since the sequencer is the only entity that is able to influence the L2 end state.\n\nQuestions:\n\n- How even include a malicious transaction? The node doesn't provide apis for malicious actions, and invalid transactions will be discarded.\n- What parts of the protocol are involved?\n- How does fraud proving work?\n\n# Before the malicious transaction\n\nIn this section we'll briefly describe the protocol in its optimistic workings—when all transactions are valid.\n\nAlice sends a signed transaction to the sequencer that will end up paying Bob 1 Ether. Currently, there is only a single sequencer controlled by Arbitrum (active work is being put in to change this in the future with systems such as [Espresso Systems](https://twitter.com/sgoldfed/status/1740109895494693334) working on a shared, decentralized sequencer).\n\nTODO: sequencing mechanics in ArbOS and sequence posting + feed.\n\nOnce the sequence is committed with finality and readily available to everyone, the future state of Arbitrum's rollup is known, since it's a deterministic process from here on. Arbitrum validators can create new attestations to the new rollup block state. This is done in\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n","title":"0x Protocol Settler bug","date":"Dec 28, 2023","suptitle":null}},"__N_SSG":true}