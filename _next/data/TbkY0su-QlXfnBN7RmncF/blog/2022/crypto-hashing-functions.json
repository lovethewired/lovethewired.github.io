{"pageProps":{"postData":{"slug":["2022","crypto-hashing-functions"],"contentRaw":"\nSecure hashing functions are pretty cool.\nSome of the properties of [cryptographic hashing functions](https://en.wikipedia.org/wiki/Cryptographic_hash_function) are:\n\n- **deterministic output** (the same input yields the same output)\n- **pre-image resistance** (given $y$, it's infeasible to find an input $x$, s.t. $y = hash(x)$)\n- **second pre-image resistance** (given $x_1$, it's infeasible to find an input $x_2$ , s.t. $hash(x_1) = hash(x_2)$)\n- **collision-resistance** (it's infeasible to find two inputs $x_1$, $x_2$ s.t. $hash(x_1) = hash(x_2)$)\n\nThe deterministic property and the second pre-image resistance is what makes them pretty cool to use for designing smart contracts.\n\n## Building a Marketplace Contract\n\nFor Mad Mouse Circus I built a [Marketplace Contract](https://github.com/0xPhaze/Gachapon/blob/gachapon/src/Marketplace.sol).\nThe idea behind this market place contract was designed to let users purchase off-chain items, such as whitelist entries or merch.\n\nThe main reason for including a smart contract in the whole process is to a) ensure that the correct amount of tokens is burned/transferred and\nb) that we don't end up over-allocating and selling too many items.\nWe can also impose further restrictions such as a valid time-window and a maximum number of purchases per user.\n\nA naive implementation would require an _ownable_ contract and adding market items\nto some kind of list with all their info (presumably defined in a MarketItem struct).\nThis however, requires the owner to make on-chain transactions for every new item to be listed.\nAnd users will have to load an items information from the contract storage when making a purchase to ensure that all requirements are fulfilled.\n\nAnother way of handling things is by letting the user input all of the items information and requirements for us (calldata is cheap) and making use of some of the cryptographic hash function's properties.\nNamely, the **deterministic output** and the **second pre-image resistance**.\n\n```Marketplace.sol\ncontract Marketplace {\n    event PurchaseItem(address indexed user, bytes32 indexed id);\n\n    mapping(bytes32 => uint256) public marketItemSupply;\n    mapping(bytes32 => mapping(address => uint256)) public marketItemPurchases;\n\n    function purchaseMarketItem(\n        uint256 start,\n        uint256 end,\n        uint256 price,\n        uint256 maxPurchases,\n        uint256 maxSupply\n    ) external {\n\n        if (block.timestamp < start || end < block.timestamp) revert NotActive();\n\n        bytes32 hash = keccak256(abi.encode(start, end, price, maxPurchases, maxSupply)); //highlight-line\n\n        if (++marketItemSupply[hash] > maxSupply) revert NoWhitelistRemaining();\n        if (++marketItemPurchases[hash][msg.sender] > maxPurchases) revert MaxPurchasesReached();\n\n        token.burnFrom(msg.sender, price);\n        emit PurchaseItem(msg.sender, hash);\n    }\n}\n```\n\nAll the item's properties (price, supply) are directly input by the user as parameters to the function call.\nNow you may ask yourself whether it is unsafe to require certain conditions that are provided by the user. What stops a user from simply bypassing the frontend and directly modifying any of the function arguments?. Well.. nothing.\n\nNothing will stop them from taking an existing item's information and increasing the supply, for example.\nEach market item is, however, uniquely identified by a `bytes32` hash deterministically generated from all of the function's inputs (assuming unique inputs for every item).\nIf any of the inputs is change, so will the hash identifier and the malicious user ends up purchasing a non-existent item.\nThrough the use of a secure hashing function we are (almost) guaranteed that different inputs will result in different outputs.\n\nThe result of implementing the contract in this way is the owner can simply list a new\nmarket item on their website with the desired properties without having to interact with\nthe smart contract.\n\nOn the frontend we can fetch valuable information to the user,\nsuch as the remaining supply by accessing `marketItemSupply[hash]`\nand how many items the user has purchased through `marketItemPurchases[hash][user]`.\nIf we don't care about limiting the amount of purchases per wallet address we can even get rid of this last variable.\n\nIn order to fetch the list of users who have purchased an item, we can query past events. This would look somewhat like this.\n\n```js\nconst hash = ethers.utils.keccak256(\n  ethers.utils.defaultAbiCoder.encode(\n    [\"uint256\", \"uint256\", \"uint256\", \"uint256\", \"uint256\"],\n    [start, end, price, maxPurchases, maxSupply]\n  )\n);\nconst filter = marketplace.filters.PurchaseItem(null, hash);\nconst blockNumber = await provider.getBlockNumber();\nconst purchases = await marketplace.queryFilter(filter, blockNumber - 5000, blockNumber);\n```\n\n(Providers often have a limit of 5000 blocks, we can however query multiple times in a loop until a desired timestamp or have a backend-server listening to events).\n\nThis same idea can be taken further for handling on-chain items.\n\n## Using permits for on-chain items\n\nTake the [on-chain raffling system](https://github.com/0xPhaze/Gachapon/blob/gachapon/src/Gachapon.sol) for example. Here users are able to win prize NFTs in a raffle if they are one of the lucky winners. The current implementation requires the owner to make an on-chain transaction for every new raffle. And when a user buys a raffle ticket, they provide an id to the raffle they want to participate in. The data is then loaded from the chain and validated.\n\nInstead of making the user pay for costly storage loads (and the owner with storage writes) we could apply the same idea from before.\n\nAlthough, compared to before, we have to take extra care and since we do not want to accept arbitrary user input that could lead to unwanted behavior. For example, they could make up a raffle (with a ticket supply of 1 and a prize NFT that was meant for another raffle), which they could immediately win.\n\nThis case can be guarded against by using permits/signatures. We can simply hash the information just as before, but now also let the user provide a signature that will be validated on-chain to prove that all the information given was indeed authorized by the owner (OpenSea's order book works in a very similar way; listing an item does not cost the owner a transaction).\n\nA simpler application than an orderbook is sometimes seen when validating users for **whitelisted ERC721 mints**.\n\n```MyNFT.sol\ncontract MyNFT is ERC721A, Ownable {\n\n    ...\n\n    address public signerAddress = address(0xb0b);\n\n    function whitelistMint(\n        uint256 amount,\n        uint256 limit,  // highlight-line\n        bytes calldata permit\n    ) external payable {\n        uint256 numMinted = numMinted(msg.sender);\n\n        if (numMinted + amount > limit) revert ExceedsLimit();  // highlight-line\n        if (!validSignature(permit, limit)) revert InvalidSignature();// highlight-line\n        if (msg.value != whitelistPrice * amount) revert IncorrectValue();\n\n        _mint(msg.sender, amount);\n    }\n\n    function validSignature(bytes calldata permit, uint256 limit) private view returns (bool) {\n        bytes32 msgHash = keccak256(abi.encode(address(this), msg.sender, limit));\n        return msgHash.toEthSignedMessageHash().recover(permit) == signerAddress;\n    }\n}\n```\n\nHere as well, the actual `limit` (restricting how many NFTs a certain wallet is able to mint), as well as the permit is being provided by the user. This information (the user and their limit) is hashed, signed and validated on-chain. If the `limit` is tampered with, the hash would change and the recovered signer would become invalid.\n","title":"Cryptographic Hashing Functions","suptitle":"for Gas Savings","date":"12 May 2022","excerpt":"Using secure hashing functions allows you to save on gas by passing information as call data instead of reading it from the chain."}},"__N_SSG":true}