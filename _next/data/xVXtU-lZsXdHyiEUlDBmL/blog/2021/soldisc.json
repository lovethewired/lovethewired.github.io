{"pageProps":{"postData":{"slug":["2021","soldisc"],"contentRaw":"\nSo you want to add a commenting-system to your blog, but you've become tired of legacy Web 2.0 tech?\nAre you sick of having capitalist commenting-services like **DisqusJS** litter your blog with corporate ads?\nWhy not give the money to hard-working miners insted?\nWhy not leverage the benefits of censorship-resistant, decentralized blockchain today?\nIt's permission-less, fast and effectively gates opinions voiced in the comment section.\nAnti-Bot protection? - Just deploy on Eth Mainnet.\n\n# The contract\n\nThe basic functionality we need is for a user to register under a unique user name.\nFor that we'll be looking up the address stored under given a names hash.\nThis is accomplished via the `userNameRegistry` a mapping `bytes32 => address`.\n\nThe `Account` struct stores the name as a string and the date the account was created on.\n\n```SolDisc.sol\n//SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\ncontract SolDisc {\n    struct Account {\n        string name;\n        uint256 creationDate;\n    }\n\n    mapping(address => Account) public accounts;\n    mapping(bytes32 => address) public userNameRegistry;\n\n    function createAccount(string calldata name) external {\n        require(isValidUserName(name, 4, 20), 'INVALID_NAME');\n\n        // enforce unique user-names by storing the hash in a registry\n        bytes32 userNameHash = keccak256(abi.encodePacked(name));\n        address userNameOwner = userNameRegistry[userNameHash];\n\n        require(userNameOwner == address(0));\n        userNameRegistry[userNameHash] = msg.sender;\n\n        // create user profile\n        Account storage account = accounts[msg.sender];\n        account.name = name;\n        account.creationDate = block.timestamp;\n    }\n}\n```\n\n`isValidUserName` is simply a function that checks for invalid characters and makes sure it fits the minimum and maximum length\nrequirements.\n\nWe can now add the functionality to enable commenting on a specific post.\n\n```SolDisc.sol\ncontract SolDisc {\n    struct Account {\n        string name;\n        uint256 creationDate;\n    }\n\n    struct Comment { //add-line\n        address user; //add-line\n        uint256 creationDate; //add-line\n        string text; //add-line\n    } //add-line\n\n    mapping(address => Account) public accounts;\n    mapping(bytes32 => address) public userNameRegistry;\n\n    mapping(bytes32 => Comment) public commentRegistry; // add-line\n    mapping(bytes32 => bytes32[]) commentHashesByPostHash; // add-line\n\n    function createAccount(string calldata name) public {\n        ...\n    }\n\n    function commentOnPost(bytes32 postHash, string calldata text) external requiresAccount { // add-line\n        require(isValidComment(text), 'INVALID_COMMENT'); //add-line\n //add-line\n        uint256 commentId = commentHashesByPostHash[postHash].length; //add-line\n        bytes32 commentHash = keccak256(abi.encode(postHash, commentId)); //add-line\n //add-line\n        // add comment to registry //add-line\n        Comment storage comment = commentRegistry[commentHash]; //add-line\n        comment.user = msg.sender; //add-line\n        comment.creationDate = block.timestamp; //add-line\n        comment.text = text; //add-line\n //add-line\n        // register comment to post //add-line\n        commentHashesByPostHash[postHash].push(commentHash); //add-line\n //add-line\n        // link comment to user account //add-line\n        accounts[msg.sender].commentHashes.push(commentHash); //add-line\n    } // add-line\n // add-line\n    modifier requiresAccount() { // add-line\n        require(accounts[msg.sender].creationDate > 0, 'USER_ACCOUNT_REQUIRED'); // add-line\n        _; // add-line\n    } // add-line\n // add-line\n}\n```\n\nSince comments can be seen as arrays tied to a certain post,\nthe function `commentOnPost` takes in a bytes32 hash `postHash` unique to a post/page\nand the string `text` which is to be added as a comment.\n\nWe could structure the mapping as `bytes32 => Comment[]`, however, as might become clearer later,\nit is practical to have a single unique hash to index each comment (i.e. `bytes32 => Comment`)\nLike before, the Comment is indexed in a mapping `bytes32 => Comment` `commentRegistry`.\n\n`commentHashesByPostHash`, a mapping `bytes32 => bytes32[]` is used to index and register\ncomments (by their hashes) given a post hash.\n\nAnd that's pretty much it to make it work! There are a few extra features that we could add,\nsuch as liking posts and editing them.\n\n## Extra Features\n\nNo commenting-system is complete without being able to like comments.\nThe number of likes a comment receives will be implemented as a `uint256 numLikes` stored in the `Comment` struct.\nFurthermore (in order to make sure a user can only like a comment once), we'll need to keep track of a user's likes.\nThis is done in the mapping `bytes32 => bool likedComments` available in each user's account\nto keep track of which comments they have already liked.\n\nIn order to like (and un-like) a comment, we'll add a function `toggleLikeComment` that takes in\nthe post hash and the comment index/id.\n\n```SolDisc.sol\ncontract SolDisc {\n    struct Account {\n        string name;\n        uint256 creationDate;\n        mapping(bytes32 => bool) likedComments; // add-line\n    }\n\n    struct Comment {\n        address user;\n        uint256 creationDate;\n        uint256 numLikes;   // add-line\n        string text;\n    }\n\n    ...\n\n    function toggleLikeComment(bytes32 postHash, uint256 commentId) external requiresAccount { // add-line\n        bytes32 commentHash = keccak256(abi.encode(postHash, commentId)); // add-line\n        Comment storage comment = commentRegistry[commentHash]; // add-line\n // add-line\n        require(comment.user != msg.sender, 'CANNOT_LIKE_OWN_COMMENT'); // add-line\n // add-line\n        Account storage account = accounts[msg.sender]; // add-line\n        bool like = !account.likedComments[commentHash]; // add-line\n        account.likedComments[commentHash] = like; // add-line\n // add-line\n        if (like) comment.numLikes++; // add-line\n        else comment.numLikes--; // add-line\n    } // add-line\n}\n```\n\nUsing **ethers.js** we can then generate a hash from out page's slug like so:\n\n```js\nconst postHash = ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode(['string'], [pageSlug]));\n```\n\nwhere `pageSlug` is '2021/soldisc' in this case.\n\nIn order to make the whole product more complete, a bunch of helper functions\nthat enable us to more quickly and efficiently fetch the data from the chain are needed.\n\nThe link to the repository can be found on [Gitbhub](https://github.com/willisk/SolDisc/blob/master/contracts/SolDisc.sol).\n\nPlease do try it out and leave a comment!\n","title":"SolDisc.sol","suptitle":"On-Chain Discourse","date":"2021-3-6","excerpt":"DisqusJS? Facebook Comments? You might as well be serving the devil directly. Learn to code your on-chain commenting-system using blockchain!"}},"__N_SSG":true}