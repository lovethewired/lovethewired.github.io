{"pageProps":{"postData":{"slug":["blog","2023","uniswap"],"contentRaw":"\n## Formulas and Derivations\n\n### Liquidity\n\n**Curve Invariant:**\n\n$$\nx \\cdot y = L^2\n$$\n\n**Price:**\n\n$$\nP = \\frac y x\n$$\n\n**Derived Formulas:**\n\nWe can derive formulas for the amounts $x$ and $y$, given the liquidity $L$ and the price $P$ by multiplying or dividing the above formulas.\n\n<details>\n<summary> Derivation\n\n$$\nx = L \\cdot \\frac 1 {\\sqrt P} \\qquad\ny = L \\cdot \\sqrt P\n$$\n\n</summary>\n\n$$\n\\begin{aligned}\n     && x \\cdot y \\cdot \\frac 1 P &= L ^ 2  \\cdot \\frac 1 P \\qquad&\n        x \\cdot y \\cdot P &= L ^ 2  \\cdot P \\\\\n\\iff && x ^2 &= \\frac {L ^ 2} P  \\qquad&\n        y ^2 &= L ^ 2 \\cdot P  \\\\\n\\iff && x &= \\frac {L} {\\sqrt P}  \\qquad&\n        y &= L \\cdot {\\sqrt P}\n\\end{aligned}\n$$\n\n</details>\n\n### Virtual liquidity\n\nIn UniswapV3 we are able to concentrate our liquidity to a limited price range $[p_a, p_b]$. This allows us to adjust the formulas, such that we can work with a deeper, virtual liquidity for a given price band. This corresponds to a shift in the curve formula, since we are adding constants to our real assets to make up our virtual assets.\n\n$$\n(x_\\text {real} + s_x) \\cdot (y_\\text {real} + s_y) =\nx_\\text {virtual} \\cdot y_\\text {virtual}\n= L^2\n$$\n\nThe tradeoff is that once we hit the upper or lower price limit, our liquidity for that range will be depleted and we will have entirely swapped one token for another. Whereas when working with the entire price range, this would never happen.\n\nWhen all of our liquidity is made up of only $Y$ assets for example, the amount of $X$ assets will be zero: $x_\\text {real} = 0$. The price of asset $Y$ per asset $X$ then reaches the upper limit: $P=p_b$.\n\n$$\n\\frac {y_\\text {real} + s_y} {x_\\text {real} + s_x} = P \\;, \\text { with } P \\in [p_a, p_b]\n$$\n\nIn order to find $s_x$, we can insert $x_\\text {real} = 0$ into the curve formula. Note that in this case we also have $P = p_b$.\n\n<details>\n<summary> Derivation\n\n$$\ns_x = \\frac L {\\sqrt {p_b}}\n$$\n\n</summary>\n\n$$\n\\begin{aligned}\n    && (x_\\text {real} + s_x) \\cdot (y_\\text {real} + s_y) &= L ^2 \\\\\n\\iff && s_x \\cdot y_\\text {virtual} &= L ^2 \\\\\n\\iff && s_x \\cdot L \\sqrt {p_b} &= L ^2 \\\\\n\\iff && s_x &= \\frac L {\\sqrt {p_b}} \\\\\n\\end{aligned}\n$$\n\n</details>\n\nSimilarly, we can find $s_y = L {\\sqrt{p_a}}$.\n\n$$\nx_\\text {virtual} = x_\\text {real} + \\frac L {\\sqrt {p_b}} \\qquad\ny_\\text {virtual} = y_\\text {real} + L {\\sqrt {p_a}}\n$$\n\nThe **shifted invariant formula** is\n\n$$\n(x_\\text {real} + \\frac L {\\sqrt {p_b}}) \\cdot (y_\\text {real} + L {\\sqrt{p_a}}) = L^2\n$$\n\nNote how this formula approaches the original curve invariant as we expand the price range: $p_a \\to 0$ and $p_b \\to \\infty$.\n\nWe can derive new formulas by multiplying the new invariant with the price formula, just like before.\n\n**Derived Formulas:**\n\n<details>\n<summary> Derivation\n\n$$\nx_\\text{real} = L \\cdot (\\frac 1 {\\sqrt P} - \\frac 1 {\\sqrt p_b}) \\qquad\ny_\\text{real} = L \\cdot (\\sqrt P - \\sqrt {p_a})\n$$\n\n</summary>\n\n$$\n\\begin{aligned}\n&& x_\\text{virtual} &= L \\cdot \\frac 1 {\\sqrt P} &\ny_\\text{virtual} &= L \\cdot \\sqrt P \\\\\n\\iff\n&& x_\\text{real} + \\frac L {\\sqrt {p_b}} &= L \\cdot \\frac 1 {\\sqrt P} &\ny_\\text{real} + L {\\sqrt{p_a}} &= L \\cdot \\sqrt P \\\\\n\\iff\n&& x_\\text{real} &= L \\cdot (\\frac 1 {\\sqrt P} - \\frac 1 {\\sqrt p_b}) &\ny_\\text{real} &= L \\cdot (\\sqrt P - \\sqrt {p_a})\n\\end{aligned}\n$$\n\n</details>\n\n### Providing Liquidity\n\nWhen providing liquidity, we would like the price to remain constant. We can then easily express the change in tokens per change in liquidity $\\Delta L$, since the formulas are linearly dependent.\n\n$$\n\\Delta x_\\text{real} = \\Delta L \\cdot (\\frac 1 {\\sqrt P} - \\frac 1 {\\sqrt p_b}) \\qquad\n\\Delta y_\\text{real} = \\Delta L \\cdot (\\sqrt P - \\sqrt {p_a}) \\;,\n$$\n\nwhere $P \\in [p_a, p_b]$. We **clamp the price** to the range for which we want to provide liquidity: $[p_a, p_b]$.\n\nNotice that when the _price is below_ our desired price range ($P \\leq p_a$), we are only providing asset $X$, as we will have $\\Delta y_\\text{real} = 0$ and $\\Delta x_\\text{real} = \\Delta L \\cdot (\\frac 1 {\\sqrt {p_a}} - \\frac 1 {\\sqrt p_b})$. One way to think of this is that when the price moves from below into our range, this means that someone is increasing the amount of $Y$ assets and decreasing $X$ assets in the pool ($P = \\frac y x$ is increasing). If the price is to increase any further, then the pool only requires $X$ assets.\nThe change in assets $\\Delta x_\\text{real} = \\Delta L \\cdot (\\frac 1 {\\sqrt {p_a}} - \\frac 1 {\\sqrt p_b})$ correspond to the assets required to cover a price move from the lower range $p_a$ to the upper range $p_b$ that depends on the change in liquidity $\\Delta L$ of the pool.\n\nConversely, when the _price is above_ our range ($P \\geq p_b$), we will only need to provide $Y$ assets to the pool. This is reflected in the formulas, as then $\\Delta x_\\text{real} = 0$ and $\\Delta y_\\text{real} = \\Delta L \\cdot (\\sqrt {p_b} - \\sqrt {p_a})$.\n\n### Swapping\n\nWhen swapping, the price changes according to the curve invariant, while the liquidity remains constant. Instead of expressing the change in one asset through a change in the other, we can express the change in tokens through the change in price. This is more convenient, as Uniswap stores the liquidity and price of assets instead of the absolute amounts.\n\n$$\n\\Delta x = L \\cdot \\Delta \\frac 1 {\\sqrt P} \\qquad\n$$\n\n$$\n\\Delta y = L \\cdot \\Delta {\\sqrt P} \\qquad\n$$\n\n#### Swap $X$ for $Y$\n\nGiven the **exact input $\\Delta x$**, we want to compute the output $\\Delta y$. In order to calculate $\\sqrt{P_\\text{new}}$, we need to transform the equation above.\n\n<details>\n<summary> Derivation\n\n$$\n\\sqrt P_\\text{new} = \\frac  {L\\sqrt P} {\\Delta x \\sqrt P + L}\n$$\n\n</summary>\n\nWe can derive the formula by rearranging the formula above.\n\n$$\n\\begin{aligned}\n     && L \\cdot \\left ( \\frac 1 {\\sqrt P_\\text{new}} - \\frac 1 {\\sqrt P} \\right )&= \\Delta x  \\\\\n\\iff && \\frac 1 {\\sqrt P_\\text{new}} - \\frac 1 {\\sqrt P} &= \\frac {\\Delta x} L \\\\\n\\iff && \\frac 1 {\\sqrt P_\\text{new}} &= \\frac {\\Delta x} L + \\frac 1 {\\sqrt P} \\\\\n\\iff && \\sqrt P_\\text{new} &= \\left( \\frac {\\Delta x \\sqrt P + L} {L\\sqrt P} \\right)^{-1} \\\\\n\\iff && \\sqrt P_\\text{new} &= \\frac  {L\\sqrt P} {\\Delta x \\sqrt P + L}  \\\\\n\\end{aligned}\n$$\n\n</details>\n\nOnce we know the change in price $\\Delta P$, the change in the $X$ asset $\\Delta x$ is easy to compute.\n\n$$\n\\sqrt P_\\text{new} = \\frac  {L\\sqrt P} {\\Delta x \\sqrt P + L} \\qquad\n\\Delta y = L \\cdot (\\sqrt P_\\text{new} - \\sqrt P)\n$$\n\nNote that, if we want to specify the **exact output $\\Delta y$** instead, we need to compute\n\n$$\n\\sqrt P_\\text{new} = \\frac {\\Delta y + L \\cdot \\sqrt P} L \\qquad\n\\Delta x = L \\cdot \\left ( \\frac 1 {\\sqrt P_\\text{new}} - \\frac 1 {\\sqrt P}\\right ) \\;.\n$$\n\n#### Swap $Y$ for $X$\n\nNotice that we have already computed the formulas for a general change in the assets. Meaning that we already have the formulas for the new price $\\sqrt p _\\text{new}$ given the **exact input $\\Delta y$**.\n\nThe same goes for when we want to compute the input $\\Delta y$, given the **exact output $\\Delta x$**.\n\n### Fees\n\n`feeGrowthGlobal` $f_{g}$ tracks the total amount of fees earned per unit of virtual liquidity for each token. These correspond to the fees earned for one unit of liquidity since the initialization of the protocol.\n\n`protocolFees` $f_p$ track the fees earned by the protocol (enabled and collected through governance). We'll ignore these for now.\n\nWhen a swap is performed, the fees are applied to the input and the accumulated fees are increased:\n\n$$\nf_g = y_{in} \\cdot \\gamma\n$$\n\n> NOTE: Shouldn't it be accounted per liquidity?\n\n$$\n\\Delta y = y_{in} \\cdot (1 - \\gamma)\n$$\n\nWhen calculating the fees owed to a liquidity provider's position, the delta in fee growth since the last update is multiplied by the liquidity size of the position. One thing to take into account is that a liquidity provider only earns fees for the range that they are providing liquidity for.\n\n### Ticks\n\nThe valid price ranges can be selected from a discrete set prices, represented by ticks.\n\n$$\np(i) = 1.0001^i\n$$\n\nFor technical reasons, the square root price is tracked.\n\n$$\n\\sqrt {p(i)} = 1.0001^{i / 2}\n$$\n\nGiven a price $P$, we can find the lower tick $i$ through the formula:\n\n$$\ni = \\lfloor \\log _{\\sqrt 1.0001} (\\sqrt P) \\rfloor\n$$\n\nAny provided ticks must be exactly `tickSpacing` apart from each other.\n\n## Code References\n\n### Pools\n\n**Immutable Parameters:**\n\n| Type    | Variable Name         | Notation | Description                                                                                         |\n| ------- | --------------------- | -------- | --------------------------------------------------------------------------------------------------- |\n| int24   | `tickSpacing`         |          | The fixed distance between ticks                                                                    |\n| uint24  | `fee`                 | $\\gamma$ | The liquidity provider fee charged on every swap                                                    |\n| uint128 | `maxLiquidityPerTick` |          | The maximum amount of liquidity that can be stored in a tick $\\frac {2^{128} - 1} {n_\\text{ticks}}$ |\n\n**Global state:**\n\n| Type    | Variable Name          | Notation  | Description                                                                                  |\n| ------- | ---------------------- | --------- | -------------------------------------------------------------------------------------------- |\n| uint128 | `liquidity`            | $L$       | Tracks total liquidity of current/active tick                                                |\n| uint160 | `sqrtPriceX96`         | $\\sqrt P$ | Stores $\\lfloor \\sqrt P \\cdot 2^{96}\\rfloor$                                                 |\n| int24   | `tick`                 | $i_c$     | The current active tick $i_c = \\lfloor \\log _{\\sqrt 1.0001} (\\sqrt P) \\rfloor$               |\n| uint256 | `feeGrowthGlobal0X128` | $f_{g,0}$ | Tracks accumulated fees per liquidity for asset $X$. Grows with $\\gamma \\cdot (1 - \\phi)$    |\n| uint256 | `feeGrowthGlobal1X128` | $f_{g,1}$ |                                                                                              |\n| uint128 | `protocolFees.token0`  | $f_{p,0}$ | Tracks accumulated protocol fees per liquidity for asset $X$. Grows with $\\gamma \\cdot \\phi$ |\n| uint128 | `protocolFees.token1`  | $f_{p,1}$ |                                                                                              |\n\nTBC...\n","title":"UniswapV3","date":"Apr 5, 2023","excerpt":"Notes on UniswapV3"}},"__N_SSG":true}