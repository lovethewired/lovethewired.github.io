<!DOCTYPE html><html><head><meta charSet="utf-8"/><title class="animate__fadeIn">0xPhaze</title><meta name="viewport" content="initial-scale=1.0, width=device-width"/><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/c857aa62c4b06e03.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c857aa62c4b06e03.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-ede13cf31a63337e.js" defer=""></script><script src="/_next/static/chunks/framework-bb5c596eafb42b22.js" defer=""></script><script src="/_next/static/chunks/main-914fbfab4f90b52f.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c052f2bf24b9813f.js" defer=""></script><script src="/_next/static/chunks/pages/index-df31b532dbb93910.js" defer=""></script><script src="/_next/static/KZNrm3_JBZN0PmmBQEnQF/_buildManifest.js" defer=""></script><script src="/_next/static/KZNrm3_JBZN0PmmBQEnQF/_ssgManifest.js" defer=""></script><script src="/_next/static/KZNrm3_JBZN0PmmBQEnQF/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="app px-4 pb-20 min-h-screen flex flex-col items-center w-full max-w-screen"><header class="w-full flex flex-col px-4 sm:px-8 md:px-12 max-w-5xl sm:flex-row justify-between items-center border-white/20 overflow-hidden border-b p-4 h-16"><div class="w-full h-full flex flex-col sm:flex-row justify-start sm:justify-between items-center gap-y-4 overflow-hidden sm:overflow-visible"><div class="flex w-full sm:w-fit items-center"><h1 class="text-xl mx-auto font-display"><a href="/">0xPhaze</a></h1><div class="my-auto -ml-6 w-6 sm:hidden"><div class="text-slate-300 hover:text-secondary-400 transition-colors duration-200 cursor-pointer h-6"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="bars" class="svg-inline--fa fa-bars " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M0 96C0 78.33 14.33 64 32 64H416C433.7 64 448 78.33 448 96C448 113.7 433.7 128 416 128H32C14.33 128 0 113.7 0 96zM0 256C0 238.3 14.33 224 32 224H416C433.7 224 448 238.3 448 256C448 273.7 433.7 288 416 288H32C14.33 288 0 273.7 0 256zM416 448H32C14.33 448 0 433.7 0 416C0 398.3 14.33 384 32 384H416C433.7 384 448 398.3 448 416C448 433.7 433.7 448 416 448z"></path></svg></div></div></div><div class="flex flex-col sm:flex-row gap-x-8 md:gap-x-10 gap-y-4"><div class="flex gap-x-2 sm:gap-x-5 items-center justify-evenly"><a target="_blank" rel="noreferrer" class="link" href="https://github.com/willisk/"><div><div class="text-slate-300 hover:text-secondary-400 transition-colors duration-200 cursor-pointer"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="h-4"><path style="fill:currentColor" d="M12 0C5.374 0 0 5.373 0 12c0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23A11.509 11.509 0 0 1 12 5.803c1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576C20.566 21.797 24 17.3 24 12c0-6.627-5.373-12-12-12z"></path></svg></div></div></a><a target="_blank" rel="noreferrer" class="link" href="https://twitter.com/lovethewired"><div><div class="text-slate-300 hover:text-secondary-400 transition-colors duration-200 cursor-pointer"><svg viewBox="0 0 16 14" fill="none" xmlns="http://www.w3.org/2000/svg" class="h-4"><path style="fill:currentColor" d="M15.584 1.578a7.91 7.91 0 0 1-1.57 1.807v.482c0 .965-.112 1.929-.336 2.772-.224.965-.673 1.808-1.121 2.652a17.373 17.373 0 0 1-1.794 2.29c-.785.723-1.681 1.205-2.578 1.566-1.01.362-2.13.603-3.252.603-1.793 0-3.475-.603-4.932-1.567h.784c1.458 0 2.915-.482 4.036-1.446a2.914 2.914 0 0 1-1.905-.723c-.561-.482-.897-.964-1.122-1.687h.561c.336 0 .56 0 .897-.12C2.579 8.085 1.907 7.603 1.458 7 .785 6.398.561 5.675.561 4.83c.449.242 1.01.362 1.458.483A5.531 5.531 0 0 1 .898 4.109C.673 3.626.449 3.024.449 2.42c0-.602.112-1.205.449-1.687a8.606 8.606 0 0 0 2.914 2.53c1.122.603 2.355.965 3.7 1.086 0-.241-.112-.483-.112-.844 0-.723.224-1.326.56-1.928.337-.603.897-.965 1.458-1.326.56-.241 1.233-.362 1.906-.12.672.12 1.233.481 1.681.964.673-.121 1.458-.362 2.018-.844-.224.844-.784 1.446-1.457 1.928.785-.12 1.457-.24 2.018-.602Z" fill="#081026"></path></svg></div></div></a><div><div class="text-slate-300 hover:text-secondary-400 transition-colors duration-200 cursor-pointer">ABI</div></div></div><button class="rounded px-4 py-2 uppercase text-white select-none  transition-all duration-300 bg-primary-600 hover:bg-primary-700  !outline-none normal-case text-sm w-[140px] w-36">Connect Wallet</button></div></div></header><main class="gap-y-20 mt-8 py-4 sm:px-8 md:px-12 w-full min-h-[500px] max-w-4xl"><ul class="flex flex-col gap-y-8"><li class="sm:text-center"><h2 class="text-lg my-2 hover:underline cursor-pointer">MadMouse.sol</h2><p class="text-slate-500 text-sm">21 Mar 2022</p><p class="mt-2">The development on MadMouse began back in November. Our goal was to include a bunch of features alongside staking without compromising on gas costs.</p><br/></li><li class="sm:text-center"><h2 class="text-lg my-2 hover:underline cursor-pointer">Underhanded Solidity Contest</h2><p class="text-slate-500 text-sm">15 Mar 2022</p><p class="mt-2">The 2022 Underhanded Solidity Contest submissions are coming up.</p><br/></li><li class="sm:text-center"><h2 class="text-lg my-2 hover:underline cursor-pointer">Counter-Attack to the Attack</h2><p class="text-slate-500 text-sm">12 Mar 2022</p><p class="mt-2">My last bug report on an exploit that allowed unlimited minting had me thinking about counter-measures to an attack.</p><br/></li><li class="sm:text-center"><h2 class="text-lg my-2 hover:underline cursor-pointer">Bug Report</h2><p class="text-slate-500 text-sm">12 Mar 2022</p><p class="mt-2">There&#x27;s a bug that seems to occur fairly frequently in the NFT projects venturing into the DeFi-space.</p><br/></li><li class="sm:text-center"><h2 class="text-lg my-2 hover:underline cursor-pointer">ABI Playground</h2><p class="text-slate-500 text-sm">9 Mar 2022</p><p class="mt-2">A tool for quickly interacting with deployed contracts. No ABI needed!</p><br/></li><li class="sm:text-center"><h2 class="text-lg my-2 hover:underline cursor-pointer">SolDisc.sol</h2><p class="text-slate-500 text-sm">6 Mar 2022</p><p class="mt-2">DisqusJS? Facebook Comments? You might as well be serving the devil directly. Learn to code your on-chain commenting-system using blockchain!</p><br/></li></ul></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"allPostsData":[{"slug":"2022/madmouse","contentRaw":"\nWe've come a long way since the development on [MadMouse](https://madmousecircus.io/) started back in November.\n\nInitially, our contract was based on [ERC721A](https://www.erc721a.org/).\nWhile being extremely happy about new form of optimization that is brought to the NFT-space,\nwe immediately had [some improvements to make](https://github.com/chiru-labs/ERC721A/issues/18).\nHowever, it quickly became clear, that because of all its features and special needs,\nthe MadMouse contract would need its own unique implementation.\n\nWhat we especially noticed was how inneficiently most staking contracts were implemented.\nWe definitely did not want to follow suit.\nThe worst thing for us would be if people had to pay\nunnecessarily high gas fees when interacting with our contracts.\nThat's why our top priority has always been to\nkeep the implementation as gas-efficient as possible,\nso not to exclude anyone from taking part in our ecosystem.\n\nTo be able to fit all of our auxilliary information into the contract\nwithout wasting extra storage slots (which ultimately are the main driver\nfor gas costs), we decided to pack all information using bitmaps.\n\nThis means that while our contract has all this extra functionality,\nthe storage costs (and thus all basic operation) remain the same as ERC721A's.\n**In fact, for some operations gas costs are even less.**\n\nStaking in batches, for example, occurs by transferring in batches while minimizing storage reads and writes.\nThere is even the possibility to mint and stake at the same time, drastically reducing costs.\nThe token data in this case is implicitly stored, just like in ERC721A.\n\n## ERC721M comparisons\n\nWhat does all this mean for the end-user?\nLet's have a look at some gas comparisons.\nFor starters, here is a comparison with [Azuki](https://www.azuki.com/garden) (the ones behind ERC721A).\n\n![azuki-comparison](/data/blog/2022/madmouse/azuki.png)\n\nERC721M still holds up to ERC721A. The comparison is based on 5 mints.\nFor all comparisons we use 100 gwei as a baseline and the first token is pre-minted.\n\nOne of ERC721M's special features is that it comes with a **'mint \u0026 stake'** functionality.\nJust recently, [Metroverse](https://metroverse.com/) launched, also with the same ability.\nAlthough their contract isn't based on ERC721A's implicit storage,\ntheir contract is still pretty optimized.\n\n![metroverse-comparison](/data/blog/2022/madmouse/metroverse.png)\n\nAgain, the data is based on a mint quantity of 5. We see that ERC721M extends the idea\nof ERC721A to allow direct staking without any overhead cost.\n**MadMouse's 'mint \u0026 stake' is about 5x cheaper than Metroverse**.\n\nWe tried hard to find a better comparison and to look for any\nimplementation that was based on ERC721A and allowed for staking.\nIn that regard, we found [WabiSabi](https://www.wabisabicollective.io/),\na collection that just launched this month.\n\n![wabisabi-comparison](/data/blog/2022/madmouse/wabisabi.png)\n\nHere, we showed what it would be like, if we didn't use the 'mint \u0026 stake' feature, but\nfirst had minted 5 NFTs and then in-turn staked those.\n\nStaking with ERC721A means that (like with a transfer), implicit token data has to be\nexplicitly set. That's why staking can seem more expensive at first.\nHowever, ERC721M still tries to optimize as much as possible under the hood.\nStaking is done similarly to a batch transfer, where state reads and writes are\nminimized as much as possible.\n**MadMouse is about 4x more efficient than Wabisabi**.\nComparing with the 'mint \u0026 stake' feature, **this turns out to be 8x as cheap**\n(not even taking into account the extra approval transaction).\n\nWabiSabi keeps track of staked token ids in a list (as seen with many other\ncollections as well). Because of this, unstaking gas costs\ncan quickly explode with higher numbers, due to the worst-case complexity being O(N^2).\n\nIf you know of any cheaper staking implementation that we could compare ours against, let us know!\n\n## What's next?\n\nSo, what's next for MadMouse? Does this become a community-standard?\nIn its current form, we had to rely on some heavy engineering work\nin order to fit in all the features while keeping costs cheap.\nMistakes are likely to happen if not handled with care.\n\nThat's why our plan is to release a simpler, lighter build in the near future\nas an ERC721A extension, so that other projects can also make use of\nan efficient staking contract.\n","title":"MadMouse.sol","suptitle":"ERC721A on steroids","date":"21 Mar 2022","excerpt":"The development on MadMouse began back in November. Our goal was to include a bunch of features alongside staking without compromising on gas costs."},{"slug":"2022/underhanded","contentRaw":"\nI just heard about the [2022 Underhanded Solidity Contest](https://underhanded.soliditylang.org/)\nand submissions are due in a day.\n\n## About the Contest\n\nFrom the website: \"The goal of the Underhanded Soldity Contest is to write seemingly innocent and straightforward-looking Solidity code which actually contains malicious behavior or backdoors.\"\n\nI have recently started getting into Solidity CTF challenges and wanted to give it a go.\nDesigning smart-contract challenges sounds like a fun task.\nThere have been times while coding a contract where I had to shudder,\nbecause I realized a terrible mistake in my code.\nI thought some of these could end up being interesting CTF Challenges.\n\nThis years theme for the challenge is about decentralized exchanges. Any kind, orderbook or AMM.\nAnd, \"simplicity is key\" is emphasized.\n\nI came up with two challenges that I [uploaded to Github](https://github.com/willisk/SmartContract-Challenges) if you want to give them a try!\n\nI was first going to go with submitting the bitmap challenge [\"ExclusiveExchange.sol\"](https://github.com/willisk/SmartContract-Challenges/blob/master/contracts/ExclusiveExchange.sol),\nbecause it came across as unique (albeit also a bit of a niche setting).\nAlthough, after stripping away any unnecessary, distracting fluff from the contract,\nthe vulnerability seemed too obvious.\nAnd, especially after hearing that @samczsun from paradigm will be on the board\n(famous for [his pinball machine](https://samczsun.com/hiding-in-plain-sight/) - probably one of the hardest challenges regarding bitmaps),\nI decided to come up with another one.\n\nSo, I wrote the second challenge [\"NFTOrderBook.sol\"](https://github.com/willisk/SmartContract-Challenges/blob/master/contracts/NFTOrderBook.sol).\nThe setup for this one is a bit more realistic and the bug is more common, although a bit simple.\nI still have not seen any other CTF challenge revolve around this vulnerability/error,\nso it could be a good fit.\n\nI might have a small write-up, after I have some people test them out\nand give me feedback.\n","title":"Underhanded Solidity Contest","date":"15 Mar 2022","excerpt":"The 2022 Underhanded Solidity Contest submissions are coming up."},{"slug":"2022/counter-attack","contentRaw":"\nMy [last post](/blog/2022/unexpected-input), which was about an exploit allowing\nunlimited minting of an ERC20 token got me thinking about whether any counter-measures\ncould be implemented if such an exploit were to happen.\n\nBelow is the contract of the MadMouse utility token Gouda, which I'm currently developing.\nIt's a standard ERC20 token combined with OpenZeppelin's AccessControl contract.\n\n```Gouda.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/access/AccessControl.sol';\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\nimport './lib/ERC721MStaking.sol';\n\nerror ExceedsMaxSupply();\n\ncontract Gouda is ERC20, AccessControl, IERC20Reward {\n    bytes32 private constant MINT_AUTHORITY = keccak256('MINT_AUTHORITY');\n    bytes32 private constant BURN_AUTHORITY = keccak256('BURN_AUTHORITY');\n\n    constructor(address madmouse, address treasury) ERC20('Gouda', 'GOUDA') {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n        _setupRole(MINT_AUTHORITY, madmouse);\n        _setupRole(BURN_AUTHORITY, madmouse);\n\n        _mint(treasury, 100_000 * 1e18);\n    }\n\n    // ------------- Restricted -------------\n\n    function mint(address user, uint256 amount) external onlyRole(MINT_AUTHORITY) {\n        _mint(user, amount);\n    }\n\n    function burn(address user, uint256 amount) external onlyRole(BURN_AUTHORITY) {\n        _burn(user, amount);\n    }\n}\n```\n\n# A counter-measure to an attack\n\nIn the case of an attacker being able to exploit the staking contract,\nthey would likely mint a high number of tokens not achievable by normal staking.\n\nWhat if we restrict the mint function to revert in such a case?\n\n```Gouda.sol\ncontract Gouda is ERC20, AccessControl, IERC20Reward {\n\n    ...\n\n    function mint(address user, uint256 amount) external onlyRole(MINT_AUTHORITY) {\n        require(amount \u003e 500_000 * 1e18, 'UNDER_ATTACK');\n        _mint(user, amount);\n    }\n}\n```\n\nThis would be too noticeable for an attacker. They would most likely realise the revert when testing locally\nand if the first attack failed, they could simply launch many more, smaller ones to bypass the limit.\n\nWhat if we instead let the call go through and then revoke the `MINT_AUTHORITY` role of the\nstaking contract? That way, the funds could remain safe until a solution has been found.\n\n```Gouda.sol\ncontract Gouda is ERC20, AccessControl, IERC20Reward {\n\n    ...\n\n    function mint(address user, uint256 amount) external onlyRole(MINT_AUTHORITY) {\n        if (amount \u003c 500_000 * 1e18) _mint(user, amount);\n        else _revokeRole(MINT_AUTHORITY, madmouse); // emergency shutdown\n    }\n}\n```\n\nHm.. so far so good. Although, they would likely run\ntests on a local network first to check whether their attack was successful\nand their token balance increased.\n\n[EIP-1344](https://eips.ethereum.org/EIPS/eip-1344) introduced the ChainID opcode\nwhich can now be accessed through `block.chainid`.\nThis way, we could have our fail-safe code run only when the chain\nis on mainnet (chain id 1).\nWe can also add further checks, since some providers will set `tx.origin = address(0)`\nwhen running 'call' methods (i.e. calls that are not sent to the blockchain to be mined).\n\n```Gouda.sol\ncontract Gouda is ERC20, AccessControl, IERC20Reward {\n\n    ...\n\n    function mint(address user, uint256 amount) external onlyRole(MINT_AUTHORITY) {\n        if (amount \u003c 500_000 * 1e18  // highlight-line\n            || block.chainid != 1  // highlight-line\n            || tx.origin == address(0)) { // highlight-line\n            _mint(user, amount); // highlight-line\n        } // highlight-line\n        else _revokeRole(MINT_AUTHORITY, madmouse);\n    }\n}\n```\n\nOk, getting there..\nNow, if the attacker tests out their exploit locally, they would be able to mint the\ntokens, and if it were to execute on mainnet, the emergency shutdown code would be called.\n\nStill, any quick peak at the contract will directly expose this counter-measure.\nSo, how can we hide it?\n\nHiding it in the ERC20.sol contract directly would seem infeasible, because we are trying\nto access `_revokeRole` from AccessControl to automatically trigger the emergency shutdown.\nERC20's implementation comes with the hooks `_beforeTokenTransfer` and `_afterTokenTransfer`.\nPerhaps these could be used in some form..\n\nI tried modifying '@openzeppelin/contracts/access/AccessControl.sol'\nto inherit from ERC20.sol.\nThat way, AccessControl could be implementing the special hooks.\nThe only problem with this is that we're now inheriting from two contracts that implement an\n`_afterTokenTransfer` and thus are required to override it again in our ERC20 contract.\nThis, in turn would look suspicious again,\nbecause \"wth is AccessControl doing implementing an `_afterTokenTransfer`?\"\n\n```Gouda.sol\ncontract Gouda is ERC20, AccessControl, IERC20Reward {\n\n    ...\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override(ERC20, AccessControl) {\n        super._afterTokenTransfer(from, to, amount);\n    }\n}\n```\n\nWhat if... we kept this piece of code in the ERC20.sol implementation and directly modified storage slots?\nFor that, we would have to figure out what storage slot is being used to grant the staking contract the authority.\n\n```AccessControl.sol\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address =\u003e bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 =\u003e RoleData) private _roles;\n\n    ...\n}\n```\n\nAccessControl's roles are stored in the `mapping(bytes32 =\u003e RoleData) _roles`\nand since we want to modify the `RoleData` for the `MINT_AUTHORITY` role,\nwe should be looking at `_roles[MINT_AUTHORITY]`\nor `_roles[0x2835a7a5b84b6b14021f9bc9694ea8ba57b01e33d0984ae2c6ac566c9cb317dd]`.\nThen, we want to access `members`, specifically `members[madmouse]`.\n\nTo get the final storage slot of `_roles[MINT_AUTHORITY].members[madmouse]`,\nwe will have to compute\n\n```sol\nbytes32 slot_roleData = keccak256(abi.encode(MINT_AUTHORITY, slot_roles));\nbytes32 slot_members = slot_roleData + 0;\nbytes32 slot_data = keccak256(abi.encode(madmouse, slot_members));\n```\n\nWe don't need to add an offset to `slot_roleData` when calculating `slot_members`,\nbecause it is in storage slot 0 in the `RoleData` struct and thus `slot_roleData == slot_members`.\nYou can read more on storage layout [here](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html).\n\nThe only missing part now is `slot_roles`.\nThis slot is dependent on the internal storage slots of the contract.\nWe can use a script to iterate over all stora slots and read out the storage\nto find this slot quickly.\n\n```js\nfor (let slot_roles = 0; slot_roles \u003c 10; slot_roles++) {\n  let slot_members = ethers.utils.keccak256(\n    ethers.utils.defaultAbiCoder.encode(\n      ['bytes32', 'uint'],\n      ['0x2835a7a5b84b6b14021f9bc9694ea8ba57b01e33d0984ae2c6ac566c9cb317dd', slot_roles]\n    )\n  );\n\n  let slot_data = ethers.utils.keccak256(\n    ethers.utils.defaultAbiCoder.encode(['address', 'bytes32'], [nft.address, slot_members])\n  );\n\n  let data = await network.provider.send('eth_getStorageAt', [gouda.address, slot_data, 'latest']);\n\n  console.log(slot_roles, slot_members, slot_data, data);\n}\n```\n\nThe result:\n\n```js\n0 0x15cbcc7ee8b33517d87e628a3ab5fdc484a6b34f5ade2092ebc08dd9cb0ca324 0xf381069cc17fc400a04f9af5041ad36e197e835f2d29ad6a9ef5436dcfc08316 0x0000000000000000000000000000000000000000000000000000000000000000\n1 0x0edbf5ca4965338dd62f75ba1de83eaaaac30e60abb11286d503c3974881165c 0x27fce0b43dd82ae221013e6954fc2adf28c02e3e6e96093620b75f1a6cd70b57 0x0000000000000000000000000000000000000000000000000000000000000000\n2 0xcee27263ce9ad7070e2cdbf5b3f11082a9b1a281ddb83f41a7eefde673a5adca 0x1f1a1876d0dd3e2d2ddbeecb460a9091173ce9f2a40563816e0244b934cf2be0 0x0000000000000000000000000000000000000000000000000000000000000000\n3 0xb32bb3ba356143f7ad5c637479f06883217ad3d5b85f7cf3f8c30152cbb6364a 0x6fc5d456201c9606ecb4c83e0bdea733d5ddc704ee75a0e9684da0e610b1b292 0x0000000000000000000000000000000000000000000000000000000000000000\n4 0xd9191642a20cbd464db6d25f40b03b7fc59b571d399a359b9ac38134c83e856a 0xa7f91fd2efb5a47686a7fd60162f86f05679850a3469c8274b51aee21c94cd6b 0x0000000000000000000000000000000000000000000000000000000000000000\n5 0x4f431056f30038a4630700c6ce70dd8770865fbb61b08a774f29ed79a8e58129 0x1d74f4cfcf55a4866d5f7e8565274daa8a310ebb98a84bdf29b1e6e8631a7380 0x0000000000000000000000000000000000000000000000000000000000001337 // highlight-line\n6 0x8cdef33328e7cad47ce15a7fe2205f3924fe77c37f2fa5061a73a1d1a85ecd96 0x2d7d9aec18f3786f6dd7a826144db7f518eb4d6d5f4121dc714bc5af105b2f35 0x0000000000000000000000000000000000000000000000000000000000000000\n7 0xbc8fbf2aa6164f00cf2f22757f1de06f71959b8b9d75dcf0beef9c7e6b6e00e7 0x6ba2813f222dd1dfbfc978039655edf7bf5e63233313f28c047caf3629b41af6 0x0000000000000000000000000000000000000000000000000000000000000000\n8 0x10f605896b2ef49244aeafc0c06c364831ebe47381f4c06a98bc6e906861c852 0xddd9db65cdfbd0127590dd5a3bc56caf338ca2fc43ca09da72317763b36a327a 0x0000000000000000000000000000000000000000000000000000000000000000\n9 0xc1a5536b2498b1ba1e7da4ff40e87f1b068e232026c46ac078ebf98c7f51f6fa 0x75b2f0ce94d3ebd5d90cdfd41f3a3ddcfaf908a8ef896b7e9516c7bb33c6f9d1 0x0000000000000000000000000000000000000000000000000000000000000000\n```\n\nI had changed the mapping in `RoleData` to `mapping(address =\u003e bytes32) members`\nand set `_roles[MINT_AUTHORITY].members[madmouse] = 0x1337` to make it more obvious.\nNow we know that the storage slot for `_roles` is 5! Although, we can simply\nuse the pre-computed `slot_members`, since that won't change. Note: depending on additional\nvariables in the contract's storage, the storage slot might be located somewhere else.\n\nWe can finally implement our `_afterTokentransfer`:\n\n```@openzeppelin/contracts/token/ERC20/ERC20.sol\n// this part is to be hidden in '@openzeppelin/contracts/token/ERC20/ERC20.sol'\nfunction _afterTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n) internal virtual override {\n    if (from == address(0) \u0026\u0026 amount \u003e 500_000 * 1e18 \u0026\u0026 block.chainid == 1 \u0026\u0026 tx.orign != address(0)) {\n        // 0x4f431056f30038a4630700c6ce70dd8770865fbb61b08a774f29ed79a8e58129\n        // is the storage slot of _roles[MINT_AUTHORITY].members in AccessControl\n        // s is the storage slot of the authorisation flag for msg.sender _roles[MINT_AUTHORITY].members[msg.sender]\n        bytes32 slot = keccak256(\n            abi.encode(msg.sender, 0x4f431056f30038a4630700c6ce70dd8770865fbb61b08a774f29ed79a8e58129)\n        );\n\n        // same as: _roles[MINT_AUTHORITY].members[msg.sender] = 0\n        assembly {\n            sstore(slot, 0)\n        }\n\n        // burn an equivalent amount of tokens to counter the amount of tokens minted\n        _burn(to, amount);\n    }\n}\n```\n\nThankfully, we don't have to think of ways to somehow pass in the staking contract's address\nto ERC20 unnoticed, since we know that the staking contract will be `msg.sender`.\n\nSome final checks make sure that this only gets triggered when minting and not when\ninitialising the contract. Because we can't modify the amount of tokens that the attacker receives\nthrough the hooks, we can simply `_burn` an equivalent amount of tokens in return.\n\n## In summary\n\n- counter-measure is hidden in `@openzeppelin/contracts/token/ERC20/ERC20.sol`\n- if an unrealistic amount of tokens is to be minted, they are immediately burned\n- the staking contract also gets the `MINT_AUTHORITY` role removed\n- the transaction does not revert\n- only activated when running on mainnet\n- funds are safu?\n\nThis trick should be fairly hard to notice and could prove useful in some cases.\n","title":"Counter-Attack to the Attack","suptitle":"aka \"Hackers hate this one weird trick\"","date":"12 Mar 2022","excerpt":"My last bug report on an exploit that allowed unlimited minting had me thinking about counter-measures to an attack."},{"slug":"2022/unexpected-input","contentRaw":"\nThere's a bug that seems to occur fairly frequently in the NFT projects venturing\ninto the DeFi-space.\nMy guess is that this is because there have not been\nfully audited ERC721 and trusted staking contracts,\nlike the Synthetix staking contract.\nI first got to know this bug through Mutant Cats' [FishFarm](https://etherscan.io/address/0xb2f43262fc23d253538ca5f7b4890f89f0ee95d9#code)\nand\nStacked Toadz' [ERC721Farm](https://etherscan.io/address/0x4d1de90bca7a38c556c356c0b802b5102cea032d#code).\n\nMutant Cats were lucky enough to get notified by the community about the vulerability\nand began migrating to a new staking contract in time.\nStacked Toadz [were not so lucky](https://twitter.com/stacked_toadz/status/1448953720348102660)\nwith the hacker making off with 43 ETH from the looted $STACKS.\n\nBecause of a project I'm working on, I wanted to make sure that all of the tokens that will be\nable to interact with our eco-system follow the ERC20 standard\n(and don't resort to a O(N) balanceOf implementation).\nAnd just out of curiosity I went ahead and looked at some of their implementations.\n\nI was able to find the same bug in [UniQuest](https://etherscan.io/address/0x3a6d70e7989ba6e7d5958d7c1eea487082681698/advanced#code), the staking contract for Uninterested Unicorns.\nThe Unicandy UCD-ETH pool maximally allowed for swapping out around 100 ETH.\n\n# The code\n\nThe relevant code to claim ERC20 rewards for Mutant Cats is shown below.\n\n```FishFarm.sol\ncontract FishFarm {\n\n    ...\n\n    function calculateRewards(address account, uint256[] memory tokenIds)\n        public\n        view\n        returns (uint256[] memory rewards)\n    {\n        rewards = new uint256[](tokenIds.length);\n\n        for (uint256 i; i \u003c tokenIds.length; i++) {\n            uint256 tokenId = tokenIds[i];\n\n            rewards[i] =\n                RATE *\n                (_deposits[account].contains(tokenId) ? 1 : 0) *\n                (Math.min(block.number, EXPIRATION) -\n                    depositBlocks[account][tokenId]);\n        }\n    }\n\n    function claimRewards(uint256[] calldata tokenIds) public {\n        uint256 reward;\n        uint256 block = Math.min(block.number, EXPIRATION);\n\n        uint256[] memory rewards = calculateRewards(msg.sender, tokenIds);\n\n        for (uint256 i; i \u003c tokenIds.length; i++) {\n            reward += rewards[i];\n            depositBlocks[msg.sender][tokenIds[i]] = block;\n        }\n\n        if (reward \u003e 0) {\n            try IERC20(FISH).transfer(msg.sender, reward) returns (bool v) {\n            } catch Error(string memory) {}\n        }\n    }\n}\n```\n\nThe `claimHODLRewards` is part of the\n[UniQuest](https://etherscan.io/address/0x3a6d70e7989ba6e7d5958d7c1eea487082681698/advanced#code)\nstaking contract for Uninterested Unicorns NFT.\n\n```UniQuest.sol\ncontract UniQuest {\n\n    ...\n\n    function claimHODLRewards(uint256[] memory tokenIds) public nonReentrant {\n        for (uint256 i = 0; i \u003c tokenIds.length; i++) {\n            require(\n                UU.ownerOf(tokenIds[i]) == msg.sender,\n                \"UniQuest: Not Owner of token\"\n            );\n        }\n\n        uint256 rewards = calculateHODLRewards(tokenIds);\n\n        for (uint256 i = 0; i \u003c tokenIds.length; i++) {\n            HODLLastClaim[tokenIds[i]] = block.timestamp;\n        }\n\n        UCD.mint(msg.sender, rewards);\n    }\n\n\n    function calculateHODLRewards(uint256[] memory tokenIds)\n        public\n        view\n        returns (uint256 HODLRewards)\n    {\n        HODLRewards = 0;\n        for (uint256 i = 0; i \u003c tokenIds.length; i++) {\n            HODLRewards = ...\n        }\n    }\n}\n```\n\n# The bug\n\nThe bug is possible because in both contracts, the rewards calculation is separated from the\nstate-update to the blockchain and because they allow for unchecked user input.\nThe reward is calculated by first looping over the user-inputted token ids.\nAnd only afterwards the claimed timestamp for each token id is set in another loop.\n\nThe problem is that the user is able to input a token id they own\nas many times as they want. There is nothing stopping them\nfrom inputting `claimRewards([3, 3, 3, 3, ...])` for example.\nThis allows the attacker to mint an unlimited amount of tokens from\nthe staking contract.\n\n# The solution\n\nA checks-effects-interactions pattern - well known for guarding\nagainst reentrancy bugs - would have prevented these exploits from being possible.\nInstead of using two-loops, the correct way would be to use one loop\nand to set the timestamp for the last claim directly after checking\nthe rewards for a certain token id.\n\nAlso, in general it makes sense to limit the degree-of-freedom a user has\nwhile interacting with a contract. **Fishfarm** had direct access to `_deposits`\nand **Uninterested Unicorns** is an _ERC721Enumerable_, so both contracts\ncould have implemented a function `claimRewards()` instead that\ndirectly claims the rewards for all token ids, thereby\nlimiting attack vectors through malicious user-input.\n\nAfter getting into contact with the Uninterested Unicorns team, they were able to\nupgrade their proxy contract's implementation - no unicorns hurt.\n","title":"Bug Report","suptitle":"Uninterested Unicorns","date":"12 Mar 2022","excerpt":"There's a bug that seems to occur fairly frequently in the NFT projects venturing into the DeFi-space."},{"slug":"2022/abi-playground","contentRaw":"\n[ABI Playground](/abi-playground)\nis a tool that allows for quick and easy interacting with deployed contracts\nwithout a verified source.\n\nThis is what the interface looks like:\n\n![demo](/data/blog/2022/abi-playground/demo.png)\n\nYou can click on the **?-symbol** next to the title to **fill in the example** for you.\nIt enters in the contract address of TheDAO and a few functions as an example.\n\n![demo](/data/blog/2022/abi-playground/demo2.png)\n\nThe ABI-section allows you to **fetch the ABI from etherscan** if it's available or import common ABIs.\n\n![demo](/data/blog/2022/abi-playground/demo3.png)\n\nYou can either enter a full ABI in JSON format, or **you can simply write function declarations yourself,\nlike in the example**.\n\n![demo](/data/blog/2022/abi-playground/demo4.png)\n\nThe _Functions_ section is generated automatically from the ABI.\nTo send a request, click on the function name.\nThe function's arguments are in between the parentheses along with their variable names if given.\nIf a variable is of type `address`, the \\*-symbol can be used to insert\nyour own address.\n\nOnce the ABI and an address has been entered, **the contract (along with the ethers library) can also be accessed by opening up the\ndeveloper console**.\n\n![demo](/data/blog/2022/abi-playground/demo5.png)\n\nThe variables after the arrow are the returned variables.\nNote that, **only constant (i.e. non-state-modifying/view) functions will return data**.\n\n- _View_ functions are marked \u003cspan class='text-primary-400'\u003eblue\u003c/span\u003e\n- _State-modifying_ functions are marked \u003cspan class='text-orange-300'\u003eorange\u003c/span\u003e\n- _Payable_ functions are in \u003cspan class='text-red-400'\u003ered\u003c/span\u003e\n\nIn order to receive an output from a state-modifying function (orange and red) they need to be called as a static request.\nThis can be achieved by either changing the definition in the ABI, i.e. adding the _view_ declaration.\nOr this can be done in the Low-Level Call section.\nThe Low-Level Call data is automatically updated by modifying function arguments, or by clicking\non the icon to the left of a function.\n\n![demo](/data/blog/2022/abi-playground/demo6.png)\n\nThis section shows the full transaction data that is submitted\nand can be directly modified. **It can therefore also be used for deploying contracts\nby copying the deployment bytecode or it can be used to directly execute raw bytecode**.\nThis can come in handy for some of the [Ethernaut challenges](https://ethernaut.openzeppelin.com/).\n\n![demo](/data/blog/2022/abi-playground/demo7.png)\n\nThe response is decoded if any return values were specified.\nIndividual values can be copied by clicking on the types to the left.\n\n![demo](/data/blog/2022/abi-playground/demo8.png)\n\nThe full response (broken up in 32 bytes chunks) can be inspected in the Low-Level Call section.\nThe raw data can be copied by clicking on 'data' on the top.\n\n[Try it out!](/abi-playground) I'm happy for any feed-back.\n\nSpecial thanks to the team developing the [ethersjs](https://docs.ethers.io/).\nThis is just a fancy interface built on-top of it.\n","title":"ABI Playground","date":"9 Mar 2022","excerpt":"A tool for quickly interacting with deployed contracts. No ABI needed!"},{"slug":"2022/soldisc","contentRaw":"\nSo you want to add a commenting-system to your blog, but you've become tired of legacy Web 2.0 tech?\nAre you sick of having capitalist commenting-services like **DisqusJS** litter your blog with corporate ads?\nWhy not give the money to hard-working miners insted?\nWhy not leverage the benefits of censorship-resistant, decentralized blockchain today?\nIt's permission-less, fast and effectively gates opinions voiced in the comment section.\nAnti-Bot protection? - Just deploy on Eth Mainnet.\n\n# The contract\n\nThe basic functionality we need is for a user to register under a unique user name.\nFor that we'll be looking up the address stored under given a names hash.\nThis is accomplished via the `userNameRegistry` a mapping `bytes32 =\u003e address`.\n\nThe `Account` struct stores the name as a string and the date the account was created on.\n\n```SolDisc.sol\n//SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\ncontract SolDisc {\n    struct Account {\n        string name;\n        uint256 creationDate;\n    }\n\n    mapping(address =\u003e Account) public accounts;\n    mapping(bytes32 =\u003e address) public userNameRegistry;\n\n    function createAccount(string calldata name) external {\n        require(isValidUserName(name, 4, 20), 'INVALID_NAME');\n\n        // enforce unique user-names by storing the hash in a registry\n        bytes32 userNameHash = keccak256(abi.encodePacked(name));\n        address userNameOwner = userNameRegistry[userNameHash];\n\n        require(userNameOwner == address(0));\n        userNameRegistry[userNameHash] = msg.sender;\n\n        // create user profile\n        Account storage account = accounts[msg.sender];\n        account.name = name;\n        account.creationDate = block.timestamp;\n    }\n}\n```\n\n`isValidUserName` is simply a function that checks for invalid characters and makes sure it fits the minimum and maximum length\nrequirements.\n\nWe can now add the functionality to enable commenting on a specific post.\n\n```SolDisc.sol\ncontract SolDisc {\n    struct Account {\n        string name;\n        uint256 creationDate;\n    }\n\n    struct Comment { //add-line\n        address user; //add-line\n        uint256 creationDate; //add-line\n        string text; //add-line\n    } //add-line\n\n    mapping(address =\u003e Account) public accounts;\n    mapping(bytes32 =\u003e address) public userNameRegistry;\n\n    mapping(bytes32 =\u003e Comment) public commentRegistry; // add-line\n    mapping(bytes32 =\u003e bytes32[]) commentHashesByPostHash; // add-line\n\n    function createAccount(string calldata name) public {\n        ...\n    }\n\n    function commentOnPost(bytes32 postHash, string calldata text) external requiresAccount { // add-line\n        require(isValidComment(text), 'INVALID_COMMENT'); //add-line\n //add-line\n        uint256 commentId = commentHashesByPostHash[postHash].length; //add-line\n        bytes32 commentHash = keccak256(abi.encode(postHash, commentId)); //add-line\n //add-line\n        // add comment to registry //add-line\n        Comment storage comment = commentRegistry[commentHash]; //add-line\n        comment.user = msg.sender; //add-line\n        comment.creationDate = block.timestamp; //add-line\n        comment.text = text; //add-line\n //add-line\n        // register comment to post //add-line\n        commentHashesByPostHash[postHash].push(commentHash); //add-line\n //add-line\n        // link comment to user account //add-line\n        accounts[msg.sender].commentHashes.push(commentHash); //add-line\n    } // add-line\n // add-line\n    modifier requiresAccount() { // add-line\n        require(accounts[msg.sender].creationDate \u003e 0, 'USER_ACCOUNT_REQUIRED'); // add-line\n        _; // add-line\n    } // add-line\n // add-line\n}\n```\n\nSince comments can be seen as arrays tied to a certain post,\nthe function `commentOnPost` takes in a bytes32 hash `postHash` unique to a post/page\nand the string `text` which is to be added as a comment.\n\nWe could structure the mapping as `bytes32 =\u003e Comment[]`, however, as might become clearer later,\nit is practical to have a single unique hash to index each comment (i.e. `bytes32 =\u003e Comment`).\nLike before, the Comment is indexed in a mapping `bytes32 =\u003e Comment` `commentRegistry`.\n\n`commentHashesByPostHash`, a mapping `bytes32 =\u003e bytes32[]` is used to index and register\ncomments (by their hashes) given a post hash.\n\nAnd that's pretty much it to make it work! There are a few extra features that we could add,\nsuch as liking posts and editing them.\n\n## Extra Features\n\nNo commenting-system is complete without being able to like comments.\nThe number of likes a comment receives will be implemented as a `uint256 numLikes` stored in the `Comment` struct.\nFurthermore (in order to make sure a user can only like a comment once), we'll need to keep track of a user's likes.\nThis is done in the mapping `bytes32 =\u003e bool likedComments` available in each user's account\nto keep track of which comments they have already liked.\n\nIn order to like (and un-like) a comment, we'll add a function `toggleLikeComment` that takes in\nthe post hash and the comment index/id.\n\n```SolDisc.sol\ncontract SolDisc {\n    struct Account {\n        string name;\n        uint256 creationDate;\n        mapping(bytes32 =\u003e bool) likedComments; // add-line\n    }\n\n    struct Comment {\n        address user;\n        uint256 creationDate;\n        uint256 numLikes;   // add-line\n        string text;\n    }\n\n    ...\n\n    function toggleLikeComment(bytes32 postHash, uint256 commentId) external requiresAccount { // add-line\n        bytes32 commentHash = keccak256(abi.encode(postHash, commentId)); // add-line\n        Comment storage comment = commentRegistry[commentHash]; // add-line\n // add-line\n        require(comment.user != msg.sender, 'CANNOT_LIKE_OWN_COMMENT'); // add-line\n // add-line\n        Account storage account = accounts[msg.sender]; // add-line\n        bool like = !account.likedComments[commentHash]; // add-line\n        account.likedComments[commentHash] = like; // add-line\n // add-line\n        if (like) comment.numLikes++; // add-line\n        else comment.numLikes--; // add-line\n    } // add-line\n}\n```\n\nFinally, on the front-end, we can then generate a hash from a post's using **ethers.js**:\n\n```js\nconst encoded = ethers.utils.defaultAbiCoder.encode(['string'], [pageSlug]);\nconst postHash = ethers.utils.keccak256(encoded);\n```\n\nwhere `pageSlug` is '2021/soldisc' in this case.\n\nIn order to make the whole experience more complete, a bunch of helper functions\nthat enable us to more quickly and efficiently fetch the data from the chain are needed.\nYou can view the final implementation on [Gitbhub](https://github.com/willisk/SolDisc/blob/master/contracts/SolDisc.sol).\n\nPlease do try it out and leave a comment! Next versions will include comments as ERC721s and likes as ERC20s.\n\nEdit: Is it 2022 already?\n","title":"SolDisc.sol","suptitle":"On-Chain Discourse","date":"6 Mar 2022","excerpt":"DisqusJS? Facebook Comments? You might as well be serving the devil directly. Learn to code your on-chain commenting-system using blockchain!"}]},"__N_SSG":true},"page":"/","query":{},"buildId":"KZNrm3_JBZN0PmmBQEnQF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>