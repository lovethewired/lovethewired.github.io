<!DOCTYPE html><html><head><meta charSet="utf-8"/><title class="animate__fadeIn">0xPhaze</title><meta name="viewport" content="initial-scale=1.0, width=device-width"/><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/fcf81e63369216ac.css" as="style"/><link rel="stylesheet" href="/_next/static/css/fcf81e63369216ac.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-ede13cf31a63337e.js" defer=""></script><script src="/_next/static/chunks/framework-bb5c596eafb42b22.js" defer=""></script><script src="/_next/static/chunks/main-914fbfab4f90b52f.js" defer=""></script><script src="/_next/static/chunks/pages/_app-ad82082731d58181.js" defer=""></script><script src="/_next/static/chunks/pages/index-5c221b819b97ede9.js" defer=""></script><script src="/_next/static/Y9bbfKQ8LkQuhxCi5ZJz5/_buildManifest.js" defer=""></script><script src="/_next/static/Y9bbfKQ8LkQuhxCi5ZJz5/_ssgManifest.js" defer=""></script><script src="/_next/static/Y9bbfKQ8LkQuhxCi5ZJz5/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="app px-4 pb-20 min-h-screen flex flex-col items-center w-full max-w-screen"><header class="w-full flex flex-col px-4 sm:px-8 md:px-12 max-w-5xl sm:flex-row justify-between items-center border-white/20 overflow-hidden border-b p-4 h-16"><div class="w-full h-full flex flex-col sm:flex-row justify-start sm:justify-between items-center gap-y-4 overflow-hidden sm:overflow-visible"><div class="flex w-full sm:w-fit items-center"><h1 class="text-xl mx-auto font-display"><a href="/">0xPhaze</a></h1><div class="my-auto -ml-6 w-6 sm:hidden"><div class="text-slate-300 hover:text-secondary-400 transition-colors duration-200 cursor-pointer h-6"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="bars" class="svg-inline--fa fa-bars " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M0 96C0 78.33 14.33 64 32 64H416C433.7 64 448 78.33 448 96C448 113.7 433.7 128 416 128H32C14.33 128 0 113.7 0 96zM0 256C0 238.3 14.33 224 32 224H416C433.7 224 448 238.3 448 256C448 273.7 433.7 288 416 288H32C14.33 288 0 273.7 0 256zM416 448H32C14.33 448 0 433.7 0 416C0 398.3 14.33 384 32 384H416C433.7 384 448 398.3 448 416C448 433.7 433.7 448 416 448z"></path></svg></div></div></div><div class="flex flex-col sm:flex-row gap-x-8 md:gap-x-10 gap-y-4"><div class="flex gap-x-2 sm:gap-x-5 items-center justify-evenly"><a target="_blank" rel="noreferrer" class="link" href="https://github.com/0xPhaze/"><div><div class="text-slate-300 hover:text-secondary-400 transition-colors duration-200 cursor-pointer"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="h-4"><path style="fill:currentColor" d="M12 0C5.374 0 0 5.373 0 12c0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23A11.509 11.509 0 0 1 12 5.803c1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576C20.566 21.797 24 17.3 24 12c0-6.627-5.373-12-12-12z"></path></svg></div></div></a><a target="_blank" rel="noreferrer" class="link" href="https://twitter.com/lovethewired"><div><div class="text-slate-300 hover:text-secondary-400 transition-colors duration-200 cursor-pointer"><svg viewBox="0 0 16 14" fill="none" xmlns="http://www.w3.org/2000/svg" class="h-4"><path style="fill:currentColor" d="M15.584 1.578a7.91 7.91 0 0 1-1.57 1.807v.482c0 .965-.112 1.929-.336 2.772-.224.965-.673 1.808-1.121 2.652a17.373 17.373 0 0 1-1.794 2.29c-.785.723-1.681 1.205-2.578 1.566-1.01.362-2.13.603-3.252.603-1.793 0-3.475-.603-4.932-1.567h.784c1.458 0 2.915-.482 4.036-1.446a2.914 2.914 0 0 1-1.905-.723c-.561-.482-.897-.964-1.122-1.687h.561c.336 0 .56 0 .897-.12C2.579 8.085 1.907 7.603 1.458 7 .785 6.398.561 5.675.561 4.83c.449.242 1.01.362 1.458.483A5.531 5.531 0 0 1 .898 4.109C.673 3.626.449 3.024.449 2.42c0-.602.112-1.205.449-1.687a8.606 8.606 0 0 0 2.914 2.53c1.122.603 2.355.965 3.7 1.086 0-.241-.112-.483-.112-.844 0-.723.224-1.326.56-1.928.337-.603.897-.965 1.458-1.326.56-.241 1.233-.362 1.906-.12.672.12 1.233.481 1.681.964.673-.121 1.458-.362 2.018-.844-.224.844-.784 1.446-1.457 1.928.785-.12 1.457-.24 2.018-.602Z" fill="#081026"></path></svg></div></div></a><div><div class="text-slate-300 hover:text-secondary-400 transition-colors duration-200 cursor-pointer">ABI</div></div><div><div class="text-slate-300 hover:text-secondary-400 transition-colors duration-200 cursor-pointer">ENC</div></div></div><button class="rounded px-4 py-2 uppercase text-white select-none  transition-all duration-300 disabled:pointer-events-none bg-primary-600 hover:bg-primary-700  !outline-none normal-case text-sm w-[140px] w-36">Connect Wallet</button></div></div></header><main class="gap-y-20 mt-8 py-4 sm:px-8 md:px-12 w-full min-h-[500px] max-w-4xl"><ul class="flex flex-col gap-y-8"><li class="sm:text-center"><h2 class="text-lg my-2 hover:underline cursor-pointer">UniswapV3</h2><p class="text-slate-500 text-sm">Apr 5, 2023</p><p class="mt-2">Notes on UniswapV3</p><br/></li><li class="sm:text-center"><h2 class="text-lg my-2 hover:underline cursor-pointer">An Introduction to Mathematical Cryptography</h2><p class="text-slate-500 text-sm">Mar 9, 2023</p><p class="mt-2">Notes taken from &quot;An Introduction to Mathematical Cryptography - Hoffstein&quot;</p><br/></li><li class="sm:text-center"><h2 class="text-lg my-2 hover:underline cursor-pointer">A Guide on Performing Arithmetic Checks in the EVM</h2><p class="text-slate-500 text-sm">Feb 19, 2023</p><p class="mt-2">A post created during my time at Trail of Bits. It features the many ways that arithmetic checks can be performed in the EVM.</p><br/></li><li class="sm:text-center"><h2 class="text-lg my-2 hover:underline cursor-pointer">Clones With Immutable Args</h2><p class="text-slate-500 text-sm">Oct 23, 2022</p><p class="mt-2">Clones with immutable args aim to save gas by avoiding storage reads and writes.</p><br/></li><li class="sm:text-center"><h2 class="text-lg my-2 hover:underline cursor-pointer">ABI-Decoding Calldata</h2><p class="text-slate-500 text-sm">Oct 22, 2022</p><p class="mt-2">Abi-decode directly in calldata without using memory.</p><br/></li><li class="sm:text-center"><h2 class="text-lg my-2 hover:underline cursor-pointer">Haki/Sekira Contract Audit</h2><p class="text-slate-500 text-sm">Jun 21, 2022</p><p class="mt-2"></p><br/></li><li class="sm:text-center"><h2 class="text-lg my-2 hover:underline cursor-pointer">Cryptographic Hashing Functions</h2><p class="text-slate-500 text-sm">May 12, 2022</p><p class="mt-2">Using secure hashing functions allows you to save on gas by passing information as call data instead of reading it from the chain.</p><br/></li><li class="sm:text-center"><h2 class="text-lg my-2 hover:underline cursor-pointer">ERC721M</h2><p class="text-slate-500 text-sm">Mar 21, 2022</p><p class="mt-2">The development on MadMouse began back in November. Our goal was to include a bunch of features alongside staking without compromising on gas costs.</p><br/></li><li class="sm:text-center"><h2 class="text-lg my-2 hover:underline cursor-pointer">Underhanded Solidity Contest</h2><p class="text-slate-500 text-sm">Mar 15, 2022</p><p class="mt-2">The 2022 Underhanded Solidity Contest submissions are coming up.</p><br/></li><li class="sm:text-center"><h2 class="text-lg my-2 hover:underline cursor-pointer">Counter-Attack to the Attack</h2><p class="text-slate-500 text-sm">Mar 12, 2022</p><p class="mt-2">My last bug report on an exploit that allowed unlimited minting had me thinking about counter-measures to an attack.</p><br/></li><li class="sm:text-center"><h2 class="text-lg my-2 hover:underline cursor-pointer">Bug Report</h2><p class="text-slate-500 text-sm">Mar 12, 2022</p><p class="mt-2">There&#x27;s a bug that seems to occur fairly frequently in the NFT projects venturing into the DeFi-space.</p><br/></li><li class="sm:text-center"><h2 class="text-lg my-2 hover:underline cursor-pointer">ABI Playground</h2><p class="text-slate-500 text-sm">Mar 9, 2022</p><p class="mt-2">A tool for quickly interacting with deployed contracts. No ABI needed!</p><br/></li><li class="sm:text-center"><h2 class="text-lg my-2 hover:underline cursor-pointer">SolDisc.sol</h2><p class="text-slate-500 text-sm">Mar 6, 2022</p><p class="mt-2">DisqusJS? Facebook Comments? You might as well be serving the devil directly. Learn to code your on-chain commenting-system using blockchain!</p><br/></li></ul></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"allPostsData":[{"slug":"blog/2023/uniswap","contentRaw":"\n## UniswapV2\n\nThe constant function AMM is defined through its invariant on the reserves. For Uniswap \u0026 co. the constant product formula $x \\cdot y = k$ is used.\n\n**Curve Invariant:**\n\n$$\nx \\cdot y = L^2\n$$\n\nOften liquidity $L$ or, in this case $L^2$ is used in the invariant formula instead. Generally, the liquidity reflects how \"liquid\" the pool is, i.e. how many assets can be swapped and what the price impact is of a trade - a pool with deeper liquidity will have a slower rate of change in price.\n\nConstant product AMMs are said to have \"infinite liquidity\", because the liquidity always remains the same during a swap. This means that it is always possible to swap with the pool, but the pool will return an increasingly smaller amount.\n\nI can't say exactly why $L^2$ instead of simply $L$ is used, buy it does seem to make sense, given that we are multiplying the amounts of two assets. And when providing liquidity, when keeping a constant price, the required tokens are proportional to $L$.\n\n**Price:**\n\n$$\nP = \\frac y x\n$$\n\nThe price $P$ is defined as the ratio between the two reserves. Often, the price of an asset will be denominated in stable units. Given the pair ETH-USD, the $x$ amount (`token0`) would reflect the ETH reserves and the $y$ amount (`token1`) the USD reserves of a pool. The price $P_{\\text{Eth}} = \\frac y x = \\frac {\\text{USD}} {\\text{ETH}}$ is the dollar per Ether rate.\n\n**Derived Formulas:**\n\nFrom these formulas, we can derive the amounts $x$ and $y$, given the liquidity $L$ and the price $P$ by multiplying or dividing the above formulas.\n\n\u003cdetails\u003e\n\u003csummary\u003e Derivation\n\n$$\nx = L \\cdot \\frac 1 {\\sqrt P} \\qquad\ny = L \\cdot \\sqrt P\n$$\n\n\u003c/summary\u003e\n\n$$\n\\begin{aligned}\n     \u0026\u0026 x \\cdot y \\cdot \\frac 1 P \u0026= L ^ 2  \\cdot \\frac 1 P \\qquad\u0026\n        x \\cdot y \\cdot P \u0026= L ^ 2  \\cdot P \\\\\n\\iff \u0026\u0026 x ^2 \u0026= \\frac {L ^ 2} P  \\qquad\u0026\n        y ^2 \u0026= L ^ 2 \\cdot P  \\\\\n\\iff \u0026\u0026 x \u0026= \\frac {L} {\\sqrt P}  \\qquad\u0026\n        y \u0026= L \\cdot {\\sqrt P}\n\\end{aligned}\n$$\n\n\u003c/details\u003e\n\nThe price $P$ can also be discovered directly in the curve. When moving along the curve with constant liquidity (e.g. when performing a swap), the negative of the derivative $\\frac {\\partial y} {\\partial x}$ reflects the price.\n\n\u003cdetails\u003e\n\u003csummary\u003e Derivation\n\n$$P = - \\frac {\\mathrm d y} {\\mathrm d x}$$\n\n\u003c/summary\u003e\n\n$$\ny = \\frac {L^2} x \\qquad\n\\frac {\\mathrm d y} {\\mathrm d x}\n= - \\frac {L^2} {x^2} = -P\n$$\n\nWe made use of the fact that the liquidity $L$ is constant.\n\n\u003c/details\u003e\n\nThis can be thought of the sensitivity of the output of a swap $\\Delta y$ given an infinitesimal amount of input $\\Delta x$. If the price is low for example - this is when we are far right on the curve and the pool almost exclusively is comprised of $X$ assets - the output will not be very sensitive to changes in $x$. Whereas when the price is high and the pool is almost exclusively made up of $Y$ assets, we'll only need a small amount of input $\\Delta x$ for a big change in output $\\Delta y$.\n\n## UniswapV3\n\n![Uniswap Figure 1 - Simulation of virtual liquidity](/data/blog/2023/uniswap/figure-1.png)\n\n### Virtual liquidity\n\nThe innovation in UniswapV3 comes from being able to concentrate our liquidity to a limited price range $[p_a, p_b]$. The original formula $x \\cdot y = L^2$, allows anyone to trade with the pool at any price. By adjusting it, we can artificially inflate the assets, as if we had a deeper liquidity in a given price band. A deeper liquidity means that the rate of change of the price will be slower, but it also means that we are swapping more tokens when the price moves.\n\nThe way this is done is by adding constants to our real assets to make up our virtual assets. This corresponds to a translation/shift in the curve formula.\n\n$$\n(x_\\text {real} + s_x) \\cdot (y_\\text {real} + s_y) =\nx_\\text {virtual} \\cdot y_\\text {virtual}\n= L^2\n$$\n\n![Uniswap Figure 2 - Real reserves](/data/blog/2023/uniswap/figure-2.png)\n\nHere, $x_\\text {virtual}$ and $y_\\text {virtual}$ are the inflated, virtual assets and $x_\\text {real}$ and $y_\\text {real}$ reflect the real assets located in the pool.\n\nThe tradeoff for inflating our assets is that our liquidity is not infinite anymore - once we hit the upper or lower price limit, the liquidity for that range will be depleted and we will have entirely swapped one token for another. When working with the entire price range, there would always be assets left to swap.\n\nWhen all of our liquidity is made up of only $Y$ assets for example, the amount of $X$ assets will be zero $x_\\text {real} = 0$. The price of asset $Y$ per asset $X$ then reaches the upper limit $P=p_b$. Since we're using the inflated assets for our curve, the price is calculated using the virtual reserves $x_\\text {virtual}$ and $y_\\text {virtual}$.\n\n$$\nP = \\frac {y_\\text {virtual}} {x_\\text {virtual}} =\n\\frac {y_\\text {real} + s_y} {x_\\text {real} + s_x} \\;, \\text { where } P \\in [p_a, p_b]\n$$\n\nIn order to find $s_x$, we can insert $x_\\text {real} = 0$ into the curve formula. Note that in this case we also have $P = p_b$.\n\n\u003cdetails\u003e\n\u003csummary\u003e Derivation\n\n$$\ns_x = \\frac L {\\sqrt {p_b}}\n$$\n\n\u003c/summary\u003e\n\n$$\n\\begin{aligned}\n    \u0026\u0026 (x_\\text {real} + s_x) \\cdot (y_\\text {real} + s_y) \u0026= L ^2 \\\\\n\\iff \u0026\u0026 s_x \\cdot y_\\text {virtual} \u0026= L ^2 \\\\\n\\iff \u0026\u0026 s_x \\cdot L \\sqrt {p_b} \u0026= L ^2 \\\\\n\\iff \u0026\u0026 s_x \u0026= \\frac L {\\sqrt {p_b}} \\\\\n\\end{aligned}\n$$\n\n\u003c/details\u003e\n\nSimilarly, we can find $s_y = L {\\sqrt{p_a}}$.\n\n$$\nx_\\text {virtual} = x_\\text {real} + \\frac L {\\sqrt {p_b}} \\qquad\ny_\\text {virtual} = y_\\text {real} + L {\\sqrt {p_a}}\n$$\n\nThe **shifted invariant formula** - the formula used by Uniswap is\n\n$$\n(x_\\text {real} + \\frac L {\\sqrt {p_b}}) \\cdot (y_\\text {real} + L {\\sqrt{p_a}}) = L^2 \\;.\n$$\n\nNote how this formula approaches the original curve invariant $x \\cdot y = L^2$ as we expand the price range: $p_a \\to 0$ and $p_b \\to \\infty$.\n\nLike before, we can derive formulas for $x_{\\text{real}}$ and $y_{\\text{real}}$ given the liquidity $L$ and the price $P$ by multiplying the new invariant with the price formula.\n\n**Derived Formulas:**\n\n\u003cdetails\u003e\n\u003csummary\u003e Derivation\n\n$$\nx_\\text{real} = L \\cdot (\\frac 1 {\\sqrt P} - \\frac 1 {\\sqrt p_b}) \\qquad\ny_\\text{real} = L \\cdot (\\sqrt P - \\sqrt {p_a})\n$$\n\n\u003c/summary\u003e\n\n$$\n\\begin{aligned}\n\u0026\u0026 x_\\text{virtual} \u0026= L \\cdot \\frac 1 {\\sqrt P} \u0026\ny_\\text{virtual} \u0026= L \\cdot \\sqrt P \\\\\n\\iff\n\u0026\u0026 x_\\text{real} + \\frac L {\\sqrt {p_b}} \u0026= L \\cdot \\frac 1 {\\sqrt P} \u0026\ny_\\text{real} + L {\\sqrt{p_a}} \u0026= L \\cdot \\sqrt P \\\\\n\\iff\n\u0026\u0026 x_\\text{real} \u0026= L \\cdot (\\frac 1 {\\sqrt P} - \\frac 1 {\\sqrt p_b}) \u0026\ny_\\text{real} \u0026= L \\cdot (\\sqrt P - \\sqrt {p_a})\n\\end{aligned}\n$$\n\n\u003c/details\u003e\n\n### Providing Liquidity\n\nWhen providing liquidity, one condition we might want is for the price to remain constant. We can then easily express the change in tokens per change in liquidity $\\Delta L$, since the formulas are linearly dependent. A change in liquidity is proportional to a change in either $X$ or $Y$ assets and vice versa.\n\n\u003cdetails\u003e\n\u003csummary\u003e Derivation\n\n$$\n\\Delta x_\\text{real} = \\Delta L \\cdot (\\frac 1 {\\sqrt P} - \\frac 1 {\\sqrt p_b}) \\qquad\n\\Delta y_\\text{real} = \\Delta L \\cdot (\\sqrt P - \\sqrt {p_a}) \\;,\n$$\n\n\u003c/summary\u003e\n\n$$\n\\begin{aligned}\n\\Delta x_\\text{real} \u0026=\nx_\\text{real}^{(2)} - x_\\text{real}^{(1)} \\\\\n\u0026=\nL^{(2)} \\cdot (\\frac 1 {\\sqrt P} - \\frac 1 {\\sqrt p_b}) -\nL^{(1)} \\cdot (\\frac 1 {\\sqrt P} - \\frac 1 {\\sqrt p_b}) \\\\\n\u0026= (L^{(2)} - L^{(1)}) \\cdot (\\frac 1 {\\sqrt P} - \\frac 1 {\\sqrt p_b}) \\\\\n\u0026= \\Delta L \\cdot (\\frac 1 {\\sqrt P} - \\frac 1 {\\sqrt p_b})\n\\end{aligned}\n$$\n\n\u003c/details\u003e\n\nwhere $P \\in [p_a, p_b]$. We must **clamp the price** in the formula to the price range $[p_a, p_b]$ for which we want to provide liquidity, because as mentioned earlier, after we leave the range, the liquidity is depleted and we don't have any tokens left to swap in the same direction anymore.\n\nNotice that when we want to supply liquidity to the pool and the _current price is below_ our desired price range ($P \\leq p_a$), we are only required to provide $X$ assets. The formula then reads $\\Delta y_\\text{real} = 0$ and $\\Delta x_\\text{real} = \\Delta L \\cdot (\\frac 1 {\\sqrt {p_a}} - \\frac 1 {\\sqrt p_b})$. If we imagine someone swapping with the pool and moving the price from below into our range, then the amount of $Y$ assets is increasing (we see this from $P = \\frac y x$) and the amount of $X$ assets are decreasing in the pool. If the price is to increase any further in the same direction, the pool only needs $X$ assets.\n\nStill reflecting on the case when the $P \\leq p_a$, the change in assets $\\Delta x_\\text{real} = \\Delta L \\cdot (\\frac 1 {\\sqrt {p_a}} - \\frac 1 {\\sqrt p_b})$ reflects the assets required to cover a full price move from the lower range $p_a$ to the upper range $p_b$ with a change in liquidity $\\Delta L$ of the pool.\n\nConversely, when the _price is above_ our range ($P \\geq p_b$), we will only need to provide $Y$ assets to the pool. The formula then reads $\\Delta x_\\text{real} = 0$ and $\\Delta y_\\text{real} = \\Delta L \\cdot (\\sqrt {p_b} - \\sqrt {p_a})$.\n\n### Swapping\n\nWhen swapping, the price changes according to the curve invariant, while we would like the (virtual) liquidity to remain constant. Instead of expressing the change in one asset through a change in the other, we can express the change in assets through the change in price instead. This is more convenient, as Uniswap stores the liquidity and price (or square root price) of assets instead of the absolute amounts.\n\n$$\n\\Delta x = L \\cdot \\Delta \\frac 1 {\\sqrt P} \\qquad\n$$\n\n$$\n\\Delta y = L \\cdot \\Delta {\\sqrt P} \\qquad\n$$\n\n#### Swap $X$ for $Y$\n\nGiven the **exact input $\\Delta x$**, we want to compute the output $\\Delta y$. In order to calculate $\\sqrt{P_\\text{new}}$, we need to transform the above equation.\n\n\u003cdetails\u003e\n\u003csummary\u003e Derivation\n\n$$\n\\sqrt P_\\text{new} = \\frac  {L\\sqrt P} {\\Delta x \\sqrt P + L}\n$$\n\n\u003c/summary\u003e\n\nWe can derive the formula by rearranging the formula above.\n\n$$\n\\begin{aligned}\n     \u0026\u0026 L \\cdot \\left ( \\frac 1 {\\sqrt P_\\text{new}} - \\frac 1 {\\sqrt P} \\right )\u0026= \\Delta x  \\\\\n\\iff \u0026\u0026 \\frac 1 {\\sqrt P_\\text{new}} - \\frac 1 {\\sqrt P} \u0026= \\frac {\\Delta x} L \\\\\n\\iff \u0026\u0026 \\frac 1 {\\sqrt P_\\text{new}} \u0026= \\frac {\\Delta x} L + \\frac 1 {\\sqrt P} \\\\\n\\iff \u0026\u0026 \\sqrt P_\\text{new} \u0026= \\left( \\frac {\\Delta x \\sqrt P + L} {L\\sqrt P} \\right)^{-1} \\\\\n\\iff \u0026\u0026 \\sqrt P_\\text{new} \u0026= \\frac  {L\\sqrt P} {\\Delta x \\sqrt P + L}  \\\\\n\\end{aligned}\n$$\n\n\u003c/details\u003e\n\nOnce we know the change in price $\\Delta P$, the change in the $X$ asset $\\Delta x$ is easy to compute.\n\n$$\n\\sqrt P_\\text{new} = \\frac  {L\\sqrt P} {\\Delta x \\sqrt P + L} \\qquad\n\\Delta y = L \\cdot (\\sqrt P_\\text{new} - \\sqrt P)\n$$\n\nNote that, if we want to specify the **exact output $\\Delta y$** instead, we need to compute\n\n$$\n\\sqrt P_\\text{new} = \\frac {\\Delta y + L \\cdot \\sqrt P} L \\qquad\n\\Delta x = L \\cdot \\left ( \\frac 1 {\\sqrt P_\\text{new}} - \\frac 1 {\\sqrt P}\\right ) \\;.\n$$\n\n#### Swap $Y$ for $X$\n\nWe have already computed the formulas for a general change in the assets (the $\\Delta$ can be positive or negative). Meaning that, in order to compute the new price $\\sqrt p _\\text{new}$ given the **exact input $\\Delta y$** we can just proceed with the formula above.\n\nThe same goes for when we want to compute the input $\\Delta y$, given the **exact output $\\Delta x$**.\n\n### Fees\n\n`feeGrowthGlobal` $f_{g}$ tracks the total amount of fees earned per unit of virtual liquidity for each token. These correspond to the fees earned for one unit of liquidity since the initialization of the protocol.\n\n`protocolFees` $f_p$ track the fees earned by the protocol (enabled and collected through governance). We'll ignore these for now.\n\nWhen a swap is performed, the fees are applied to the input and the accumulated fees are increased:\n\n$$\nf_g = y_{in} \\cdot \\gamma\n$$\n\n\u003e NOTE: Shouldn't it be accounted per liquidity?\n\n$$\n\\Delta y = y_{in} \\cdot (1 - \\gamma)\n$$\n\nWhen calculating the fees owed to a liquidity provider's position, the delta in fee growth since the last update is multiplied by the liquidity size of the position. One thing to take into account is that a liquidity provider only earns fees for the range that they are providing liquidity for.\n\n### Ticks\n\nThe valid price ranges can be selected from a discrete set prices, represented by ticks.\n\n$$\np(i) = 1.0001^i\n$$\n\nFor technical reasons, the square root price is tracked.\n\n$$\n\\sqrt {p(i)} = 1.0001^{i / 2}\n$$\n\nGiven a price $P$, we can find the lower tick $i$ through the formula:\n\n$$\ni = \\lfloor \\log _{\\sqrt 1.0001} (\\sqrt P) \\rfloor\n$$\n\nAny provided ticks must be exactly `tickSpacing` apart from each other.\n\n## Code References\n\n### Pools\n\n**Immutable Parameters:**\n\n| Type    | Variable Name         | Notation | Description                                                                                         |\n| ------- | --------------------- | -------- | --------------------------------------------------------------------------------------------------- |\n| int24   | `tickSpacing`         |          | The fixed distance between ticks                                                                    |\n| uint24  | `fee`                 | $\\gamma$ | The liquidity provider fee charged on every swap                                                    |\n| uint128 | `maxLiquidityPerTick` |          | The maximum amount of liquidity that can be stored in a tick $\\frac {2^{128} - 1} {n_\\text{ticks}}$ |\n\n**Global state:**\n\n| Type    | Variable Name          | Notation  | Description                                                                                  |\n| ------- | ---------------------- | --------- | -------------------------------------------------------------------------------------------- |\n| uint128 | `liquidity`            | $L$       | Tracks total liquidity of current/active tick                                                |\n| uint160 | `sqrtPriceX96`         | $\\sqrt P$ | Stores $\\lfloor \\sqrt P \\cdot 2^{96}\\rfloor$                                                 |\n| int24   | `tick`                 | $i_c$     | The current active tick $i_c = \\lfloor \\log _{\\sqrt 1.0001} (\\sqrt P) \\rfloor$               |\n| uint256 | `feeGrowthGlobal0X128` | $f_{g,0}$ | Tracks accumulated fees per liquidity for asset $X$. Grows with $\\gamma \\cdot (1 - \\phi)$    |\n| uint256 | `feeGrowthGlobal1X128` | $f_{g,1}$ |                                                                                              |\n| uint128 | `protocolFees.token0`  | $f_{p,0}$ | Tracks accumulated protocol fees per liquidity for asset $X$. Grows with $\\gamma \\cdot \\phi$ |\n| uint128 | `protocolFees.token1`  | $f_{p,1}$ |                                                                                              |\n\n### Tick Information\n\n#### Conversion\n\n\u003c!-- gh-embed:Uniswap:v3-core:d8b1c635c275d2a9450bd6a78f3fa2484fef73eb:contracts/libraries/TickMath.sol:18:23 --\u003e\n\n**[TickMath.sol](https://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/contracts/libraries/TickMath.sol#L18-L23)**\n\n```sol\n/// @notice Calculates sqrt(1.0001^tick) * 2^96\n/// @dev Throws if |tick| \u003e max tick\n/// @param tick The input tick for the above formula\n/// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n/// at the given tick\nfunction getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n```\n\n\u003c!-- gh-embed:Uniswap:v3-core:d8b1c635c275d2a9450bd6a78f3fa2484fef73eb:contracts/libraries/TickMath.sol:56:61 --\u003e\n\n**[TickMath.sol](https://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/contracts/libraries/TickMath.sol#L56-L61)**\n\n```sol\n/// @notice Calculates the greatest tick value such that getRatioAtTick(tick) \u003c= ratio\n/// @dev Throws in case sqrtPriceX96 \u003c MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n/// ever return.\n/// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n/// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\nfunction getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n```\n\n#### State\n\nThe tick information is stored in mappings in a pool.\n\n\u003c!-- gh-embed:Uniswap:v3-core:d8b1c635c275d2a9450bd6a78f3fa2484fef73eb:contracts/UniswapV3Pool.sol:92:95 --\u003e\n\n**[UniswapV3Pool.sol](https://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/contracts/UniswapV3Pool.sol#L92-L95)**\n\n```sol\n/// @inheritdoc IUniswapV3PoolState\nmapping(int24 =\u003e Tick.Info) public override ticks;\n/// @inheritdoc IUniswapV3PoolState\nmapping(int16 =\u003e uint256) public override tickBitmap;\n```\n\n`tickBitMap` simply keeps track of whether a particular tick has been initialized.\n`ticks` stores all the information related to a ticks liquidity and fees.\n\n\u003c!-- gh-embed:Uniswap:v3-core:d8b1c635c275d2a9450bd6a78f3fa2484fef73eb:contracts/libraries/Tick.sol:16:37 --\u003e\n\n**[Tick.sol](https://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/contracts/libraries/Tick.sol#L16-L37)**\n\n```sol\n// info stored for each initialized individual tick\nstruct Info {\n    // the total position liquidity that references this tick\n    uint128 liquidityGross;\n    // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),\n    int128 liquidityNet;\n    // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n    // only has relative meaning, not absolute — the value depends on when the tick is initialized\n    uint256 feeGrowthOutside0X128;\n    uint256 feeGrowthOutside1X128;\n    // the cumulative tick value on the other side of the tick\n    int56 tickCumulativeOutside;\n    // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n    // only has relative meaning, not absolute — the value depends on when the tick is initialized\n    uint160 secondsPerLiquidityOutsideX128;\n    // the seconds spent on the other side of the tick (relative to the current tick)\n    // only has relative meaning, not absolute — the value depends on when the tick is initialized\n    uint32 secondsOutside;\n    // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0\n    // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks\n    bool initialized;\n}\n```\n\n## Flows\n\n### Providing Liquidity\n\n\u003c!-- gh-embed:Uniswap:v3-core:d8b1c635c275d2a9450bd6a78f3fa2484fef73eb:contracts/UniswapV3Pool.sol:457:463 --\u003e\n\n**[UniswapV3Pool.sol](https://github.com/Uniswap/v3-core/blob/d8b1c635c275d2a9450bd6a78f3fa2484fef73eb/contracts/UniswapV3Pool.sol#L457-L463)**\n\n```sol\nfunction mint(\n    address recipient,\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 amount,\n    bytes calldata data\n) external override lock returns (uint256 amount0, uint256 amount1) {\n```\n\n**requires**\n\n- `amount != 0`\n- `TickMath.MIN_TICK \u003c= tickLower \u003c tickUpper \u003c= TickMath.MAX_TICK`\n- `tickUpper - tickLower % tickSpacing == 0`\n- `liquidityGrossAfter \u003c= maxLiquidity`\n\n**steps**\n\n- updates position `[tickLower, tickUpper]` of `recipient` by `liquidityDelta`\n  - update {lower,upper} tick info\n    - STORE initial tick params\n      - from current global state params if {lower,upper} tick \u003c current tick\n        -       info.feeGrowthOutside0X128 = feeGrowthGlobal0X128;\n                info.feeGrowthOutside1X128 = feeGrowthGlobal1X128;\n                info.secondsPerLiquidityOutsideX128 = secondsPerLiquidityCumulativeX128;\n                info.tickCumulativeOutside = tickCumulative;\n                info.secondsOutside = time;\n      - else default (0)\n    - STORE `tick.liquidityGross += liquidityDelta`\n    - STORE `tick.liquidityNet += liquidityDelta` if lower tick\n    - STORE `tick.liquidityNet -= liquidityDelta` if upper tick\n  - STORE activated state for {lower,upper} tick in `tickBitmap` depending on change in `liquidityGross`\n  - compute `feeGrowthInside0X128`, `feeGrowthInside1X128`\n  - update recipient position\n    - sd\n- calculate `amount0` and `amount1` required from `recipient`\n  - if `currentTick \u003c tickLower`, then `amount0 = amount`\n\n**Questions**\n\n- is `tick.liquidityNet = +/- tick.liquidityGross`? Why is it being tracked separately\n","title":"UniswapV3","date":"Apr 5, 2023","excerpt":"Notes on UniswapV3"},{"slug":"blog/2023/cryptography","contentRaw":"\n_Notes taken from [An Introduction to Mathematical Cryptography](https://link.springer.com/book/10.1007/978-0-387-77993-5). Updated as I continue._\n\n# Table of Contents\n\n# 1. An Introduction to Cryptography\n\n## 1.2 Divisibility and greatest common divisors\n\n\u003e **Definition.** Let $a, b \\in \\mathbb Z$ and $a \\neq 0$.\n\u003e Then $a \\mid b$ (\"$a$ divides $b$\"), if there exists $q \\in \\mathbb Z$ s.t.\n\u003e\n\u003e $$\n\u003e q \\cdot a = b\n\u003e $$\n\n\u003e **Proposition 1.4** Let $a, b, c \\in \\mathbb Z$\n\u003e\n\u003e - If $a \\mid b$ and $b \\mid c$ $\\implies$ $a \\mid c$\n\u003e - If $a \\mid b$ and $b \\mid a$ $\\implies$ $a = \\pm b$\n\u003e - If $a \\mid b$ and $a \\mid c$ $\\implies$ $a \\mid (a + c)$ and $a \\mid (b - c)$\n\n\u003e **Definition.** The _greatest common divisor_ of $a$ and $b$ is the largest positive integer $d$ such that $d \\mid a$ and $d \\mid b$.\n\n\u003e **Definition.** (Euclidean Algoritm) Let $a, b \\in \\mathbb Z$. Then $a$ divided by $b$ has quotient $q$ and remainder $r$.\n\u003e\n\u003e $$\n\u003e a = bq + r \\quad \\text{with } 0 \\leq r \\lt b\n\u003e $$\n\u003e\n\u003e From this formula and proposition 1.4 we get\n\u003e\n\u003e $$\n\u003e \\gcd(a, b) = \\gcd(b, r)\n\u003e $$\n\u003e\n\u003e Continuing this process with $\\gcd(b, r) = \\gcd(r', r)$ we eventually arrive at $\\gcd(s, 0) = s$ where $s = \\gcd(a, b)$.\n\n\u003e **Theorem 1.11** (Extended Euclidean Algorithm). Let $a, b \\in \\mathbb N$. Then\n\u003e\n\u003e $$\n\u003e au + bv = \\gcd(a, b) \\;, \\quad u, v \\in \\mathbb Z\n\u003e $$\n\u003e\n\u003e always has a solution.\n\u003e\n\u003e If $(u_0, v_0)$ is one solution, then every solution has the form\n\u003e\n\u003e $$\n\u003e u = u_0 + \\frac {bk} {\\gcd(a, b)}\n\u003e \\quad \\text{and} \\quad\n\u003e v = v_0 + \\frac {ak} {\\gcd(a, b)}\n\u003e \\quad \\text{for some } k \\in \\mathbb Z\n\u003e $$\n\n_Proof._\n\nSubstitute the remainder in each step of the Euclidean Algorithm into the equation of the next step\nin order to arrive at the expression.\n\n\u003e **Definition.** Let $a, b \\in \\mathbb Z$. We say that $a$ and $b$ are _relatively prime_ or _coprime_ if $\\gcd(a, b) = 1$.\n\u003e\n\u003e More generally, any equation\n\u003e\n\u003e $$\n\u003e au + bv = \\gcd(a, b)\n\u003e $$\n\u003e\n\u003e can be reduced to the case of relatively prime numbers by dividing both sides by $\\gcd(a, b)$.\n\u003e\n\u003e $$\n\u003e \\frac a {\\gcd(a, b)} u + \\frac b {\\gcd(a, b)} v = 1\n\u003e $$\n\n## 1.3 Modular arithmetic\n\n\u003e **Definition.** Let $m \\geq 1$ be an integer. We say that integers $a$ and $b$ are _congruent modulo m_ if their difference $a - b$ is divisible by $m$.\n\u003e\n\u003e $$\n\u003e a \\equiv b \\pmod m\n\u003e $$\n\n\u003e **Proposition 1.13.** Let $m \\geq 1$ be an integer.\n\u003e \\\n\u003e \\\n\u003e **(a)** If $a_1 \\equiv a_2 \\pmod m$ and $b_1 \\equiv b_2 \\pmod m$, then\n\u003e\n\u003e - $a_1 \\pm b_1 \\equiv a_2 \\pm b_2 \\pmod m$\n\u003e - $a_1 \\cdot b_1 \\equiv a_2 \\cdot b_2 \\pmod m$\n\u003e\n\u003e \\\n\u003e **(b)** Let $a \\in \\mathbb Z$. Then\n\u003e\n\u003e $$\n\u003e a \\cdot b \\equiv 1 \\pmod m \\quad \\text{for some integer $b$} \\iff \\gcd(a, m) = 1\n\u003e $$\n\n_Proof._\n\n$\\implies:$\nAssume $g = \\gcd(a, m) \\neq 1$, then $g \\mid a$ and $g \\mid m$.\nNow let $b \\in \\mathbb Z$, then $ab = mk + r$.\nIt follows that $g \\mid (ab - mk)$ and thus $g \\mid r$. But if $g \\neq 1 \\mid r$, then $r \\neq 1$.\n\n$\\impliedby:$\nTheorem 1.11 says that $ab + mk = \\gcd(a, m) = 1$ has a solution for $b, k \\in \\mathbb Z$.\nBecause $ab - 1 = -mk$, $ab \\equiv 1 \\pmod m$.\n\n\u003e **Definition.** Numbers that have multiplicative inverses modulo $m$ are called _units_.\n\u003e\n\u003e $$\n\u003e \\begin{aligned}\n\u003e (\\mathbb Z / m \\mathbb Z)^*\n\u003e \u0026= \\{a \\in \\mathbb Z / m \\mathbb Z : \\gcd(a, m) = 1\\} \\\\\n\u003e \u0026= \\{a \\in \\mathbb Z / m \\mathbb Z : a\\text{ has an inverse modulo }m\\}\n\u003e \\end{aligned}\n\u003e $$\n\u003e\n\u003e The set $(\\mathbb Z / m \\mathbb Z)^*$ is called the _group of units modulo m_.\n\u003e\n\u003e If $a_1$ and $a_2$ are units, then so is $a_1 \\cdot a_2$.\n\u003e On the other hand, if we add two units, we do not always get a unit.\n\n\u003e **Definition.** _Euler's phi function_ (or _Euler's totient function_) is the function $\\Phi(m)$ defined by\n\u003e\n\u003e $$\n\u003e \\Phi(m) = \\#(\\mathbb Z / m \\mathbb Z) ^* = \\# \\{ 0 \\leq a \\lt m: \\gcd(a, m) = 1\\} \\;.\n\u003e $$\n\n### 1.3.1 Modular arithmetic and shift ciphers\n\n_Encryption._\n\n$$\nc \\equiv p + k \\pmod {26}\n$$\n\n_Decryption._\n\n$$\np \\equiv c - k \\pmod {26}\n$$\n\n### 1.3.2 The fast powering algorithm\n\n$g^A \\pmod N$ can be computed by a succession of squarings and multiplications by using the binary expansion of the exponent, $A = A_0 + A_1 \\cdot 2^1 + \\cdots + A_r \\cdot 2^r$.\n\n_Example 1.19._\n\n$$\n3^{128}\n= 3^{2 + 2^3 + 2^4 + 2^6 + 2^7}\n= 3^{2^1} + 3^{2^3} + 3^{2^4} + 3^{2^6} + 3^{2^7}\n$$\n\n**Running Time.**\nIt takes at most $2r$ multiplications mod $N$ ($r$ multiplications for computing the squares and $r$ multiplications when computing the final result).\nBecause $A \\geq 2^r$, it takes at most $2\\log_2(A)$ multiplications to compute $g^A$.\nIf $A \\approx 2^{1000}$, this is about $2000$ multiplications.\n\n## 1.4 Prime numbers, unique factorization, and finite fields\n\n\u003e **Definition.** An integer $p$ is called a _prime_ if $p \\geq 1$ and if the only positive divisors are $1$ and $p$.\n\n\u003e **Proposition 1.20.** Let $p$ be a prime number that divides the product $ab$ of two integers.\n\u003e Then $p$ divides at least one of $a$ and $b$.\n\u003e More generally, if $p \\mid a_1a_2\\cdots a_n$, then $p$ divides at least one of the $a_i$.\n\n_Proof._\nLet $g = \\gcd (a, p)$. Then $g \\mid p$, so either $g = 1$ or $g = p$.\nIf $g = p$, then $p \\mid a$ and we're done.\nOtherwise if $g = 1$, then Theorem 1.11 says that we're able to find $u$, $v$ satisfying $au + pv = 1$.\nMultiplying by $b$ gives\n\n$$\nabu + pbv = b\n$$\n\nSince $p \\mid ab$ and $p \\mid pbv$, $p$ divides the left-hand side and so $p \\mid b$.\n\n\u003e **Theorem 1.21 (The Fundamental Theorem of Arithmetic).**\n\u003e Let $a \\geq 2$ be an integer. Then $a$ can be factored as a product of prime numbers\n\u003e\n\u003e $$\n\u003e a =\n\u003e p_1^{e_1}\n\u003e  \\cdot p_2^{e_2}\n\u003e  \\cdot p_3^{e_3}\n\u003e  \\cdots\n\u003e   p_r^{e_r}\n\u003e  \\; .\n\u003e $$\n\u003e\n\u003e This factorization is unique.\n\n_Proof._\n\nA simple algorithm can be used to prove that every $a \\geq 2$ can be factored into primes.\nTo prove uniqueness of the factorization, let\n$a = p_1^{e_1} \\cdot p_2^{e_2} \\cdot p_3^{e_3} \\cdots p_r^{e_r} = q_1^{f_1} \\cdot q_2^{f_2} \\cdot q_3^{f_3} \\cdots q_r^{f_s}$\nbe two factorizations of $a$.\n\n$p_1$ is a factor of $a$, so by Proposition 1.20, it must divide the product $\\prod_{i=1}^s q_i^{f_i}$. Since $p_1$ is prime, it means that there is an $1 \\leq i \\leq s$ with $q_i = p_1$.\n\nNow, since $p_1^{e_1}$ divides the product, $p_1$ must also appear with the same exponent. This process can be repeated to show that $r = s$ and $\\prod_{i=1}^r p_i^{e_i} = \\prod_{i=1}^s q_i^{f_i}$.\n\n\u003e **Definition.** The _order_ or _exponent_ of a prime $p$ in $a$ - $\\text {ord} _p (a)$ - is given by the power of $p$ in the factorization of $a$.\n\u003e\n\u003e $$\n\u003e a = \\prod _{p \\text { prime}} p^{\\text {ord} _p (a)}\n\u003e $$\n\n\u003e **Proposition 1.22.** Every element $a \\neq 0$ in $\\mathbb Z / p \\mathbb Z$ has a multiplicative inverse for $p$ prime.\n\u003e\n\u003e $$\n\u003e ab = 1 \\mod p\n\u003e $$\n\u003e\n\u003e We denote $b = a^{-1} \\mod p$.\n\n_Proof._ This follows directly from Proposition 1.13 b)\n\nUsing the Euclidean Algorithm we can compute $a^{-1}$ efficiently by solving\n\n$$\nau + pv = 1 \\;.\n$$\n\nIf follows that $u = a^{-1}$.\n\nWith Proposition 1.22 we get that $(\\mathbb Z / p \\mathbb Z)^* = \\{1, 2, \\ldots, p-1\\}$.\n\n\u003e **Definition.** $\\mathbb Z / p \\mathbb Z$ is a _field_. A field is a _Ring_ with the additional property that every\n\u003e nonzero element has a multiplicative inverse.\n\u003e We write\n\u003e $\\mathbb F_p = \\mathbb Z / p \\mathbb Z$\n\u003e for the finite field of $p$ elements and $\\mathbb F_p^* = (\\mathbb Z / p \\mathbb Z)^*$\n\u003e for its group of units with $p - 1$ elements.\n\n## 1.5 Powers and primitive roots in finite fields\n","title":"An Introduction to Mathematical Cryptography","date":"Mar 9, 2023","excerpt":"Notes taken from \"An Introduction to Mathematical Cryptography - Hoffstein\"","suptitle":"Jeffrey Hoffstein"},{"slug":"blog/2023/arithmetic-checks","contentRaw":"\n\u003e This post was created during my time at Trail of Bits. It is featured in the [secure-contracts/learn-evm](https://secure-contracts.com/learn_evm/arithmetic-checks).\n\nThe Ethereum Virtual Machine (EVM) distinguishes itself from other virtual machines and computer systems through several unique aspects.\nOne notable difference is its treatment of arithmetic checks.\nWhile most architectures and virtual machines provide access to carry bits or an overflow flag,\nthese features are absent in the EVM.\nConsequently, these safeguards must be incorporated within the machine's constraints.\n\nStarting with Solidity version 0.8.0 the compiler automatically includes over and underflow protection in all arithmetic operations.\nPrior to version 0.8.0, developers were required to implement these checks manually, often using a library known as [SafeMath](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol), originally developed by OpenZeppelin.\nThe compiler incorporates arithmetic checks in a manner similar to SafeMath, through additional operations.\n\nAs the Solidity language has evolved, the compiler has generated increasingly optimized code for arithmetic checks. This trend is also observed in smart contract development in general, where highly optimized arithmetic code written in low-level assembly is becoming more common. However, there is still a lack of comprehensive resources explaining the nuances of how the EVM handles arithmetic for signed and unsigned integers of 256 bits and less.\n\nThis article serves as a guide for gaining a deeper understanding of arithmetic in the EVM by exploring various ways to perform arithmetic checks. We'll learn more about the two's complement system and some lesser-known opcodes. This article is designed for those curious about the EVM's inner workings and those interested in bit manipulations in general. A basic understanding of bitwise arithmetic and Solidity opcodes is assumed.\n\nAdditional references for complementary reading are:\n\n- [evm.codes](https://evm.codes)\n- [Understanding Two's Complement](https://www.geeksforgeeks.org/twos-complement/)\n\n\u003e **Disclaimer:** Please note that this article is for educational purposes.\n\u003e It is not our intention to encourage micro optimizations in order to save gas,\n\u003e as this can potentially introduce new, hard-to-detect bugs that may compromise the security and stability of a protocol.\n\u003e As a developer, prioritize the safety and security of the protocol over [premature optimizations](https://www.youtube.com/watch?v=tKbV6BpH-C8).\n\u003e Including redundant checks for critical operations may be a good practice when the protocol code is still evolving.\n\u003e However, we do encourage experimentation with these operations for educational purposes.\n\n## Arithmetic checks for uint256 addition\n\nTo examine how the solc compiler implements arithmetic checks, we can compile the code with the `--asm` flag and inspect the resulting bytecode.\nAlternatively, using the `--ir` flag allows us to examine the Yul code that is generated as an intermediate representation (IR).\n\n\u003e Note that Solidity aims to make the new Yul pipeline the standard.\n\u003e Certain operations (including arithmetic checks) are always included as Yul code, regardless of whether the code is compiled with the new pipeline using `--via-ir`.\n\u003e This provides an opportunity to examine the Yul code and gain a better understanding of how arithmetic checks are executed in Solidity.\n\u003e However, keep in mind that the final bytecode may differ slightly when compiler optimizations are turned on.\n\nTo illustrate how the compiler detects overflow in unsigned integer addition, consider the following example of Yul code produced by the compiler before version 0.8.16.\n\n```solidity\nfunction checked_add_t_uint256(x, y) -\u003e sum {\n    x := cleanup_t_uint256(x)\n    y := cleanup_t_uint256(y)\n\n    // overflow, if x \u003e (maxValue - y)\n    if gt(x, sub(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, y)) { panic_error_0x11() }\n\n    sum := add(x, y)\n}\n```\n\nTo improve readability, we can translate the Yul code back into high-level Solidity code.\n\n```solidity\n/// @notice versions \u003e=0.8.0 \u0026\u0026 \u003c0.8.16\nfunction checkedAddUint1(uint256 a, uint256 b) public pure returns (uint256 c) {\n    unchecked {\n        c = a + b;\n\n        if (a \u003e type(uint256).max - b) arithmeticError();\n    }\n}\n```\n\n\u003e Solidity's arithmetic errors are encoded as `abi.encodeWithSignature(\"Panic(uint256)\", 0x11)`.\n\nThe check for overflow in unsigned integer addition involves calculating the largest value that one summand can have when added to the other without causing an overflow.\nSpecifically, in this case, the maximum value `a` can have is `type(uint256).max - b`.\nIf `a` exceeds this value, we can conclude that `a + b` will overflow.\n\nAn alternative and slightly more efficient approach for computing the maximum value of `a` involves inverting the bits of `b`.\n\n```solidity\n/// @notice versions \u003e=0.8.0 \u0026\u0026 \u003c0.8.16 with compiler optimizations\nfunction checkedAddUint2(uint256 a, uint256 b) public pure returns (uint256 c) {\n    unchecked {\n        c = a + b;\n\n        if (a \u003e ~b) arithmeticError();\n    }\n}\n```\n\nThis is process is equivalent, because `type(uint256).max` is a 256-bit integer with all its bits set to `1`.\nSubtracting `b` from `type(uint256).max` can be viewed as inverting each bit in `b`.\nThis transformation is demonstrated by `~b = ~(0 ^ b) = ~0 ^ b = MAX ^ b = MAX - b`.\n\n\u003e Note that `a - b = a ^ b` is **NOT** a general rule, except in special cases, such as when one of the values equals `type(uint256).max`.\n\u003e The relation `~b + 1 = 0 - b = -b` is also obtained if we add `1` mod `2**256` to both sides of the previous equation.\n\nBy first calculating the result of the addition and then performing a check on the sum, the need performing extra arithmetic operations are removed.\nThis is how the compiler implements arithmetic checks for unsigned integer addition in versions 0.8.16 and later.\n\n```solidity\n/// @notice versions \u003e=0.8.16\nfunction checkedAddUint(uint256 a, uint256 b) public pure returns (uint256 c) {\n    unchecked {\n        c = a + b;\n\n        if (a \u003e c) arithmeticError();\n    }\n}\n```\n\nOverflow is detected when the sum is smaller than one of its addends.\nIn other words, if `a \u003e a + b`, then overflow has occurred.\nTo fully prove this, it is necessary to verify that overflow occurs if and only if `a \u003e a + b`.\nAn important observation is that `a \u003e a + b` (mod `2**256`) for `b \u003e 0` is only possible when `b \u003e= 2**256`, which exceeds the maximum possible value.\n\n## Arithmetic checks for int256 addition\n\nThe Solidity compiler generates the following (equivalent) code for detecting overflow in signed integer addition for versions below 0.8.16.\n\n```solidity\n/// @notice versions \u003e=0.8.0 \u0026\u0026 \u003c0.8.16\nfunction checkedAddInt(int256 a, int256 b) public pure returns (int256 c) {\n    unchecked {\n        c = a + b;\n\n        // If `a \u003e 0`, then `b` can't exceed `type(int256).max - a`.\n        if (a \u003e 0 \u0026\u0026 b \u003e type(int256).max - a) arithmeticError();\n        // If `a \u003c 0`, then `b` can't be less than `type(int256).min - a`.\n        if (a \u003c 0 \u0026\u0026 b \u003c type(int256).min - a) arithmeticError();\n    }\n}\n```\n\nSimilar to the previous example, we can compute the maximum and minimum value of one addend, given that the other is either positive or negative.\n\nFor reference, this is the Yul code that is produced when compiling via IR.\n\n```solidity\nfunction checked_add_t_int256(x, y) -\u003e sum {\n    x := cleanup_t_int256(x)\n    y := cleanup_t_int256(y)\n\n    // overflow, if x \u003e= 0 and y \u003e (maxValue - x)\n    if and(iszero(slt(x, 0)), sgt(y, sub(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, x))) { panic_error_0x11() }\n    // underflow, if x \u003c 0 and y \u003c (minValue - x)\n    if and(slt(x, 0), slt(y, sub(0x8000000000000000000000000000000000000000000000000000000000000000, x))) { panic_error_0x11() }\n\n    sum := add(x, y)\n}\n```\n\nIt's important to note that when comparing signed values, the opcodes `slt` (signed less than) and `sgt` (signed greater than) must be used to avoid interpreting signed integers as unsigned integers.\nSolidity will automatically insert the correct opcode based on the value's type. This applies to other signed operations as well.\n\n### Quick primer on a two's complement system\n\nIn a two's complement system, the range of possible integers is divided into two halves: the positive and negative domains.\nThe first bit of an integer represents the sign, with `0` indicating a positive number and `1` indicating a negative number.\nFor positive integers (those with a sign bit of `0`), their binary representation is the same as their unsigned bit representation.\nHowever, the negative domain is shifted to lie \"above\" the positive domain.\n\n$$uint256 \\text{ domain}$$\n\n$$\n├\\underset{0}{─}────────────────────────────\\underset{\\hskip -2em 2^{256} - 1}{─}┤\n$$\n\n```solidity\n0x0000000000000000000000000000000000000000000000000000000000000000 // 0\n0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff // uint256_max\n```\n\n$$int256 \\text{ domain}$$\n\n$$\n\\overset{\\hskip 1em positive}{\n    ├\\underset{0}{─}────────────\\underset{\\hskip -2em 2^{255} - 1}{─}┤\n}\n\\overset{\\hskip 1em negative}{\n    ├────\\underset{\\hskip -3.5em - 2^{255}}─────────\\underset{\\hskip -0.4 em -1}{─}┤\n}\n$$\n\n```solidity\n0x0000000000000000000000000000000000000000000000000000000000000000 // 0\n0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff // int256_max\n0x8000000000000000000000000000000000000000000000000000000000000000 // int256_min\n0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff // -1\n```\n\nThe maximum positive integer that can be represented in a two's complement system using 256 bits is\n`0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` which is roughly equal to half of the maximum value that can be represented using uint256.\nThe most significant bit of this number is `0`, while all other bits are `1`.\n\nOn the other hand, all negative numbers start with a `1` as their first bit.\nIf we look at the underlying hex representation of these numbers, they are all greater than or equal to the smallest integer that can be represented using int256, which is `0x8000000000000000000000000000000000000000000000000000000000000000`. The integer's binary representation is a `1` followed by 255 `0`'s.\n\nTo obtain the negative value of an integer in a two's complement system, we flip the underlying bits and add `1`: `-a = ~a + 1`.\nAn example illustrates this.\n\n```solidity\n0x0000000000000000000000000000000000000000000000000000000000000003 // 3\n0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc // ~3\n0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd // -3 = ~3 + 1\n```\n\nTo verify that `-a + a = 0` holds for all integers, we can use the property of two's complement arithmetic that `-a = ~a + 1`.\nBy substituting this into the equation, we get `-a + a = (~a + 1) + a = MAX + 1 = 0`, where `MAX` is the maximum integer value.\n\nIn two's complement arithmetic, there is a unique case that warrants special attention. The smallest possible integer `int256).min = 0x8000000000000000000000000000000000000000000000000000000000000000 = -57896044618658097711785492504343953926634992332820282019728792003956564819968`\ndoes not have a positive inverse, making it the only negative number with this property.\n\nInterestingly, if we try to compute `-type(int256).min`, we obtain the same number, as `-type(int256).min = ~type(int256).min + 1 = type(int256).min`.\nThis means there are two fixed points for additive inverses: `-0 = 0` and `-type(int256).min = type(int256).min`.\nIt's important to note that Solidity's arithmetic checks will throw an error when evaluating `-type(int256).min` (outside of unchecked blocks).\n\nExamining the underlying bit (or hex) representation emphasizes the importance of using the correct operators for signed integers, such as `slt` instead of `lt`, to prevent misinterpreting negative values as large numbers.\n\n```solidity\n  0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff // int256(-1) or type(uint256).max\n\u003c 0x0000000000000000000000000000000000000000000000000000000000000000 // 0\n// When using `slt`, the comparison is interpreted as `-1 \u003c 0 = true`.\n= 0x0000000000000000000000000000000000000000000000000000000000000001\n// When using `lt`, the comparison is interpreted as `type(uint256).max \u003c 0 = false`.\n= 0x0000000000000000000000000000000000000000000000000000000000000000\n```\n\nStarting with Solidity versions 0.8.16, integer overflow is prevented by using the computed result `c = a + b` to check for overflow/underflow.\nHowever, signed addition requires two separate checks instead of one, unlike unsigned addition.\n\n```solidity\n/// @notice versions \u003e=0.8.16\nfunction checkedAddInt2(int256 a, int256 b) public pure returns (int256 c) {\n    unchecked {\n        c = a + b;\n\n        // If `a` is positive, then the sum `c = a + b` can't be less than `b`.\n        if (a \u003e 0 \u0026\u0026 c \u003c b) arithmeticError();\n        // If `a` is negative, then the sum `c = a + b` can't be greater than `b`.\n        if (a \u003c 0 \u0026\u0026 c \u003e b) arithmeticError();\n    }\n}\n```\n\nNevertheless, by utilizing the boolean exclusive-or, we can combine these checks into a single step.\nAlthough Solidity does not allow the `xor` operation for boolean values, it can be used in inline-assembly.\nWhile doing so, it is important to validate our assumptions that both inputs are genuinely boolean (either `0` or `1`), as the xor operation functions bitwise and is not limited to only boolean values.\n\n```solidity\nfunction checkedAddInt3(int256 a, int256 b) public pure returns (int256 c) {\n    unchecked {\n        c = a + b;\n\n        bool overflow;\n\n        assembly {\n            // If `a \u003e= 0`, then the sum `c = a + b` can't be less than `b`.\n            // If `a \u003c  0`, then the sum `c = a + b` can't be greater than `b`.\n            // We combine these two conditions into one using `xor`.\n            overflow := xor(slt(a, 0), sgt(b, c))\n        }\n\n        if (overflow) arithmeticError();\n    }\n}\n```\n\nAn alternative approach to detecting overflow in addition is based on the observation that adding two integers with different signs will never result in an overflow.\nThis simplifies the check to the case when both operands have the same sign.\nIf the sign of the sum differs from one of the operands, the result has overflowed.\n\n```solidity\nfunction checkedAddInt4(int256 a, int256 b) public pure returns (int256 c) {\n    unchecked {\n        c = a + b;\n\n        // Overflow, if the signs of `a` and `b` are the same,\n        // but the sign of the result `c = a + b` differs from its summands.\n        // When the signs of `a` and `b` differ overflow is not possible.\n        if ((~a ^ b) \u0026 (a ^ c) \u003c 0) arithmeticError();\n    }\n}\n```\n\nInstead of checking the sign bit explicitly, which can be done by shifting the value to the right by 255 bits and verifying that it is non-zero,\nwe can use the `slt` operation to compare the value with `0`.\n\n## Arithmetic checks for uint256 subtraction\n\nThe process of checking for underflow in subtraction is similar to that of addition.\nWhen subtracting `a - b`, and `b` is greater than `a`, an underflow occurs.\n\n```solidity\nfunction checkedSubUint(uint256 a, uint256 b) public pure returns (uint256 c) {\n    unchecked {\n        c = a - b;\n\n        if (b \u003e a) arithmeticError();\n    }\n}\n```\n\nAlternatively, we could perform the check on the result itself using `if (c \u003e a) arithmeticError();`, because subtracting a positive value from `a` should yield a value less than or equal to `a`.\nHowever, in this case, we don't save any operations.\n\nSimilar to addition, for signed integers, we can combine the checks for both scenarios into a single check using `xor`.\n\n```solidity\nfunction checkedSubInt(int256 a, int256 b) public pure returns (int256 c) {\n    unchecked {\n        c = a - b;\n\n        bool overflow;\n\n        assembly {\n            // If `b \u003e= 0`, then the result `c = a - b` can't be greater than `a`.\n            // If `b \u003c  0`, then the result `c = a - b` can't be less than `a`.\n            overflow := xor(sgt(b, 0), sgt(a, c))\n        }\n\n        if (overflow) arithmeticError();\n    }\n}\n```\n\n## Arithmetic checks for uint256 multiplication\n\nTo detect overflow when multiplying two unsigned integers, we can use the approach of computing the maximum possible value of a multiplicand and check that it isn't exceeded.\n\n```solidity\n/// @notice versions \u003e=0.8.0 \u0026\u0026 \u003c0.8.17\nfunction checkedMulUint1(uint256 a, uint256 b) public pure returns (uint256 c) {\n    unchecked {\n        c = a * b;\n\n        if (a != 0 \u0026\u0026 b \u003e type(uint256).max / a) arithmeticError();\n    }\n}\n```\n\n\u003e The Solidity compiler always includes a zero check for all division and modulo operations, irrespective of whether an unchecked block is present.\n\u003e The EVM itself, however, returns `0` when dividing by `0`, which applies to inline-assembly as well.\n\u003e Evaluating the boolean expression `a != 0 \u0026\u0026 b \u003e type(uint256).max / a` in reverse order would cause an incorrect reversion when `a = 0`.\n\nWe can compute the maximum value for `b` as long as `a` is non-zero. However, if `a` is zero, we know that the result will be zero as well, and there is no need to check for overflow.\nLike before, we can also make use of the result and try to reconstruct one multiplicand from it. This is possible if the product didn't overflow and the first multiplicand is non-zero.\n\n```solidity\n/// @notice versions \u003e=0.8.17\nfunction checkedMulUint2(uint256 a, uint256 b) public pure returns (uint256 c) {\n    unchecked {\n        c = a * b;\n\n        if (a != 0 \u0026\u0026 b != c / a) arithmeticError();\n    }\n}\n```\n\nFor reference, we can further remove the additional division by zero check by writing the code in assembly.\n\n```solidity\nfunction checkedMulUint3(uint256 a, uint256 b) public pure returns (uint256 c) {\n    unchecked {\n        c = a * b;\n\n        bool overflow;\n\n        assembly {\n            // This version does not include a redundant division-by-0 check\n            // which the Solidity compiler includes when performing `c / a`.\n            overflow := iszero(or(iszero(a), eq(div(c, a), b)))\n        }\n\n        if (overflow) arithmeticError();\n    }\n}\n```\n\n## Arithmetic checks for int256 multiplication\n\nIn versions before 0.8.17, the Solidity compiler uses four separate checks to detect integer multiplication overflow.\nThe produced Yul code is equivalent to the following high-level Solidity code.\n\n```solidity\n/// @notice versions \u003e=0.8.0 \u0026\u0026 \u003c0.8.17\nfunction checkedMulInt(int256 a, int256 b) public pure returns (int256 c) {\n    unchecked {\n        c = a * b;\n\n        if (a \u003e 0 \u0026\u0026 b \u003e 0 \u0026\u0026 a \u003e type(int256).max / b) arithmeticError();\n        if (a \u003e 0 \u0026\u0026 b \u003c 0 \u0026\u0026 a \u003c type(int256).min / b) arithmeticError();\n        if (a \u003c 0 \u0026\u0026 b \u003e 0 \u0026\u0026 a \u003c type(int256).min / b) arithmeticError();\n        if (a \u003c 0 \u0026\u0026 b \u003c 0 \u0026\u0026 a \u003c type(int256).max / b) arithmeticError();\n    }\n}\n```\n\nSince Solidity version 0.8.17, the check is performed by utilizing the computed product in the check.\n\n```solidity\n/// @notice versions \u003e=0.8.17\nfunction checkedMulInt2(int256 a, int256 b) public pure returns (int256 c) {\n    unchecked {\n        c = a * b;\n\n        if (a \u003c 0 \u0026\u0026 b == type(int256).min) arithmeticError();\n        if (a != 0 \u0026\u0026 b != c / a) arithmeticError();\n    }\n}\n```\n\nWhen it comes to integer multiplication, it's important to handle the case when `a \u003c 0` and `b == type(int256).min`.\nThe actual case, where the product `c` will overflow, is limited to `a == -1` and `b == type(int256).min`.\nThis is because `-b` cannot be represented as a positive signed integer, as previously mentioned.\n\n## Arithmetic checks for addition with sub-32-byte types\n\nWhen performing arithmetic checks on data types that use less than 32 bytes, there are some additional steps to consider.\nFirst, let's take a look at the addition of signed 64-bit integers.\n\nOn a 64-bit system, integer addition works in the same way as before.\n\n```solidity\n  0xfffffffffffffffe // int64(-2)\n+ 0x0000000000000003 // int64(3)\n= 0x0000000000000001 // int64(1)\n```\n\nHowever, when performing the same calculations on a 256-bit machine, we need to extend the sign of the int64 value over all unused bits,\notherwise the value won't be interpreted correctly.\n\n```solidity\n                                   extended sign ──┐┌── 64-bit information\n  0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe // int64(-2)\n+ 0x0000000000000000000000000000000000000000000000000000000000000003 // int64(3)\n= 0x0000000000000000000000000000000000000000000000000000000000000001 // int64(1)\n```\n\nIt's worth noting that not all operations require clean upper bits. In fact, even if the upper bits are dirty, we can still get correct results for addition. However, the sum will usually contain dirty upper bits that will need to be cleaned. For example, we can perform addition without knowledge of the upper bits.\n\n```solidity\n  0x????????????????????????????????????????????????fffffffffffffffe // int64(-2)\n+ 0x????????????????????????????????????????????????0000000000000003 // int64(3)\n= 0x????????????????????????????????????????????????0000000000000001 // int64(1)\n```\n\nIt is crucial to be mindful of when to clean the bits before and after operations.\nBy default, Solidity takes care of cleaning the bits before operations on smaller types and lets the optimizer remove any redundant steps.\nHowever, values accessed after operations included by the compiler are not guaranteed to be clean. In particular, this is the case for addition with small data types.\nFor example, the bit cleaning steps will be removed by the optimizer (even without optimizations enabled) if a variable is only accessed in a subsequent assembly block.\nRefer to the [Solidity documentation](https://docs.soliditylang.org/en/v0.8.18/internals/variable_cleanup.html#cleaning-up-variables) for further information on this matter.\n\nWhen performing arithmetic checks in the same way as before, it is necessary to include a step to clean the bits on the sum.\nOne approach to achieve this is by performing `signextend(7, value)`, which extends the sign of a 64-bit (7 + 1 = 8 bytes) integer over all upper bits.\n\n```solidity\nfunction checkedAddInt64_1(int64 a, int64 b) public pure returns (int64 c) {\n    unchecked {\n        bool overflow;\n\n        c = a + b;\n\n        assembly {\n            // Note that we must manually clean the upper bits in this case.\n            // Solidity will optimize the cleaning away otherwise.\n            // Extend the sign of the sum to 256 bits.\n            c := signextend(7, c)\n\n            // Perform the same arithmetic overflow check as before.\n            overflow := xor(slt(a, 0), sgt(b, c))\n        }\n\n        if (overflow) arithmeticError();\n    }\n}\n```\n\nIf we remove the line that includes `c := signextend(7, c)` the overflow check will not function correctly.\nThis is because Solidity does not take into account the fact that the variable is used in an assembly block, and the optimizer removes the bit cleaning operation, even if the Yul code includes it after the addition.\n\nOne thing to keep in mind is that since we are performing a 64-bit addition in 256 bits, we practically have access to the carry/overflow bits.\nIf our computed value does not overflow, then it will fall within the correct bounds `type(int64).min \u003c= c \u003c= type(int64).max`.\nThe actual overflow check in Solidity involves verifying both the upper and lower bounds.\n\n```solidity\n/// @notice version \u003e= 0.8.16\nfunction checkedAddInt64_2(int64 a, int64 b) public pure returns (int64 c) {\n    unchecked {\n        // Perform the addition in int256.\n        int256 uc = int256(a) + b;\n\n        // If the value can not be represented by a int64, there is overflow.\n        if (uc \u003e type(int64).max || uc \u003c type(int64).min) arithmeticError();\n\n        // We can safely cast the result.\n        c = int64(uc);\n    }\n}\n```\n\nThere are a few ways to verify that the result in its 256-bit representation will fit into the expected data type.\nThis is only true when all upper bits are the same.\nThe most direct method, as previously shown, involves verifying both the lower and upper bounds.\n\n```solidity\n/// @notice Check used in int64 addition for version \u003e= 0.8.16.\nfunction overflowInt64(int256 value) public pure returns (bool overflow) {\n    overflow = value \u003e type(int64).max || value \u003c type(int64).min;\n}\n```\n\nWe can simplify the expression to a single comparison if we can shift the disjointed number domain back so that it's connected.\nTo accomplish this, we subtract the smallest negative int64 `type(int64).min` from a value (or add the underlying unsigned value).\nA better way to understand this is by visualizing the signed integer number domain in relation to the unsigned domain (which is demonstrated here using int128).\n\n$$uint256 \\text{ domain}$$\n\n$$\n├\\underset{0}{─}────────────────────────────\\underset{\\hskip -2em 2^{256} - 1}{─}┤\n$$\n\n$$int256 \\text{ domain}$$\n\n$$\n\\overset{\\hskip 1em positive}{\n    ├\\underset{0}{─}────────────\\underset{\\hskip -2em 2^{255} - 1}{─}┤\n}\n\\overset{\\hskip 1em negative}{\n    ├────\\underset{\\hskip -3.5em - 2^{255}}─────────\\underset{\\hskip -0.4 em -1}{─}┤\n}\n$$\n\nThe domain for uint128/int128 can be visualized as follows.\n\n$$uint128 \\text{ domain}$$\n\n$$\n├\\underset{0}─────────────\\underset{\\hskip -2em 2^{128}-1}─┤\n\\phantom{───────────────}┆\n$$\n\n$$int128 \\text{ domain}$$\n\n$$\n\\overset{\\hskip 1em positive}{\n    ├\\underset{0}{─}────\\underset{\\hskip -2em 2^{127} - 1}{─}┤\n}\n\\phantom{────────────────}\n\\overset{\\hskip 1em negative}{\n    ├────\\underset{\\hskip -3.5em - 2^{127}}─\\underset{\\hskip -0.4 em -1}{─}┤\n}\n$$\n\nNote that the scales of the number ranges in the previous section do not accurately depict the magnitude of numbers that are representable with the different types and only serve as a visualization. We can represent twice as many numbers with only one additional bit, yet the uint256 domain has twice the number of bits compared to uint128.\n\nAfter subtracting `type(int128).min` (or adding $2^{127}$) and essentially shifting the domains to the right, we get the following, connected set of values.\n\n$$\n├\\underset{0}─────────────\\underset{\\hskip -2em 2^{128}-1}─┤\n\\phantom{───────────────}┆\n$$\n\n$$\n\\overset{\\hskip 1em negative}{├──────┤}\n\\overset{\\hskip 1em positive}{├──────┤}\n\\phantom{───────────────}┆\n$$\n\nIf we interpret the shifted value as an unsigned integer, we only need to check whether it exceeds the maximum unsigned integer `type(uint128).max`.\nThe corresponding check in Solidity is shown below.\n\n```solidity\nfunction overflowInt64_2(int256 value) public pure returns (bool overflow) {\n    unchecked {\n        overflow = uint256(value) - uint256(int256(type(int64).min)) \u003e type(uint64).max;\n    }\n}\n```\n\nIn this case the verbose assembly code might actually be easier to follow than the Solidity code which sometimes contains implicit operations.\n\n```solidity\nint64 constant INT64_MIN = -0x8000000000000000;\nuint64 constant UINT64_MAX = 0xffffffffffffffff;\n\nfunction overflowInt64_2_yul(int256 value) public pure returns (bool overflow) {\n    assembly {\n        overflow := gt(sub(value, INT64_MIN), UINT64_MAX)\n    }\n}\n```\n\nAs mentioned earlier, this approach is only effective for negative numbers when all of their upper bits are set to `1`, allowing us to overflow back into the positive domain.\nAn alternative and more straightforward method would be to simply verify that all of the upper bits are equivalent to the sign bit for all integers.\n\n```solidity\nfunction overflowInt64_3(int256 value) public pure returns (bool overflow) {\n    overflow = value != int64(value);\n}\n```\n\nIn Yul, the equivalent resembles the following.\n\n```solidity\nfunction overflowInt64_3_yul(int256 value) public pure returns (bool overflow) {\n    assembly {\n        overflow := iszero(eq(value, signextend(7, value)))\n    }\n}\n```\n\nAnother way of extending the sign is to make use of `sar` (signed arithmetic right shift).\n\n```solidity\nfunction overflowInt64_4(int256 value) public pure returns (bool overflow) {\n    overflow = value != (value \u003c\u003c 192) \u003e\u003e 192;\n}\n\nfunction overflowInt64_4_yul(int256 value) public pure returns (bool overflow) {\n    assembly {\n        overflow := iszero(eq(value, sar(192, shl(192, value))))\n    }\n}\n```\n\nFinally, a full example for detecting signed 64-bit integer overflow, implemented in Solidity can be seen below:\n\n```solidity\nfunction checkedAddInt64_2(int64 a, int64 b) public pure returns (int64 c) {\n    unchecked {\n        // Cast the first summand.\n        // The second summand is implicitly casted.\n        int256 uc = int256(a) + b;\n\n        // Check whether the result `uc` can be represented by 64 bits\n        // by shifting the values to the uint64 domain.\n        // This is done by subtracting the smallest value in int64.\n        if (uint256(uc) - uint256(int256(type(int64).min)) \u003e type(uint64).max) arithmeticError();\n\n        // We can safely cast the result.\n        c = int64(uc);\n    }\n}\n```\n\nOne further optimization that we could perform is to add `-type(int64).min` instead of subtracting `type(int64).min`. This would not reduce computation costs, however it could end up reducing bytecode size. This is because when we subtract `-type(int64).min`, we need to push 32 bytes (`0xffffffffffffffffffffffffffffffffffffffffffffffff8000000000000000`), whereas when we add `-type(int64).min`, we only end up pushing 8 bytes (`0x8000000000000000`). However, as soon as we turn on compiler optimizations, the produced bytecode ends up being the same.\n\n## Arithmetic checks for multiplication with sub-32-byte types\n\nWhen the product `c = a * b` can be calculated in 256 bits without the possibility of overflowing, we can verify whether the result can fit into the anticipated data type. This is also the way Solidity handles the check in versions 0.8.17 and later.\n\n```solidity\n/// @notice version \u003e= 0.8.17\nfunction checkedMulInt64(int64 a, int64 b) public pure returns (int64 c) {\n    unchecked {\n        int256 uc = int256(a) * int256(b);\n\n        // If the product can not be represented with 64 bits,\n        // there is overflow.\n        if (overflowInt64(uc)) arithmeticError();\n\n        c = int64(uc);\n    }\n}\n```\n\nHowever, if the maximum value of a product exceeds 256 bits, then this method won't be effective.\nThis happens, for instance, when working with int192. The product `type(int192).min * type(int192).min` requires 192 + 192 = 384 bits to be stored, which exceeds the maximum of 256 bits.\nOverflow occurs in 256 bits, causing a loss of information, and it won't be logical to check if the result fits into 192 bits.\nIn this scenario, we can rely on the previous checks and, for example, attempt to reconstruct one of the multiplicands.\n\n```solidity\nfunction checkedMulInt192_1(int192 a, int192 b) public pure returns (int192 c) {\n    unchecked {\n        c = a * b;\n\n        if (a != 0 \u0026\u0026 b != c / a) arithmeticError();\n        if (a = -1 \u0026\u0026 b == type(int192).min) arithmeticError();\n    }\n}\n```\n\nWe must consider the two special circumstances:\n\n1. When one of the multiplicands is zero (`a == 0`), the other multiplicand cannot be retrieved. However, this case never results in overflow.\n2. Even if the multiplication is correct in 256 bits, the calculation overflows when only examining the least-significant 192 bits if the first multiplicand is negative one (`a = -1`) and the other multiplicand is the minimum value.\n\nAn example might help explain the second case.\n\n```solidity\n  0xffffffffffffffff800000000000000000000000000000000000000000000000 // type(int192).min\n* 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff // -1\n= 0x0000000000000000800000000000000000000000000000000000000000000000 // type(int192).min (when seen as a int192)\n```\n\nA method to address this issue is to always start by sign-extending or cleaning the result before attempting to reconstruct the other multiplicand.\nBy doing so, it eliminates the need to check for the special condition.\n\n```solidity\n/// @notice version \u003e= 0.8.17\nfunction checkedMulInt192_2(int192 a, int192 b) public pure returns (int192 c) {\n    unchecked {\n        bool overflow;\n\n        assembly {\n            // Extend the sign for int192 (24 = 23 + 1 bytes).\n            c := signextend(23, mul(a, b))\n\n            // Overflow, if `a != 0 \u0026\u0026 b != c / a`.\n            overflow := iszero(or(iszero(a), eq(b, sdiv(c, a))))\n        }\n\n        if (overflow) arithmeticError();\n    }\n}\n```\n\n## Conclusion\n\nIn conclusion, we hope this article has served as an informative guide on signed integer arithmetic within the EVM and the two's complement system.\nWe have explored:\n\n- the added complexity from handling signed over unsigned integers\n- the intricacies involved in managing sub 32-byte types\n- the significance of `signextend` and opcodes related to signed integers\n- the importance of bit-cleaning\n\nWhile low-level optimizations are attractive, they are also heavily error-prone. This article aims to deepen one's understanding of low-level arithmetic, to reduce these risks. Nevertheless, it is crucial to integrate custom low-level optimizations only after thorough manual analysis, automated testing, and to document any non-obvious assumptions.\n","title":"A Guide on Performing Arithmetic Checks in the EVM","date":"Feb 19, 2023","excerpt":"A post created during my time at Trail of Bits. It features the many ways that arithmetic checks can be performed in the EVM."},{"slug":"blog/2022/clones-with-immutable-args-comparison","contentRaw":"\n[Clones with immutable args](https://github.com/wighawag/clones-with-immutable-args) (CWIA) aim to save gas by avoiding storage reads and writes. \n\n\nClones - and proxies alike - usually contain a initializer function to set parameters specific to the clone. This is due to the nature of contracts that function as proxies. Typically they use standardized and optimized implementations that contain minimal logic and forward all calls to an contract that handles the implementation logic. \n\nImmutable variables are useful, because instead of writing these variables into the contract's storage space, they are directly included in the contract's runtime bytecode. They work in a similar way as variables that are declared to be constant, but they are evaluated and inserted during contract creation - in the constructor.\n\nSince solidity does not allow for dynamic type immutable variables, it's not that straightforward to write a clone/proxy contract that will just take in a immutable string of bytes to be easily accessed in the implementation contract.\n\nAnother reason for the slow adoption of clones that use immutable args is that they are often heavily optimized. [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167) formalizes the specs for minimal proxy clones. \n\n```ERC1167Clone.evm\n0x363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3\n```\n\nBecause EIP-1667 clones can easily be identified by checking their bytecode, services such as [etherscan](https://etherscan.io) are able to detect these. \nIf the contract were to include immutable args however, this would require more rules in order to identify such contracts, because the immutable args must be included in the contract's runtime code.\n\n\u003c!-- Clones, much like proxies typically only contain minimal logic and use the `delegatecall` opcode to refer to another contract for the implementation details. Because solidity does not allow for dynamic type immutable variables, it is not possible to pass arbitrary bytes to the clone contract to store these in the contract code versus the contract storage.\nEven if we were to use a specialized clone that is able to set immutable variables in its constructor, this could be problematic. Clones are heavily optimized (and written in bytecode) to contain minimally required bytes in order to reduce gas costs when deploying and when interacting with these contracts.\n\n[EIP-1167](https://eips.ethereum.org/EIPS/eip-1167) formalizes the spec for minimal proxy clones. Because they always have the same bytecode, they can easily be detected as clones by services such as [etherscan](https://etherscan.io). \nImmutable variables are similar to constants, except for that they are evaluated during constructor call and replaced in the contract runtime code.\nThis means that they actually end up in the contract's runtime code. Two contracts initialized with different immutable variables will end up having a different runtime code. \nIt would be possible to \nAnd since there has not been any spec to account for \n\nNormally, if one wants to pass data to when using [EIP-1167 Minimal Proxy Clones](https://eips.ethereum.org/EIPS/eip-1167)clones, a clone will contain an `init()` function which is called upon construction with parameters that end up getting stored in the clone's contract storage.\nwould be required \n\nCWIA work by appending the immutable args --\u003e\n\n\n# Clones with immutable args - via `CALL`\n\nTo illustrate some of the ideas behind clones with immutable args, we \ncan think of a minimal clone contract that takes in an immutable arg as a parameter.\n\n```CloneWithImmutableArgsVer1.sol\ncontract CloneWithImmutableArgsVer1 {\n    address private immutable logic;\n    uint256 public immutable immutableArg0;\n\n    constructor(address logic_, uint256 immutableArg0_) payable {\n        logic = logic_;\n        immutableArg0 = immutableArg0_;\n    }\n\n    fallback() external payable {\n        address logic_ = logic;\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n\n            let success := delegatecall(gas(), logic_, 0, calldatasize(), 0, 0)\n\n            returndatacopy(0, 0, returndatasize())\n\n            if success {\n                return(0, returndatasize())\n            }\n\n            revert(0, returndatasize())\n        }\n    }\n}\n```\n\nThis contract takes in a `address logic_` to which all calls are delegated to and a `uint256 immutableArg0_` that is accessible to the clone as a public function.\n\n\u003c!-- While writing the contracts in solidity makes it easy to follow along and understand the ideas, the resulting bytecode ends up being much bigger compared to the optimized EIP-1167 clones.\n\n```CloneWithImmutableArgsVer1.evm\n0x608060405260043610601c5760003560e01c80634134658c146060575b7f000000000000000000000000ce71065d4017f316ec606fe4422e11eb2c47c2463660008037600080366000845af43d6000803e8015605a573d6000f35b503d6000fd5b348015606b57600080fd5b5060927f000000000000000000000000000000000000000000000000000000000000133781565b60405190815260200160405180910390f3fea164736f6c634300080f000a\n```\n\nClones are often used in clone factories where many hundred or thousand clones are created - such as AMM pools. The logic thus has to be heavily optimized to reduce deployment costs and gas costs when interacting with the contracts.\n\nThe consequences are that \n1) deploying these clones will have a higher cost - due to increased bytecode size\n2) Calling such a clone will have a higher cost - due to the increased bytecode size and due to having 2 function dispatchers now, one in the clone and one in the logic --\u003e\n\nThere is still one problem, however. We usually will want to access `immutableArg0` from within the logic contract. Since the logic contract does not know about `immutableArg0` - let alone the clone contract itself - it is not directly available to the implementation.\nAlthough, since we know that we will be calling the logic contract via `delegatecall`, we can call back into the clone contract via `CloneWithImmutableArgsVer1(address(this)).immutableArg0()` to access the variable.\n\n\u003e Essentially this method will result in an additional `call` operation and a `codecopy` operation once the context is set back to the clone contract. `staticcall` could also be used instead to ensure that no persistent changes are being made.\n\nAnother problem is that the current contract only works for one fixed 32 bytes word. \nIdeally, we would be able to store and access arbitrary byte strings.\nA way to get around this is shown in the next possible method that uses `extcodecopy`.\n\n\n# Clones with immutable args - via `EXTCODECOPY`\n\nInstead of calling back into the clone contract, we could also directly access the bytes via `extcodecopy` while remaining in the context of the implementation contract.\nThis example will work with immutable args that can be bytes of arbitrary lengths.\n\n```ClonesWithImmutableArgsVer2.sol\ncontract CloneBase {\n    fallback() external payable {\n        address logic = ImmutableArgsVer2Lib.getLogicAddress();\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n\n            let success := delegatecall(gas(), logic, 0, calldatasize(), 0, 0)\n\n            returndatacopy(0, 0, returndatasize())\n\n            if success {\n                return(0, returndatasize())\n            }\n\n            revert(0, returndatasize())\n        }\n    }\n}\n\ncontract ClonesWithImmutableArgsVer2 {\n    constructor(address logic, bytes memory immutableArgs) payable {\n        bytes memory code = abi.encodePacked(\n            type(CloneBase).runtimeCode,\n            immutableArgs,\n            uint16(immutableArgs.length),\n            logic\n        );\n\n        assembly {\n            return(add(code, 0x20), mload(code))\n        }\n    }\n}\n```\n\nThe delegatecall logic in the fallback function remains the same, except that we are now reading the address of the logic contract using a library function `ImmutableArgsVer2Lib.getLogicAddress()` - which we'll get into in a bit. \n \nOut goal is to append additional data - the immutable args - to the contract bytecode so that we can cheaply access these later. \n`ClonesWithImmutableArgsVer2` acts as a kind of \"wrapper\" contract that returns the code of the underlying contract - `CloneBase` - with additional data appended - the immutable args, the length of the immutable args and the logic contract. \n\nSince we're accessing `type(CloneBase).runtimeCode` we need to avoid any `immutable` keywords, because these would not be available in the runtime code. That's why we also append the `logic` address to the contract code to be able to access this in the fallback function of the clone.\n\nWe now need to write the functions that will make it possible to retrieve `address logic` and `bytes immutableArgs` from the contract code.\n\n```ImmutableArgsVer2Lib.sol\n library ImmutableArgsVer2Lib {\n    function getLogicAddress() internal returns (address logic) {\n        assembly {\n            // `address logic` is encoded into bytecode at last position.\n            // Load 20 bytes (0x14) starting from end - 20 bytes.\n            let offsetLogic := sub(codesize(), 0x14)\n            // Store in scratch space in first slot at 12 bytes (0x0c = 32 - 20) offset.\n            codecopy(0x0c, offsetLogic, 0x14)\n            // Load first memory slot to retrieve the address.\n            logic := mload(0)\n        }\n    }\n\n    function getImmutableArgs() internal returns (bytes memory args) {\n        assembly {\n            // Clear dirty scratch space.\n            mstore(0, 0)\n\n            let codeSize := extcodesize(address())\n            // The offset for the length of the args is stored\n            // at `codeSize - 20 - 2` (20 bytes address + 2 bytes length)\n            let argsLenOffset := sub(codeSize, 0x16)\n\n            // Load length of immutable args from contract bytecode.\n            extcodecopy(address(), 0x1e, argsLenOffset, 0x02)\n\n            let argsLen := mload(0)\n            let argsOffset := sub(argsLenOffset, argsLen)\n\n            // Place `args` at free memory position.\n            args := mload(0x40)\n            // Store length of `args` bytes-array.\n            mstore(args, argsLen)\n\n            // Copy immutable args to `args` memory offset.\n            extcodecopy(address(), add(args, 0x20), argsOffset, argsLen)\n\n            // Advance the `memPtr` by `argsLen + 0x20`,\n            // rounded up to the next multiple of 32.\n            mstore(0x40, shl(5, shr(5, add(add(args, argsLen), 0x3f))))\n        }\n    }\n}\n```\n\nNotice how `getLogicAddress()` uses `codecopy` and how `getImmutableArgs()` uses `extcodecopy`.\nThis is because `getLogicAddress()` will be executed in the context of the clone - meaning the address is stored in the current runtime code - whereas `getImmutableArgs()` will be executed in the context of the logic contract, which is unable to access the immutable args stored in the runtime code and thus must use `extcodecopy`.\n\n# Clones with immutable args - via `CALLDATA`\n\nThe [original clones with immutable args](https://github.com/wighawag/clones-with-immutable-args) uses another trick. The immutable args are directly appended to the calldata of the delegatecall in the clone's fallback function.\n\n`CloneWithImmutableArgsVer3`'s constructor code remains the same as `CloneWithImmutableArgsVer2`.\n\n```CloneWithImmutableArgsVer3.sol\ncontract CloneWithImmutableArgsVer3 {\n    constructor(address logic, bytes memory immutableArgs) payable {\n        bytes memory code = abi.encodePacked(\n            type(CloneBaseVer3).runtimeCode,\n            immutableArgs,\n            uint16(immutableArgs.length),\n            logic\n        );\n\n        assembly {\n            return(add(code, 0x20), mload(code))\n        }\n    }\n}\n```\n\nNow when we make the delegatecall, we need to concatenate the the following data in memory: calldata + immutable args + uint16 length of immutable args. Retrieving and copying the immutable args works exactly the same as with the previous version, except that, since we're in the clone's context, we can use `codesize` and `codecopy` instead of `extcodesize` and `extcodecopy`.\n\n```CloneWithImmutableArgsVer3.sol\ncontract CloneBaseVer3 {\n    fallback() external payable {\n        address logic = ImmutableArgsVer2Lib.getLogicAddress();\n\n        assembly {\n            // Clear dirty scratch space.\n            mstore(0, 0)\n\n            // Get length and offset of immutable args.\n            let argsLenOffset := sub(codesize(), 0x16)\n            codecopy(0x1e, argsLenOffset, 0x02)\n\n            let argsLen := mload(0)\n            let argsOffset := sub(argsLenOffset, argsLen)\n\n            calldatacopy(0, 0, calldatasize())\n\n            // Copy immutable args to end of calldata in memory.\n            codecopy(calldatasize(), argsOffset, argsLen)\n            // Append the length of the immutable args to the end.\n            mstore8(add(calldatasize(), argsLen), shr(8, argsLen))\n            mstore8(add(add(calldatasize(), argsLen), 1), argsLen)\n\n            let success := delegatecall(gas(), logic, 0, add(add(calldatasize(), argsLen), 2), 0, 0)\n\n            returndatacopy(0, 0, returndatasize())\n\n            if success {\n                return(0, returndatasize())\n            }\n\n            revert(0, returndatasize())        \n        }\n    }\n}\n```\n\nNow the implementation contract will have direct access to the immutable args via calldata. This part is left out, because it works in pretty much the same way as retrieving immutable args from the contract code.\n\nThis method has the benefit that it doesn't need to make another external call or copy external code (since it uses `codecopy` instead). \nAccessing the immutable args via calldata is cheap and almost practically negligible - except for when this is run on rollups that commit calldata to the root chain (here calldata makes up for over 50% of the transaction cost). Yet, unlike before, where we only access the immutable args when needed, these are always appended to any function call - no matter if they are required or not.\n\n\n# Tradeoffs and Gas Comparisons\n\nThe full code for all comparisons can be found here https://github.com/0xPhaze/clones-with-immutable-args-comparison (though method 1 and method 3 are swapped here).\nThe clone implementations are written in pure bytecode to better understand the limits.\nThe methods that use `codecopy` could however, still be further optimized to not use `codecopy` at all, but to loop over `push` opcodes that push the data directly onto the stack and store it in memory.\n\n|  | Relevant Opcodes | Notes |\n|:--:  | :--: | :--: \n| Method 1 | `call` + `codecopy` | Calls back into clone contract to retrieve immutable arg. |\n| Method 2 | `extcodecopy` | Loads external code from clone contract. |\n| Method 3 | `codecopy` + `calldataload` | Adds a gas overhead to EVERY function call |\n\nI ran multiple tests and plotted the results to get a better feel for the behavior of the gas costs. Below is a comparison between method 2 and method 3. Method 1 was left out, as it behaved much like method 2, but slightly worse.\n\n![gas-cost-comparison](/data/blog/2022/clones-with-immutable-args-comparison/gas-cost-comparison.png)\n\nThe plot shows the gas costs for reading x bytes from the immutable args from immutable args with varying lengths. In most cases, using method 3, i.e. reading args from calldata will be cheaper. Using `extcodecopy` (method 2) becomes cheaper after a certain amount of bytes (1.5k-2k).\n\nThe aforementioned gas overhead (for method 3) can be seen for the purple line - reading 0 bytes is the overhead added to any other call that does not need to read immutable bytes. Here, method 2 is cheaper and stays pretty much constant, while it increases linearly with the length of the stored immutable args for method 3 - when the args are appended to the calldata.","title":"Clones With Immutable Args","suptitle":"Gas Comparisons","date":"Oct 23, 2022","excerpt":"Clones with immutable args aim to save gas by avoiding storage reads and writes."},{"slug":"blog/2022/abi-decoding-calldata","contentRaw":"\n`abi.decode(data, (type))` can be used to decode abi-encoded bytes located in memory and calldata. Currently, it's only possible to assign dynamic types to memory. Decoding to calldata is not supported yet, however, this can still be achieved manually.\n\nSay we wanted to send a NFT cross-chain. For this we have have to encode a message that could look like this.\n\n```FxERC721Root.sol\nbytes4 constant REGISTER_ERC721_IDS_SELECTOR = \n    bytes4(keccak256(\"registerERC721IdsWithChild(address,uint256[])\"));\n\n    function _registerERC721IdsWithChild(address to, uint256[] calldata ids) internal virtual {\n        bytes memory message = abi.encodeWithSelector(REGISTER_ERC721_IDS_SELECTOR, to, ids); // highlight-line\n\n        _sendMessageToChild(message);\n    }\n```\n\nThe child chain can receive the full message as `calldata`, run some security checks and then process it in another function.\n\n\n```FxERC721Child.sol\n    function processMessageFromRoot(\n        uint256 stateId,\n        address rootMessageSender,\n        bytes calldata message // highlight-line\n    ) external {\n        if (msg.sender != fxChild) revert CallerNotFxChild();\n        if (rootMessageSender == address(0) || rootMessageSender != s().fxRootTunnel) revert InvalidRootSender();\n\n        _processMessageFromRoot(stateId, rootMessageSender, message);\n    }\n```\n\nSolidity does not allow us to decode the ids as a `uint256[] calldata` array directly yet. I.e. the following \n```solidity\n    (address to, uint256[] calldata ids) = abi.decode(message[4:], (address, uint256[]));\n```\nwould fail with the message:\n`\"TypeError: Type uint256[] memory is not implicitly convertible to expected type uint256[] calldata.\"`\n\nHowever, by declaring `uint256[] calldata ids;` and manually setting `ids.offset` and `ids.length` via assembly, we can manually decode the data.\nFor more on the abi encoding spec, read up on the [docs](https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#argument-encoding).\n\n```FxERC721Child.sol\n    function _processMessageFromRoot(\n        uint256,\n        address,\n        bytes calldata message\n    ) internal virtual override {\n        bytes4 selector = bytes4(message);\n\n        if (selector != REGISTER_ERC721_IDS_SELECTOR) revert InvalidSelector();\n\n        address to = address(uint160(uint256(bytes32(message[4:36]))));\n\n        uint256[] calldata ids;\n        // abi-decode `ids` directly in calldata.\n        assembly {\n            // Skip bytes4 selector + bytes32 encoded address\n            // starting from message's offset in calldata\n            // to get the relative offset of the uint256[] encoded array's size.\n            let idsLenOffset := add(add(message.offset, 0x04), calldataload(add(message.offset, 0x24)))\n            ids.length := calldataload(idsLenOffset)\n            ids.offset := add(idsLenOffset, 0x20)\n        }\n\n        _registerIds(to, ids);\n    }\n\n    function _registerIds(address to, uint256[] calldata ids) internal virtual {\n        for (uint256 i; i \u003c ids.length; ++i) {\n            _registerId(to, ids[i]);\n        }\n    }\n```\n\nHere's an example of a call to the function `processMessageFromRoot()`.\n\n```sol\n    child.processMessageFromRoot(\n        1,\n        address(this),\n        abi.encodeWithSelector(REGISTER_ERC721_IDS_SELECTOR, address(0xbabe), 31.range(34))\n    );\n```\n\nIn this case, the calldata would look like this.\n\n```sol\n  [selector] 0x9a7c4b71 // processMessageFromRoot.selector\n  [0x00] 0000000000000000000000000000000000000000000000000000000000000001 // stateId\n  [0x20] 000000000000000000000000b4c79dab8f259c7aee6e5b2aa729821864227e84 // rootMessageSender\n  [0x40] 0000000000000000000000000000000000000000000000000000000000000060 // message.length offset\n  [0x60] 00000000000000000000000000000000000000000000000000000000000000c4 // message.length\n  [0x80] 4d26d408000000000000000000000000000000000000000000000000000000000000babe00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000001f0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002100000000000000000000000000000000000000000000000000000000 // encoded message\n```\n\n\u003e Note: Even though the message length is located at message[0x64:0x84] the offset (of message.length) is set to 0x60, since the selector is not counted.\n\nBecause the message is abi-encoded separately, the offsets in the encoded bytes are relative to the start of the message after the selector.\n\n```sol\n  [selector] 0x4d26d408 // REGISTER_ERC721_IDS_SELECTOR\n  [0x00] 000000000000000000000000000000000000000000000000000000000000babe // address to\n  [0x20] 0000000000000000000000000000000000000000000000000000000000000040 // ids.length relative offset\n  [0x40] 0000000000000000000000000000000000000000000000000000000000000003 // ids.length\n  [0x60] 000000000000000000000000000000000000000000000000000000000000001f // ids[0]\n  [0x80] 0000000000000000000000000000000000000000000000000000000000000020 // ids[1]\n  [0xa0] 0000000000000000000000000000000000000000000000000000000000000021 // ids[2]\n  [0xc0] 00000000000000000000000000000000000000000000000000000000 // padded zeros\n```\n\nThis means that, if we want to get the correct calldata offset for `ids.offset`, we need\nto load the word located at 0x20 in the encoded message. In order to get the absolute position in the calldata, we thus need to add the offset of the message in the calldata to 0x24 - the 4 bytes selector from the message must be taken into account, since the message is embedded into the calldata as bytes.\n\n```sol\n    let idsOffsetRel := calldataload(add(message.offset, 0x24))\n```\n\nNow to get the absolute offset of `ids.length` we need to add the position of where the relative offset in the message starts: `message.offset + 0x04` - the starting location of the message + the encoded selector.\n\n```sol\n    let idsLenOffset := add(add(message.offset, 0x04), idsOffsetRel)\n```\n\nNow that we have the offset of the length, we just need to load it from the calldata. By looking at the encoding we can also see that we simply need to add one word (0x20) to find the start of the `uint256[]` data - `ids.offset`.\n\n```sol\n    ids.length := calldataload(idsLenOffset)\n    ids.offset := add(idsLenOffset, 0x20)\n```\n\n## Why not just hardcode the offset?\n\nWe could also simply hardcode the values for `ids.length` and `ids.offset` after we have calculated them once. \n\n```sol\n    ids.offset := 0xe8\n    ids.length := calldataload(sub(ids.offset, 0x20))\n```\n\nThis works as long as the function signature won't change (so that the offset of `message` doesn't change) and the calldata is encoded in a standard way.\n\nWe can create a non-standard encoding by adding useless filler data for example and we quickly see why the hardcoded version will not work anymore.\n\n```sol\n    address(child).call(\n        hex\"9a7c4b71\"                                                         // processMessageFromRoot.selector\n        hex\"0000000000000000000000000000000000000000000000000000000000000001\" // stateId\n        hex\"000000000000000000000000b4c79dab8f259c7aee6e5b2aa729821864227e84\" // rootMessageSender\n        hex\"0000000000000000000000000000000000000000000000000000000000000080\" // message.length offset\n        hex\"ccaaffeeccaaffeeccaaffeeccaaffeeccaaffeeccaaffeeccaaffeeccaaffee\" // ??\n        hex\"00000000000000000000000000000000000000000000000000000000000000e4\" // message.length\n        hex\"4d26d408\"                                                         // REGISTER_ERC721_IDS_SELECTOR\n        hex\"000000000000000000000000000000000000000000000000000000000000babe\" // address to\n        hex\"0000000000000000000000000000000000000000000000000000000000000060\" // ids.length relative offset\n        hex\"ccaaffeeccaaffeeccaaffeeccaaffeeccaaffeeccaaffeeccaaffeeccaaffee\" // ??\n        hex\"0000000000000000000000000000000000000000000000000000000000000003\" // ids.length\n        hex\"000000000000000000000000000000000000000000000000000000000000001f\" // ids[0]\n        hex\"0000000000000000000000000000000000000000000000000000000000000020\" // ids[1]\n        hex\"0000000000000000000000000000000000000000000000000000000000000021\" // ids[2]\n        hex\"00000000000000000000000000000000000000000000000000000000\"         // padded zeros\n    );\n```\n\nWithout hardcoding the offsets, reading the `uint256[] calldata` from the above encoding will still be possible.\n\n\n\n\n# Gas Savings\n\nAbi-decoding directly to calldata can avoid copying data to memory.\nThis saves us a few `mstore` and `mload` operations.\nBelow is a comparison of the gas savings for encoding a certain number of ids.\n\n\n| #ids | Calldata | Memory | Difference |\n| --- | --- | --- | ---- |\n| 0 | 1125 |1552 | 427 |\n| 1 | 2271 |2775 | 504 |\n| 2 | 3197 |3781 | 584 |\n| 3 | 4126 |4790 | 664 |\n| 4 | 5050 |5794 | 744 |\n| 5 | 5977 |6801 | 824 |\n| 6 | 6904 |7809 | 905 |\n| 7 | 7835 |8820 | 985 |\n| 8 | 8760 |9825 | 1065 |\n| 9 | 9694 |10839 | 1145 |\n\n\nIn this case, using calldata over memory can save us 427 gas + roughly an additional 80 gas per extra word.","title":"ABI-Decoding Calldata","date":"Oct 22, 2022","excerpt":"Abi-decode directly in calldata without using memory."},{"slug":"audit/2022/haki-audit","contentRaw":"\n\n# Table of Contents\n\n# Context\n\nThe audit was performed as a \"non-extensive review\".\nThis means that solely the code is reviewed as is\nand no further tests have been prepared for this review.\nUnit-tests are essential for ensuring correct behavior and calculations.\n\nThis audit is a review of the [Haki staking contracts](https://github.com/rekttdoteth/haki-staking-contract)\n(private)\nand was performed at commit\n[77865daafe1311dd45ad29bb8087f55fdc660c54](https://github.com/rekttdoteth/haki-staking-contract/commit/77865daafe1311dd45ad29bb8087f55fdc660c54).\n\nThe given repository itself contains no tests.\n\n**Focus:**\n\nGas optimizations (specifically storage accesses) \non `TheShrine.sol` (to be deployed on Ethereum) are highlighted, whereas they are largely ignored for `ShrineToken.sol` (to be deployed on Polygon).\n\nSpecial attention was given to unauthorized access-control and exploitability. Logical errors were covered as best as possible,\nalthough these require extensive unit-testing to cover appropriately.\n\n# Overview\n\nThe client has designed contracts that allow for staking of ERC721 NFTs.\nWhile the staking itself will be performed on Ethereum, \nstaking rewards are emitted as ERC20 tokens on Polygon.\nThe communication between the chains is done using Polygon's \n[flexible portal contracts](https://github.com/fx-portal/contracts).\nStaking on Ethereum is handled by\n`TheShrine.sol` which is designed to be able to handle multiple ERC721 contracts.\n`ShrineToken.sol` is an ERC20 token on Polygon that contains logic\nto handle state updates from the root contract `TheShrine.sol`.\n`SekiraVerifier.sol` acts as a simple \"proxy\" that allows counting owned and staked NFT balances for the _Sekira_ contract.\n\n\n# Scope\n\nThe repository contains the following contracts\n```ml\n└── contracts\n    ├── ERC20.sol\n    ├── ExitPayloadReader.sol\n    ├── FxBaseChildTunnel.sol\n    ├── FxBaseRootTunnel.sol\n    ├── Merkle.sol\n    ├── MerklePatriciaProof.sol\n    ├── RLPReader.sol\n    ├── SekiraVerifier.sol\n    ├── ShrineToken.sol\n    └── TheShrine.sol\n```\n\nAs a basis for the ERC20 contract, `ShrineToken.sol` uses Rari-Capital solmate's [ERC20 implementation](https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol) `ERC20.sol`.\nNo noteworthy differences to the [latest commit](https://github.com/Rari-Capital/solmate/commit/25015a1d18e75921f8cb1bacd4beb9f364e788a9) exist.\n\nPolygon's [flexible portal contracts](https://github.com/fx-portal/contracts)\nare being used for message passing between Ethereum and Polygon.\nNo noteworthy differences to the [latest commit](https://github.com/fx-portal/contracts/commit/baed24d22178201bca33140c303e0925661ec0ac) exist.\n\nThese external contracts are out of scope.\nThe focus of the review is narrowed down to the following contracts.\n\n```ml\n└── contracts\n    ├── SekiraVerifier.sol\n    ├── ShrineToken.sol\n    └── TheShrine.sol\n```\n\n# Summary\n\nNo critical errors were identified.\n\nThe contracts could benefit from simplification\nto reduce complexity, computation and storage access.\nFurthermore, although not explicitly detailed,\nrepetition of contract logic/functions can be avoided.\nThis would also help validate logic and improve readability.\nIt is further noted that the use of custom errors vs. require-statements could chosen consistently and docstring comments could be standardized.\n\n# Audit Findings Classifications\n\n# Medium Findings\n\n## :zap: [ShrineToken.sol] State-Desync Possible\n\nCurrently `ShrineToken.sol` gets relative balance updates from the root contract `TheShrine.sol` on Ethereum.\nA complete synchronization between the two chains is not guaranteed and incoming tokens are not validated to be uniquely counted in \n`userInfo.stakedBalance` and `userInfo.stakedIds`. \n\nSetting the child contract `ShrineToken.sol` to be paused\nwould lead to failed transactions and a state-desync when `_processMessageFromRoot` is called.\nThis would mean that, for example, unstaking on Ethereum L1\nwould not be updated on L2.\n\nThe results of this effect, however, are minimized due to the way \nrewards are being calculated.\nWhen claiming rewards, the ids found in `userInfo.stakedIds`\nare iterated over and the reward is calculated based on the\n`record` found for each individual id. The individual id is immediately \"marked\" as claimed by updating `stakeRecord.lastClaimed`.\n\nThis does, however, still mean that it could be possible for a user to claim\nrewards for an NFT no longer owned, even if it is currently being\nstaked by someone else. Additionally, this could lead to a higher `multipleStakedBoostThreshold`.\n\n**Mitigation:**\nNew token ids being registered in the `ShrineToken` contract could\ncheck whether they are currently still attributed to someone else\nin the system. If they are, they should be removed from that user's\nbalance/stake.\n\n\n## :zap: [TheShrine.sol] Hardcoded Testnet Address \n\n```TheShrine.sol\n    function balanceOf(address owner) external view returns (uint256) {\n        address hakiContract = 0xd053b4FdbC3470E6aAF9f65ED13AFDaA5af0d7E5; //highlight-line\n        return\n            addressToContractStakedIds[owner][hakiContract].length +\n            ERC721(hakiContract).balanceOf(owner);\n    }\n```\n\n`TheShrine.sol` contains a hardcoded `address hakiContract` which does not correspond to `address hakiERC721` of the constructor. This address currently only contains code on test-nets.\n\n**Mitigation:**\nUpdate address pointing to the correct ERC721 contract on Ethereum or declare a variable that is set\nby the constructor parameter.\n\n**Update:**\nThe client has responded that this address will be updated accordingly.\n\n\n# Minor Findings\n\n## :zap: [FxBaseRootTunnel.sol] Unprotected Function\n\n_Note: Originally declared as out of scope._\n\n```FxBaseRootTunnel.sol\n    function setFxChildTunnel(address _fxChildTunnel) public virtual { //highlight-line\n        require(fxChildTunnel == address(0x0), \"FxBaseRootTunnel: CHILD_TUNNEL_ALREADY_SET\");\n        fxChildTunnel = _fxChildTunnel;\n    }\n```\n\n`setFxChildTunnel` does not contain any access-control. Anyone is able to call this function. Although, once set, it cannot be changed due to the contract logic. Any malicious address is able to call this and essentially void the full contract if accidentally left unset.\nThis generally should be seen as bad practice, even if introduced by the Matic-Team.\n\n**Mitigation:**\nOverride function in inheriting contract `TheShrine.sol` and add the `onlyOwner` modifier.\nA check for whether it has been set already is not strictly necessary, otherwise this could be marked as immutable, furthermore ensuring that it is set and reducing gas costs.\n\n```TheShrine.sol\n    function setFxChildTunnel(address _fxChildTunnel) public override onlyOwner { //highlight-line\n        fxChildTunnel = _fxChildTunnel;\n    }\n```\n\n_Note:_\nThe same holds for `setFxRootTunnel` in `FxBaseChildTunnel.sol`.\n\n\n## :recycle: [ShrineToken.sol] Reduce Use of Permits\n\n`gaslessHarvest` and `gaslessHarvestByNFT` allow an authorized party\nto distribute pending rewards to a user.\nThese function are currently guarded by the `onlyHarvester` modifier\nonly allowing calls by previously authorized accounts.\n\n**Mitigation:**\nSince `_harvestReward` does not contain any security-critical\nlogic, this extra authorization could be foregone to increase simplicity.\n\n\n## :recycle: [ShrineToken.sol] Reduce Logic for Tracking Staked Contracts\n\n`_processMessageFromRoot` keeps track contracts a user\nhas any staked balances separately through the use of an 'enumerable set'\nstructure. This is done via the mapping `addressToContractIndex`\nthat keeps track of multiple values, including an index to `userInfo.stakedContract`. There are multiple variables that are being tracked\nthat could be redundant.\n\n\n**Mitigation:**\nTo reduce complexity, `addressToContractIndex` and `userInfo.stakedContract` could be removed and logic could be simplified:\nInstead of iterating over the `userInfo.stakedContract` array,\nlooping over both contracts and checking `userInfo.stakedIds[collection].length` would reduce complexity.\n\nA lot of the \"messy\" logic for enumerable sets can be hidden by using\ntrusted libraries, like [OpenZeppelin's Enumerable Set](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol).\n\n## :recycle: [TheShrine.sol] Nearly Identical Logic\n\n`stake` \u0026 `stakeMultiple` (and `unstake` \u0026 `unstakeMultiple`) largely contain the same code.\nThere is very little gas overhead involved when simply using `stakeMultiple`, `unstakeMultiple`,\nas these would likely involve only a few more stack-operations.\nRemoving duplicate code, reduces maintenance work and \nsimplifies interfacing the contract on a frontend\ndue to multiple choices of functions being considered.\n\n**Mitigation:**\nConsider removing `stake` and `unstake` functions.\n\n## :recycle: [TheShrine.sol] Reduce External Calls\n\n`_sendMessageToChild` is being called in a loop requiring multiple external calls (\u0026 memory accesses, event emissions).\n\n**Mitigation:**\nConsider directly encoding an array of token ids thus only requiring one message to be sent.\n\n```TheShrine.sol\n    _sendMessageToChild(\n        abi.encode(\n            msg.sender,\n            collection,\n            tokenIds[i], //del-line\n            tokenIds, //add-line\n            lockupDelta,\n            true\n        )\n    );\n```\n\n## :recycle: [TheShrine.sol] Optimize Storage Reads/Writes\n\nCurrently `TheShrine.sol` keeps track of token ownerships through the use of 3 mappings:\n- `contractToTokenStaker` (tracks token ownership)\n- `addressToContractStakedIds` (enumerable list of ids per user)\n- `contractToTokenIndex` (tracks indices in enumerable list)\n\nThis is comparable to `ERC721Enumerable` vs. `ERC721` (logic-wise and storage cost-wise). Reducing these mappings to one would simplify logic\nand lower gas costs.\n\n**Mitigation:**\nThe contract could simply track `contractToTokenStaker` (token ownerships) and balances.\n\n*Note:*\nBecause `contractToTokenIndex` is a mapping to a list, keeping track of ownerships\nin the `stake` function update involves 4 distinct storage slots,\nwhereas, if optimized, it would only involve one.\nThis would also remove the complexity of keeping track of and re-arranging indices.\n\n*Further Note:*\nBecause `contractToTokenIndex` and `unlockOn` share the same mapping keys, these\ncould further be combined into one packed storage slot instead of taking up 2 separate slots.\n\n\n\n## :recycle: [SekiraVerifier.sol] Remove Unused Logic\n\n`SekiraVerifier.sol`'s code size can be significantly reduced. This contract acts as a simple proxy that propagates owned balances and staked balances of the _Sekira_ ERC721. It does not require any of the existing ERC721 logic, as it is never expected to be called (there exists no logic for minting tokens).\nThe only function that is necessary (for collab.land) is `balanceOf`.\n\n**Mitigation:**\nConsider removing the ERC721 logic in order to save gas costs for deployment.\n\n**Update:**\nThe client has noted that they will be using *Whop* which requires some additional logic.\n\n\n## ️️:recycle: [FxBaseRootTunnel.sol] Make Non-Changing Variables Immutable\n\n_Note: Originally declared as out of scope._\n\n```FxBaseRootTunnel.sol\n    // state sender contract\n    IFxStateSender public fxRoot; //delete-line\n    IFxStateSender public immutable fxRoot; //add-line\n    // root chain manager\n    ICheckpointManager public checkpointManager; //delete-line\n    ICheckpointManager public immutable checkpointManager; //add-line\n    // child tunnel contract which receives and sends messages\n    address public fxChildTunnel;\n```\n`IFxStateSender fxRoot` and `ICheckpointManager checkpointManager`\nare declared as storage variables that do not contain logic to be changed/updated in any form.\n\n**Mitigation:**\nThese variables can be declared _immutable_ saving roughly 4200 gas.\n\n_Note_: `address fxChildTunnel` is not part of the constructor variables, as it requires the address of the child contract on Polygon to be set.\nIt is, however, possible to first deploy the child contract or to\npre-compute the address. This way `fxChildTunnel` could also be declared\n_immutable_ saving a total of 6300 gas.\n\n\n# Audit Disclaimer","title":"Haki/Sekira Contract Audit","date":"Jun 21, 2022"},{"slug":"blog/2022/crypto-hashing-functions","contentRaw":"\nUpdate: Added gas savings comparison.\n\n## Table of contents\n\n\nSecure hashing functions are pretty cool.\nSome of the properties of [cryptographic hashing functions](https://en.wikipedia.org/wiki/Cryptographic_hash_function) are:\n\n- **deterministic output** (the same input yields the same output)\n- **pre-image resistance** (given $y$, it's infeasible to find an input $x$, s.t. $y = hash(x)$)\n- **second pre-image resistance** (given $x_1$, it's infeasible to find an input $x_2$ , s.t. $hash(x_1) = hash(x_2)$)\n- **collision-resistance** (it's infeasible to find two inputs $x_1$, $x_2$ s.t. $hash(x_1) = hash(x_2)$)\n\nThe deterministic property and the second pre-image resistance is what makes them pretty cool to use for designing smart contracts.\n\n## Building a Marketplace Contract\n\nFor Mad Mouse Circus I built a [Marketplace Contract](https://github.com/0xPhaze/Gachapon/blob/gachapon/src/Marketplace.sol).\nThe idea behind this market place contract was designed to let users purchase off-chain items, such as whitelist entries or merch.\n\nThe main reason for including a smart contract in the whole process is to a) ensure that the correct amount of tokens is burned/transferred and\nb) that we don't end up over-allocating and selling too many items.\nWe can also impose further restrictions such as a valid time-window and a maximum number of purchases per user.\n\nA naive implementation would require an _ownable_ contract and adding market items\nto some kind of list with all their info (presumably defined in a MarketItem struct).\nThis however, requires the owner to make on-chain transactions for every new item to be listed.\nAnd users will have to load an items information from the contract storage when making a purchase to ensure that all requirements are fulfilled.\n\nAnother way of handling things is by letting the user input all of the items information and requirements for us (calldata is cheap) and making use of some of the cryptographic hash function's properties.\nNamely, the **deterministic output** and the **second pre-image resistance**.\n\n```Marketplace.sol\ncontract Marketplace {\n    event PurchaseItem(address indexed user, bytes32 indexed id);\n\n    mapping(bytes32 =\u003e uint256) public marketItemSupply;\n    mapping(bytes32 =\u003e mapping(address =\u003e uint256)) public marketItemPurchases;\n\n    function purchaseMarketItem(\n        uint256 start,\n        uint256 end,\n        uint256 price,\n        uint256 maxPurchases,\n        uint256 maxSupply\n    ) external {\n        bytes32 hash = keccak256(abi.encode(start, end, price, maxPurchases, maxSupply)); // highlight-line\n\n        if (block.timestamp \u003c start || end \u003c block.timestamp) revert NotActive(); // highlight-line\n        if (++marketItemSupply[hash] \u003e maxSupply) revert NoWhitelistRemaining(); // highlight-line\n        if (++marketItemPurchases[hash][msg.sender] \u003e maxPurchases) revert MaxPurchasesReached(); // highlight-line\n\n        token.burnFrom(msg.sender, price);\n        emit PurchaseItem(msg.sender, hash);\n    }\n}\n```\n\nAll the item's properties (price, supply) are directly input by the user as parameters to the function call.\nNow you may ask yourself whether it is unsafe to require certain conditions that are provided by the user. What stops a user from simply bypassing the frontend and directly modifying any of the function arguments?. Well.. nothing.\n\nNothing will stop them from taking an existing item's information and increasing the supply, for example.\nEach market item is, however, uniquely identified by a `bytes32` hash deterministically generated from all of the function's inputs (assuming unique inputs for every item).\nIf any of the inputs is change, so will the hash identifier and the malicious user ends up purchasing a non-existent item.\nThrough the use of a secure hashing function we are (almost) guaranteed that different inputs will result in different outputs.\n\n## Gas Savings\n\nBelow is a table of how much gas it would cost to run `abi.encode` and `keccak256` with the number of `uint256` parameters.\nAlongside is also the storage load costs for reading those amount of `uint256`s from storage (these could be packed if less bytes are needed).\n\n| # of inputs | keccak256 gas cost | sload gas cost |\n| ----------- | ------------------ | -------------- |\n| 1           | 79                 | 2100           |\n| 2           | 91                 | 4200           |\n| 3           | 112                | 6300           |\n| 4           | 133                | 8400           |\n| 5           | 154                | 10500          |\n\nUsing keccak256 does indeed save a lot of gas compared to naively storing data that needs to be used for validation in the contract.\n\n## Frontend Interaction\n\nThe result of implementing the contract in this way is the owner can simply list a new\nmarket item on their website with the desired properties without having to interact with\nthe smart contract.\n\nOn the frontend we can fetch valuable information to the user,\nsuch as the remaining supply by accessing `marketItemSupply[hash]`\nand how many items the user has purchased through `marketItemPurchases[hash][user]`.\nIf we don't care about limiting the amount of purchases per wallet address we can even get rid of this last variable.\n\nIn order to fetch the list of users who have purchased an item, we can query past events. This would look somewhat like this.\n\n```js\nconst hash = ethers.utils.keccak256(\n  ethers.utils.defaultAbiCoder.encode(\n    [\"uint256\", \"uint256\", \"uint256\", \"uint256\", \"uint256\"],\n    [start, end, price, maxPurchases, maxSupply]\n  )\n);\nconst filter = marketplace.filters.PurchaseItem(null, hash);\nconst blockNumber = await provider.getBlockNumber();\nconst purchases = await marketplace.queryFilter(filter, blockNumber - 5000, blockNumber);\n```\n\n(Providers often have a limit of 5000 blocks, we can however query multiple times in a loop until a desired timestamp or have a backend-server listening to events).\n\nThis same idea can be taken further for handling on-chain items.\n\n## Permits for On-Chain Items\n\nTake the [on-chain raffling system](https://github.com/0xPhaze/Gachapon/blob/gachapon/src/Gachapon.sol) for example. Here users are able to win prize NFTs in a raffle if they are one of the lucky winners. The current implementation requires the owner to make an on-chain transaction for every new raffle. And when a user buys a raffle ticket, they provide an id to the raffle they want to participate in. The data is then loaded from the chain and validated.\n\nInstead of making the user pay for costly storage loads (and the owner with storage writes) we could apply the same idea from before.\n\nAlthough, compared to before, we have to take extra care and since we do not want to accept arbitrary user input that could lead to unwanted behavior. For example, they could make up a raffle (with a ticket supply of 1 and a prize NFT that was meant for another raffle), which they could immediately win.\n\nThis case can be guarded against by using permits/signatures. We can simply hash the information just as before, but now also let the user provide a signature that will be validated on-chain to prove that all the information given was indeed authorized by the owner (OpenSea's order book works in a very similar way; listing an item does not cost the owner a transaction).\n\nA simpler application than an orderbook is sometimes seen when validating users for **whitelisted ERC721 mints**.\n\n```MyNFT.sol\ncontract MyNFT is ERC721A, Ownable {\n\n    ...\n\n    address public signerAddress = address(0xb0b);\n\n    function whitelistMint(\n        uint256 amount,\n        uint256 limit,  // highlight-line\n        bytes calldata permit\n    ) external payable {\n        uint256 numMinted = numMinted(msg.sender);\n\n        if (numMinted + amount \u003e limit) revert ExceedsLimit();  // highlight-line\n        if (!validSignature(permit, limit)) revert InvalidSignature();// highlight-line\n        if (msg.value != whitelistPrice * amount) revert IncorrectValue();\n\n        _mint(msg.sender, amount);\n    }\n\n    function validSignature(bytes calldata permit, uint256 limit) private view returns (bool) {\n        bytes32 msgHash = keccak256(abi.encode(address(this), msg.sender, limit));\n        return msgHash.toEthSignedMessageHash().recover(permit) == signerAddress;\n    }\n}\n```\n\nHere as well, the actual `limit` (restricting how many NFTs a certain wallet is able to mint), as well as the permit is being provided by the user. This information (the user and their limit) is hashed, signed and validated on-chain. If the `limit` is tampered with, the hash would change and the recovered signer would become invalid.\n","title":"Cryptographic Hashing Functions","suptitle":"for Gas Savings","date":"May 12, 2022","excerpt":"Using secure hashing functions allows you to save on gas by passing information as call data instead of reading it from the chain."},{"slug":"unpublished/rsa","contentRaw":"\n*Notes taken from the [RSA paper](https://people.csail.mit.edu/rivest/Rsapaper.pdf)*.\n\n## Table of Contents\n\n## RSA\n\n$$\ndec(enc(M)) = M\n$$\n\n\nA *trap-door one-way function* allows a message $M$ to be encrypted as cyphertext $C$\ngiven a public (known) key / encryption method ($enc$).\n$C$ is only able to be deciphered in a reasonable time if the private key ($dec$) is known.\n\nFirst, assume that $M$ can be represented as an integer $\\in [0, n-1]$ (if not, break it into blocks).\nEncrypting/Decrypting $M$ with the public key ($e$, $n$) $\\in \\mathbb N^+$ works by:\n\n### Encrypting $M$\n$$\nC = enc(M) = M ^e \\quad (\\text {mod} \\; n)\n$$\n\n### Decrypting $C$\n$$\ndec(C) = C ^d \\quad (\\text {mod} \\; n)\n$$\n\n### Steps\n| Steps                                      | Variables                   |\n| ------------------------------------------ | --------------------------- |\n| find $p$ and $q$ two large prime numbers   | $p$, $q$ prime              |\n| calculate $n=pq$                           | $n = pq$                    |\n| calculate $\\phi (n) = (p - 1)(q - 1)$      | $\\phi (n) = (p - 1)(q - 1)$ |\n| pick $e$ relatively prime to $\\phi (n)$    | $e$                         |\n| pick $d$ mul inverse of $e$ mod $\\phi (n)$ | $d$                         |\n\nTo use RSA, one must find $p$ and $q$, two very large, random prime numbers.\n\nTheorem states\n\nThe security of the scheme relies on the fact that it is computationally infeasible to derive $p$ and $q$ from $n$.\n\n*Public key*: $[e, n]$\n*Private key*: $[d, n]$\n\n\n## Why does this work?\n\n$$\ndec(enc(M)) = (M^e)^d = M ^{ed} \\quad (\\text {mod} \\; n)\n$$\n\nWe would like to show that $M^{ed} \\; (\\text {mod} \\; n) \\overset ! = M$.\nWe know that $e$ and $d$ are multiplicative inverses ($\\text {mod} \\; \\phi (n)$):\n$$\ned \\equiv 1 \\quad (\\text{mod} \\; \\phi (n))\n$$\n\nThis means that there exists some $k \\in \\mathbb N^+$ s.t.\n$$\ned = k \\phi(n) + 1\n$$\n\nThis leads us to\n$$\n\\begin{equation}\n\\begin{align*}\nM^{ed} = M^{k \\phi(n) + 1} \n\u0026= M^{k (p - 1)(q -1 ) + 1} \\\\\n\u0026= M(M^{k(q - 1)})^{(p - 1)}\n\\end{align*}\n\\end{equation}\n$$\n\n\n### Fermat's little theoreom\n\n[Fermat's little theoreom](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem) states that \n$$\na^p \\equiv a \\quad (\\text {mod} \\; p)\n$$\nfor any integer $a$ and prime $p$.\n\nIf $a \\not\\equiv 0 \\ (\\text {mod} \\; p)$, then\n$$\na^{(p - 1)} \\equiv 1 \\quad (\\text {mod} \\; p)\n$$\n\nUsing Fermat's little theorem in equation $(1)$, we can conclude that\n\n$$\n\\begin{align*}\nM^{ed} \n\u0026= M(M^{k(q - 1)})^{(p - 1)} \\\\\n\u0026\\equiv M \\quad (\\text{mod} \\; p)\n\\end{align*}\n$$\n\nUsing the same logic, we can show that \n\n$$\nM^{ed} \\equiv M \\quad (\\text{mod} \\; q)\n$$\n\n### Chinese remainder theoreom\n\nThe [Chinese remainder theorem](https://en.wikipedia.org/wiki/Chinese_remainder_theorem) (adapted to this case) states that:\n\nIf \n$x \\equiv M \\; (\\text{mod} \\; p)$\nand\n$x \\equiv M \\; (\\text{mod} \\; q)$\nfor two co-prime integers $p$, $q$\nthen\n$x \\equiv M \\; (\\text{mod} \\; pq)$\n\nUsing these two theorems, we conclude that \n$$\nM^{ed} \\equiv M \\; (\\text{mod} \\; n)\n$$\n\n\nQuestions:\n- why $\\phi$\n- Why $e$ relatively prime\n\n$$\n\\phi(n) = n \\prod _{p | n}(1 - \\frac 1 p) \n= n ( 1 - \\frac 1 p)(1 - \\frac 1 q)\n= n ( \\frac {p - 1}  p)(\\frac {q - 1} q)\n= (p - 1)(q - 1)\n$$\n\n\nhttps://eli.thegreenplace.net/2019/rsa-theory-and-implementation/","title":"RSA","date":"May 12, 2022","excerpt":"Taking a look at RSA","suptitle":"\"The era of 'electronic mail' may soon be upon us\"\n"},{"slug":"blog/2022/madmouse","contentRaw":"\nUpdate: Check out [this repo](https://github.com/0xphaze/ERC721M) for an implementation.\n\nWe've come a long way since the development on [MadMouse](https://madmousecircus.io/) started back in November.\n\nInitially, our contract was based on [ERC721A](https://www.erc721a.org/).\nWhile being extremely happy about new form of optimization that is brought to the NFT-space,\nwe immediately had [some suggestions to make](https://github.com/chiru-labs/ERC721A/issues/18).\nHowever, it quickly became clear, that because of all its features and special needs,\nthe MadMouse contract would need its own unique implementation.\n\nWhat we especially noticed was how inneficiently most staking contracts were implemented.\nWe definitely did not want to follow suit.\nThe worst thing for us would be if people had to pay\nunnecessarily high gas fees when interacting with our contracts.\nThat's why our top priority has always been to\nkeep the implementation as gas-efficient as possible,\nso not to exclude anyone from taking part in our ecosystem.\n\nTo be able to fit all of our auxilliary information into the contract\nwithout wasting extra storage slots (which ultimately are the main driver\nfor gas costs), we decided to pack all information using bitmaps.\n\nThis means that while our contract has all this extra functionality,\nthe storage costs (and thus all basic operation) remain the same as ERC721A's.\n**In fact, for some operations gas costs are even less.**\n\nStaking in batches, for example, occurs by transferring in batches while minimizing storage reads and writes.\nThere is even the possibility to mint and stake at the same time, drastically reducing costs.\nThe token data in this case is implicitly stored, just like in ERC721A.\n\n## ERC721M comparisons\n\nWhat does all this mean for the end-user?\nLet's have a look at some gas comparisons.\nFor starters, here is a comparison with [Azuki](https://www.azuki.com/garden) (the ones behind ERC721A).\n\n![azuki-comparison](/data/blog/2022/madmouse/azuki.png)\n\nERC721M still holds up to ERC721A. The comparison is based on 5 mints.\nFor all comparisons we use 100 gwei as a baseline and the first token is pre-minted.\n\nOne of ERC721M's special features is that it comes with a **'mint \u0026 stake'** functionality.\nJust recently, [Metroverse](https://metroverse.com/) launched, also with the same ability.\nAlthough their contract isn't based on ERC721A's implicit storage,\ntheir contract is still pretty optimized.\n\n![metroverse-comparison](/data/blog/2022/madmouse/metroverse.png)\n\nAgain, the data is based on a mint quantity of 5. We see that ERC721M extends the idea\nof ERC721A to allow direct staking without any overhead cost.\n**MadMouse's 'mint \u0026 stake' is about 5x cheaper than Metroverse**.\n\nWe tried hard to find a better comparison and to look for any\nimplementation that was based on ERC721A and allowed for staking.\nIn that regard, we found [WabiSabi](https://www.wabisabicollective.io/),\na collection that just launched this month.\n\n![wabisabi-comparison](/data/blog/2022/madmouse/wabisabi.png)\n\nHere, we showed what it would be like, if we didn't use the 'mint \u0026 stake' feature, but\nfirst had minted 5 NFTs and then in-turn staked those.\n\nStaking with ERC721A means that (like with a transfer), implicit token data has to be\nexplicitly set. That's why staking can seem more expensive at first.\nHowever, ERC721M still tries to optimize as much as possible under the hood.\nStaking is done similarly to a batch transfer, where state reads and writes are\nminimized as much as possible.\n**MadMouse is about 4x more efficient than Wabisabi**.\nComparing with the 'mint \u0026 stake' feature, **this turns out to be 8x as cheap**\n(not even taking into account the extra approval transaction).\n\nWabiSabi keeps track of staked token ids in a list (as seen with many other\ncollections as well). Because of this, unstaking gas costs\ncan quickly explode with higher numbers, due to the worst-case complexity being O(N^2).\n\nIf you know of any cheaper staking implementation that we could compare ours against, let us know!\n\n## What's next?\n\nSo, what's next for MadMouse? Does this become a community-standard?\nIn its current form, we had to rely on some heavy engineering work\nin order to fit in all the features while keeping costs cheap.\nMistakes are likely to happen if not handled with care.\n\nThat's why our plan is to release a simpler, lighter build in the near future\nas an ERC721A extension, so that other projects can also make use of\nan efficient staking contract.\n","title":"ERC721M","suptitle":"Staking with ERC721A","date":"Mar 21, 2022","excerpt":"The development on MadMouse began back in November. Our goal was to include a bunch of features alongside staking without compromising on gas costs."},{"slug":"blog/2022/underhanded","contentRaw":"\nI just heard about the [2022 Underhanded Solidity Contest](https://underhanded.soliditylang.org/)\nand submissions are due in a day.\n\n## About the Contest\n\nFrom the website: \"The goal of the Underhanded Soldity Contest is to write seemingly innocent and straightforward-looking Solidity code which actually contains malicious behavior or backdoors.\"\n\nI have recently started getting into Solidity CTF challenges and wanted to give it a go.\nDesigning smart-contract challenges sounds like a fun task.\nThere have been times while coding a contract where I had to shudder,\nbecause I realized a terrible mistake in my code.\nI thought some of these could end up being interesting CTF Challenges.\n\nThis years theme for the challenge is about decentralized exchanges. Any kind, orderbook or AMM.\nAnd, \"simplicity is key\" is emphasized.\n\nI came up with two challenges that I [uploaded to Github](https://github.com/willisk/SmartContract-Challenges) if you want to give them a try!\n\nI was first going to go with submitting the bitmap challenge [\"ExclusiveExchange.sol\"](https://github.com/willisk/SmartContract-Challenges/blob/master/contracts/ExclusiveExchange.sol),\nbecause it came across as unique (albeit also a bit of a niche setting).\nAlthough, after stripping away any unnecessary, distracting fluff from the contract,\nthe vulnerability seemed too obvious.\nAnd, especially after hearing that @samczsun from paradigm will be on the board\n(famous for [his pinball machine](https://samczsun.com/hiding-in-plain-sight/) - probably one of the hardest challenges regarding bitmaps),\nI decided to come up with another one.\n\nSo, I wrote the second challenge [\"NFTOrderBook.sol\"](https://github.com/willisk/SmartContract-Challenges/blob/master/contracts/NFTOrderBook.sol).\nThe setup for this one is a bit more realistic and the bug is more common, although a bit simple.\nI still have not seen any other CTF challenge revolve around this vulnerability/error,\nso it could be a good fit.\n\nI might have a small write-up, after I have some people test them out\nand give me feedback.\n","title":"Underhanded Solidity Contest","date":"Mar 15, 2022","excerpt":"The 2022 Underhanded Solidity Contest submissions are coming up."},{"slug":"blog/2022/counter-attack","contentRaw":"\nMy [last post](/blog/2022/unexpected-input), which was about an exploit allowing\nunlimited minting of an ERC20 token got me thinking about whether any counter-measures\ncould be implemented if such an exploit were to happen.\n\nBelow is the contract of the MadMouse utility token Gouda, which I'm currently developing.\nIt's a standard ERC20 token combined with OpenZeppelin's AccessControl contract.\n\n```Gouda.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/access/AccessControl.sol';\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\nimport './lib/ERC721MStaking.sol';\n\nerror ExceedsMaxSupply();\n\ncontract Gouda is ERC20, AccessControl, IERC20Reward {\n    bytes32 private constant MINT_AUTHORITY = keccak256('MINT_AUTHORITY');\n    bytes32 private constant BURN_AUTHORITY = keccak256('BURN_AUTHORITY');\n\n    constructor(address madmouse, address treasury) ERC20('Gouda', 'GOUDA') {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n        _setupRole(MINT_AUTHORITY, madmouse);\n        _setupRole(BURN_AUTHORITY, madmouse);\n\n        _mint(treasury, 100_000 * 1e18);\n    }\n\n    // ------------- Restricted -------------\n\n    function mint(address user, uint256 amount) external onlyRole(MINT_AUTHORITY) {\n        _mint(user, amount);\n    }\n\n    function burn(address user, uint256 amount) external onlyRole(BURN_AUTHORITY) {\n        _burn(user, amount);\n    }\n}\n```\n\n# A counter-measure to an attack\n\nIn the case of an attacker being able to exploit the staking contract,\nthey would likely mint a high number of tokens not achievable by normal staking.\n\nWhat if we restrict the mint function to revert in such a case?\n\n```Gouda.sol\ncontract Gouda is ERC20, AccessControl, IERC20Reward {\n\n    ...\n\n    function mint(address user, uint256 amount) external onlyRole(MINT_AUTHORITY) {\n        require(amount \u003e 500_000 * 1e18, 'UNDER_ATTACK');\n        _mint(user, amount);\n    }\n}\n```\n\nThis would be too noticeable for an attacker. They would most likely realise the revert when testing locally\nand if the first attack failed, they could simply launch many more, smaller ones to bypass the limit.\n\nWhat if we instead let the call go through and then revoke the `MINT_AUTHORITY` role of the\nstaking contract? That way, the funds could remain safe until a solution has been found.\n\n```Gouda.sol\ncontract Gouda is ERC20, AccessControl, IERC20Reward {\n\n    ...\n\n    function mint(address user, uint256 amount) external onlyRole(MINT_AUTHORITY) {\n        if (amount \u003c 500_000 * 1e18) _mint(user, amount);\n        else _revokeRole(MINT_AUTHORITY, madmouse); // emergency shutdown\n    }\n}\n```\n\nHm.. so far so good. Although, they would likely run\ntests on a local network first to check whether their attack was successful\nand their token balance increased.\n\n[EIP-1344](https://eips.ethereum.org/EIPS/eip-1344) introduced the ChainID opcode\nwhich can now be accessed through `block.chainid`.\nThis way, we could have our fail-safe code run only when the chain\nis on mainnet (chain id 1).\nWe can also add further checks, since some providers will set `tx.origin = address(0)`\nwhen running 'call' methods (i.e. calls that are not sent to the blockchain to be mined).\n\n```Gouda.sol\ncontract Gouda is ERC20, AccessControl, IERC20Reward {\n\n    ...\n\n    function mint(address user, uint256 amount) external onlyRole(MINT_AUTHORITY) {\n        if (amount \u003c 500_000 * 1e18  // highlight-line\n            || block.chainid != 1  // highlight-line\n            || tx.origin == address(0)) { // highlight-line\n            _mint(user, amount); // highlight-line\n        } // highlight-line\n        else _revokeRole(MINT_AUTHORITY, madmouse);\n    }\n}\n```\n\nOk, getting there..\nNow, if the attacker tests out their exploit locally, they would be able to mint the\ntokens, and if it were to execute on mainnet, the emergency shutdown code would be called.\n\nStill, any quick peak at the contract will directly expose this counter-measure.\nSo, how can we hide it?\n\nHiding it in the ERC20.sol contract directly would seem infeasible, because we are trying\nto access `_revokeRole` from AccessControl to automatically trigger the emergency shutdown.\nERC20's implementation comes with the hooks `_beforeTokenTransfer` and `_afterTokenTransfer`.\nPerhaps these could be used in some form..\n\nI tried modifying '@openzeppelin/contracts/access/AccessControl.sol'\nto inherit from ERC20.sol.\nThat way, AccessControl could be implementing the special hooks.\nThe only problem with this is that we're now inheriting from two contracts that implement an\n`_afterTokenTransfer` and thus are required to override it again in our ERC20 contract.\nThis, in turn would look suspicious again,\nbecause \"wth is AccessControl doing implementing an `_afterTokenTransfer`?\"\n\n```Gouda.sol\ncontract Gouda is ERC20, AccessControl, IERC20Reward {\n\n    ...\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override(ERC20, AccessControl) {\n        super._afterTokenTransfer(from, to, amount);\n    }\n}\n```\n\nWhat if... we kept this piece of code in the ERC20.sol implementation and directly modified storage slots?\nFor that, we would have to figure out what storage slot is being used to grant the staking contract the authority.\n\n```AccessControl.sol\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address =\u003e bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 =\u003e RoleData) private _roles;\n\n    ...\n}\n```\n\nAccessControl's roles are stored in the `mapping(bytes32 =\u003e RoleData) _roles`\nand since we want to modify the `RoleData` for the `MINT_AUTHORITY` role,\nwe should be looking at `_roles[MINT_AUTHORITY]`\nor `_roles[0x2835a7a5b84b6b14021f9bc9694ea8ba57b01e33d0984ae2c6ac566c9cb317dd]`.\nThen, we want to access `members`, specifically `members[madmouse]`.\n\nTo get the final storage slot of `_roles[MINT_AUTHORITY].members[madmouse]`,\nwe will have to compute\n\n```sol\nbytes32 slot_roleData = keccak256(abi.encode(MINT_AUTHORITY, slot_roles));\nbytes32 slot_members = slot_roleData + 0;\nbytes32 slot_data = keccak256(abi.encode(madmouse, slot_members));\n```\n\nWe don't need to add an offset to `slot_roleData` when calculating `slot_members`,\nbecause it is in storage slot 0 in the `RoleData` struct and thus `slot_roleData == slot_members`.\nYou can read more on storage layout [here](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html).\n\nThe only missing part now is `slot_roles`.\nThis slot is dependent on the internal storage slots of the contract.\nWe can use a script to iterate over all stora slots and read out the storage\nto find this slot quickly.\n\n```js\nfor (let slot_roles = 0; slot_roles \u003c 10; slot_roles++) {\n  let slot_members = ethers.utils.keccak256(\n    ethers.utils.defaultAbiCoder.encode(\n      ['bytes32', 'uint'],\n      ['0x2835a7a5b84b6b14021f9bc9694ea8ba57b01e33d0984ae2c6ac566c9cb317dd', slot_roles]\n    )\n  );\n\n  let slot_data = ethers.utils.keccak256(\n    ethers.utils.defaultAbiCoder.encode(['address', 'bytes32'], [nft.address, slot_members])\n  );\n\n  let data = await network.provider.send('eth_getStorageAt', [gouda.address, slot_data, 'latest']);\n\n  console.log(slot_roles, slot_members, slot_data, data);\n}\n```\n\nThe result:\n\n```js\n0 0x15cbcc7ee8b33517d87e628a3ab5fdc484a6b34f5ade2092ebc08dd9cb0ca324 0xf381069cc17fc400a04f9af5041ad36e197e835f2d29ad6a9ef5436dcfc08316 0x0000000000000000000000000000000000000000000000000000000000000000\n1 0x0edbf5ca4965338dd62f75ba1de83eaaaac30e60abb11286d503c3974881165c 0x27fce0b43dd82ae221013e6954fc2adf28c02e3e6e96093620b75f1a6cd70b57 0x0000000000000000000000000000000000000000000000000000000000000000\n2 0xcee27263ce9ad7070e2cdbf5b3f11082a9b1a281ddb83f41a7eefde673a5adca 0x1f1a1876d0dd3e2d2ddbeecb460a9091173ce9f2a40563816e0244b934cf2be0 0x0000000000000000000000000000000000000000000000000000000000000000\n3 0xb32bb3ba356143f7ad5c637479f06883217ad3d5b85f7cf3f8c30152cbb6364a 0x6fc5d456201c9606ecb4c83e0bdea733d5ddc704ee75a0e9684da0e610b1b292 0x0000000000000000000000000000000000000000000000000000000000000000\n4 0xd9191642a20cbd464db6d25f40b03b7fc59b571d399a359b9ac38134c83e856a 0xa7f91fd2efb5a47686a7fd60162f86f05679850a3469c8274b51aee21c94cd6b 0x0000000000000000000000000000000000000000000000000000000000000000\n5 0x4f431056f30038a4630700c6ce70dd8770865fbb61b08a774f29ed79a8e58129 0x1d74f4cfcf55a4866d5f7e8565274daa8a310ebb98a84bdf29b1e6e8631a7380 0x0000000000000000000000000000000000000000000000000000000000001337 // highlight-line\n6 0x8cdef33328e7cad47ce15a7fe2205f3924fe77c37f2fa5061a73a1d1a85ecd96 0x2d7d9aec18f3786f6dd7a826144db7f518eb4d6d5f4121dc714bc5af105b2f35 0x0000000000000000000000000000000000000000000000000000000000000000\n7 0xbc8fbf2aa6164f00cf2f22757f1de06f71959b8b9d75dcf0beef9c7e6b6e00e7 0x6ba2813f222dd1dfbfc978039655edf7bf5e63233313f28c047caf3629b41af6 0x0000000000000000000000000000000000000000000000000000000000000000\n8 0x10f605896b2ef49244aeafc0c06c364831ebe47381f4c06a98bc6e906861c852 0xddd9db65cdfbd0127590dd5a3bc56caf338ca2fc43ca09da72317763b36a327a 0x0000000000000000000000000000000000000000000000000000000000000000\n9 0xc1a5536b2498b1ba1e7da4ff40e87f1b068e232026c46ac078ebf98c7f51f6fa 0x75b2f0ce94d3ebd5d90cdfd41f3a3ddcfaf908a8ef896b7e9516c7bb33c6f9d1 0x0000000000000000000000000000000000000000000000000000000000000000\n```\n\nI had changed the mapping in `RoleData` to `mapping(address =\u003e bytes32) members`\nand set `_roles[MINT_AUTHORITY].members[madmouse] = 0x1337` to make it more obvious.\nNow we know that the storage slot for `_roles` is 5! Although, we can simply\nuse the pre-computed `slot_members`, since that won't change. Note: depending on additional\nvariables in the contract's storage, the storage slot might be located somewhere else.\n\nWe can finally implement our `_afterTokentransfer`:\n\n```@openzeppelin/contracts/token/ERC20/ERC20.sol\n// this part is to be hidden in '@openzeppelin/contracts/token/ERC20/ERC20.sol'\nfunction _afterTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n) internal virtual override {\n    if (from == address(0) \u0026\u0026 amount \u003e 500_000 * 1e18 \u0026\u0026 block.chainid == 1 \u0026\u0026 tx.orign != address(0)) {\n        // 0x4f431056f30038a4630700c6ce70dd8770865fbb61b08a774f29ed79a8e58129\n        // is the storage slot of _roles[MINT_AUTHORITY].members in AccessControl\n        // s is the storage slot of the authorisation flag for msg.sender _roles[MINT_AUTHORITY].members[msg.sender]\n        bytes32 slot = keccak256(\n            abi.encode(msg.sender, 0x4f431056f30038a4630700c6ce70dd8770865fbb61b08a774f29ed79a8e58129)\n        );\n\n        // same as: _roles[MINT_AUTHORITY].members[msg.sender] = 0\n        assembly {\n            sstore(slot, 0)\n        }\n\n        // burn an equivalent amount of tokens to counter the amount of tokens minted\n        _burn(to, amount);\n    }\n}\n```\n\nThankfully, we don't have to think of ways to somehow pass in the staking contract's address\nto ERC20 unnoticed, since we know that the staking contract will be `msg.sender`.\n\nSome final checks make sure that this only gets triggered when minting and not when\ninitialising the contract. Because we can't modify the amount of tokens that the attacker receives\nthrough the hooks, we can simply `_burn` an equivalent amount of tokens in return.\n\n## In summary\n\n- counter-measure is hidden in `@openzeppelin/contracts/token/ERC20/ERC20.sol`\n- if an unrealistic amount of tokens is to be minted, they are immediately burned\n- the staking contract also gets the `MINT_AUTHORITY` role removed\n- the transaction does not revert\n- only activated when running on mainnet\n- funds are safu?\n\nThis trick should be fairly hard to notice and could prove useful in some cases.\n","title":"Counter-Attack to the Attack","suptitle":"aka \"Hackers hate this one weird trick\"","date":"Mar 12, 2022","excerpt":"My last bug report on an exploit that allowed unlimited minting had me thinking about counter-measures to an attack."},{"slug":"blog/2022/unexpected-input","contentRaw":"\nThere's a bug that seems to occur fairly frequently in the NFT projects venturing\ninto the DeFi-space.\nMy guess is that this is because there have not been\nfully audited ERC721 and trusted staking contracts,\nlike the Synthetix staking contract.\nI first got to know this bug through Mutant Cats' [FishFarm](https://etherscan.io/address/0xb2f43262fc23d253538ca5f7b4890f89f0ee95d9#code)\nand\nStacked Toadz' [ERC721Farm](https://etherscan.io/address/0x4d1de90bca7a38c556c356c0b802b5102cea032d#code).\n\nMutant Cats were lucky enough to get notified by the community about the vulerability\nand began migrating to a new staking contract in time.\nStacked Toadz [were not so lucky](https://twitter.com/stacked_toadz/status/1448953720348102660)\nwith the hacker making off with 43 ETH from the looted $STACKS.\n\nBecause of a project I'm working on, I wanted to make sure that all of the tokens that will be\nable to interact with our eco-system follow the ERC20 standard\n(and don't resort to a O(N) balanceOf implementation).\nAnd just out of curiosity I went ahead and looked at some of their implementations.\n\nI was able to find the same bug in [UniQuest](https://etherscan.io/address/0x3a6d70e7989ba6e7d5958d7c1eea487082681698/advanced#code), the staking contract for Uninterested Unicorns.\nThe Unicandy UCD-ETH pool maximally allowed for swapping out around 100 ETH.\n\n# The code\n\nThe relevant code to claim ERC20 rewards for Mutant Cats is shown below.\n\n```FishFarm.sol\ncontract FishFarm {\n\n    ...\n\n    function calculateRewards(address account, uint256[] memory tokenIds)\n        public\n        view\n        returns (uint256[] memory rewards)\n    {\n        rewards = new uint256[](tokenIds.length);\n\n        for (uint256 i; i \u003c tokenIds.length; i++) {\n            uint256 tokenId = tokenIds[i];\n\n            rewards[i] =\n                RATE *\n                (_deposits[account].contains(tokenId) ? 1 : 0) *\n                (Math.min(block.number, EXPIRATION) -\n                    depositBlocks[account][tokenId]);\n        }\n    }\n\n    function claimRewards(uint256[] calldata tokenIds) public {\n        uint256 reward;\n        uint256 block = Math.min(block.number, EXPIRATION);\n\n        uint256[] memory rewards = calculateRewards(msg.sender, tokenIds);\n\n        for (uint256 i; i \u003c tokenIds.length; i++) {\n            reward += rewards[i];\n            depositBlocks[msg.sender][tokenIds[i]] = block;\n        }\n\n        if (reward \u003e 0) {\n            try IERC20(FISH).transfer(msg.sender, reward) returns (bool v) {\n            } catch Error(string memory) {}\n        }\n    }\n}\n```\n\nThe `claimHODLRewards` is part of the\n[UniQuest](https://etherscan.io/address/0x3a6d70e7989ba6e7d5958d7c1eea487082681698/advanced#code)\nstaking contract for Uninterested Unicorns NFT.\n\n```UniQuest.sol\ncontract UniQuest {\n\n    ...\n\n    function claimHODLRewards(uint256[] memory tokenIds) public nonReentrant {\n        for (uint256 i = 0; i \u003c tokenIds.length; i++) {\n            require(\n                UU.ownerOf(tokenIds[i]) == msg.sender,\n                \"UniQuest: Not Owner of token\"\n            );\n        }\n\n        uint256 rewards = calculateHODLRewards(tokenIds);\n\n        for (uint256 i = 0; i \u003c tokenIds.length; i++) {\n            HODLLastClaim[tokenIds[i]] = block.timestamp;\n        }\n\n        UCD.mint(msg.sender, rewards);\n    }\n\n\n    function calculateHODLRewards(uint256[] memory tokenIds)\n        public\n        view\n        returns (uint256 HODLRewards)\n    {\n        HODLRewards = 0;\n        for (uint256 i = 0; i \u003c tokenIds.length; i++) {\n            HODLRewards = ...\n        }\n    }\n}\n```\n\n# The bug\n\nThe bug is possible because in both contracts, the rewards calculation is separated from the\nstate-update to the blockchain and because they allow for unchecked user input.\nThe reward is calculated by first looping over the user-inputted token ids.\nAnd only afterwards the claimed timestamp for each token id is set in another loop.\n\nThe problem is that the user is able to input a token id they own\nas many times as they want. There is nothing stopping them\nfrom inputting `claimRewards([3, 3, 3, 3, ...])` for example.\nThis allows the attacker to mint an unlimited amount of tokens from\nthe staking contract.\n\n# The solution\n\nA checks-effects-interactions pattern - well known for guarding\nagainst reentrancy bugs - would have prevented these exploits from being possible.\nInstead of using two-loops, the correct way would be to use one loop\nand to set the timestamp for the last claim directly after checking\nthe rewards for a certain token id.\n\nAlso, in general it makes sense to limit the degree-of-freedom a user has\nwhile interacting with a contract. **Fishfarm** had direct access to `_deposits`\nand **Uninterested Unicorns** is an _ERC721Enumerable_, so both contracts\ncould have implemented a function `claimRewards()` instead that\ndirectly claims the rewards for all token ids, thereby\nlimiting attack vectors through malicious user-input.\n\nAfter getting into contact with the Uninterested Unicorns team, they were able to\nupgrade their proxy contract's implementation - no unicorns hurt.\n","title":"Bug Report","suptitle":"Uninterested Unicorns","date":"Mar 12, 2022","excerpt":"There's a bug that seems to occur fairly frequently in the NFT projects venturing into the DeFi-space."},{"slug":"blog/2022/abi-playground","contentRaw":"\n[ABI Playground](/abi-playground)\nis a tool that allows for quick and easy interacting with deployed contracts\nwithout a verified source.\n\nThis is what the interface looks like:\n\n![demo](/data/blog/2022/abi-playground/demo.png)\n\nYou can click on the **?-symbol** next to the title to **fill in the example** for you.\nIt enters in the contract address of TheDAO and a few functions as an example.\n\n![demo](/data/blog/2022/abi-playground/demo2.png)\n\nThe ABI-section allows you to **fetch the ABI from etherscan** if it's available or import common ABIs.\n\n![demo](/data/blog/2022/abi-playground/demo3.png)\n\nYou can either enter a full ABI in JSON format, or **you can simply write function declarations yourself,\nlike in the example**.\n\n![demo](/data/blog/2022/abi-playground/demo4.png)\n\nThe _Functions_ section is generated automatically from the ABI.\nTo send a request, click on the function name.\nThe function's arguments are in between the parentheses along with their variable names if given.\nIf a variable is of type `address`, the \\*-symbol can be used to insert\nyour own address.\n\nOnce the ABI and an address has been entered, **the contract (along with the ethers library) can also be accessed by opening up the\ndeveloper console**.\n\n![demo](/data/blog/2022/abi-playground/demo5.png)\n\nThe variables after the arrow are the returned variables.\nNote that, **only constant (i.e. non-state-modifying/view) functions will return data**.\n\n- _View_ functions are marked \u003cspan class='text-primary-400'\u003eblue\u003c/span\u003e\n- _State-modifying_ functions are marked \u003cspan class='text-orange-300'\u003eorange\u003c/span\u003e\n- _Payable_ functions are in \u003cspan class='text-red-400'\u003ered\u003c/span\u003e\n\nIn order to receive an output from a state-modifying function (orange and red) they need to be called as a static request.\nThis can be achieved by either changing the definition in the ABI, i.e. adding the _view_ declaration.\nOr this can be done in the Low-Level Call section.\nThe Low-Level Call data is automatically updated by modifying function arguments, or by clicking\non the icon to the left of a function.\n\n![demo](/data/blog/2022/abi-playground/demo6.png)\n\nThis section shows the full transaction data that is submitted\nand can be directly modified. **It can therefore also be used for deploying contracts\nby copying the deployment bytecode or it can be used to directly execute raw bytecode**.\nThis can come in handy for some of the [Ethernaut challenges](https://ethernaut.openzeppelin.com/).\n\n![demo](/data/blog/2022/abi-playground/demo7.png)\n\nThe response is decoded if any return values were specified.\nIndividual values can be copied by clicking on the types to the left.\n\n![demo](/data/blog/2022/abi-playground/demo8.png)\n\nThe full response (broken up in 32 bytes chunks) can be inspected in the Low-Level Call section.\nThe raw data can be copied by clicking on 'data' on the top.\n\n[Try it out!](/abi-playground) I'm happy for any feed-back.\n\nSpecial thanks to the team developing the [ethersjs](https://docs.ethers.io/).\nThis is just a fancy interface built on-top of it.\n","title":"ABI Playground","date":"Mar 9, 2022","excerpt":"A tool for quickly interacting with deployed contracts. No ABI needed!"},{"slug":"blog/2022/soldisc","contentRaw":"\nSo you want to add a commenting-system to your blog, but you've become tired of legacy Web 2.0 tech?\nAre you sick of having capitalist commenting-services like **DisqusJS** litter your blog with corporate ads?\nWhy not give the money to hard-working miners insted?\nWhy not leverage the benefits of censorship-resistant, decentralized blockchain today?\nIt's permission-less, fast and effectively gates opinions voiced in the comment section.\nAnti-Bot protection? - Just deploy on Eth Mainnet.\n\n# The contract\n\nThe basic functionality we need is for a user to register under a unique user name.\nFor that we'll be looking up the address stored under given a names hash.\nThis is accomplished via the `userNameRegistry` a mapping `bytes32 =\u003e address`.\n\nThe `Account` struct stores the name as a string and the date the account was created on.\n\n```SolDisc.sol\n//SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\ncontract SolDisc {\n    struct Account {\n        string name;\n        uint256 creationDate;\n    }\n\n    mapping(address =\u003e Account) public accounts;\n    mapping(bytes32 =\u003e address) public userNameRegistry;\n\n    function createAccount(string calldata name) external {\n        require(isValidUserName(name, 4, 20), 'INVALID_NAME');\n\n        // enforce unique user-names by storing the hash in a registry\n        bytes32 userNameHash = keccak256(abi.encodePacked(name));\n        address userNameOwner = userNameRegistry[userNameHash];\n\n        require(userNameOwner == address(0));\n        userNameRegistry[userNameHash] = msg.sender;\n\n        // create user profile\n        Account storage account = accounts[msg.sender];\n        account.name = name;\n        account.creationDate = block.timestamp;\n    }\n}\n```\n\n`isValidUserName` is simply a function that checks for invalid characters and makes sure it fits the minimum and maximum length\nrequirements.\n\nWe can now add the functionality to enable commenting on a specific post.\n\n```SolDisc.sol\ncontract SolDisc {\n    struct Account {\n        string name;\n        uint256 creationDate;\n    }\n\n    struct Comment { //add-line\n        address user; //add-line\n        uint256 creationDate; //add-line\n        string text; //add-line\n    } //add-line\n\n    mapping(address =\u003e Account) public accounts;\n    mapping(bytes32 =\u003e address) public userNameRegistry;\n\n    mapping(bytes32 =\u003e Comment) public commentRegistry; // add-line\n    mapping(bytes32 =\u003e bytes32[]) commentHashesByPostHash; // add-line\n\n    function createAccount(string calldata name) public {\n        ...\n    }\n\n    function commentOnPost(bytes32 postHash, string calldata text) external requiresAccount { // add-line\n        require(isValidComment(text), 'INVALID_COMMENT'); //add-line\n //add-line\n        uint256 commentId = commentHashesByPostHash[postHash].length; //add-line\n        bytes32 commentHash = keccak256(abi.encode(postHash, commentId)); //add-line\n //add-line\n        // add comment to registry //add-line\n        Comment storage comment = commentRegistry[commentHash]; //add-line\n        comment.user = msg.sender; //add-line\n        comment.creationDate = block.timestamp; //add-line\n        comment.text = text; //add-line\n //add-line\n        // register comment to post //add-line\n        commentHashesByPostHash[postHash].push(commentHash); //add-line\n //add-line\n        // link comment to user account //add-line\n        accounts[msg.sender].commentHashes.push(commentHash); //add-line\n    } // add-line\n // add-line\n    modifier requiresAccount() { // add-line\n        require(accounts[msg.sender].creationDate \u003e 0, 'USER_ACCOUNT_REQUIRED'); // add-line\n        _; // add-line\n    } // add-line\n // add-line\n}\n```\n\nSince comments can be seen as arrays tied to a certain post,\nthe function `commentOnPost` takes in a bytes32 hash `postHash` unique to a post/page\nand the string `text` which is to be added as a comment.\n\nWe could structure the mapping as `bytes32 =\u003e Comment[]`, however, as might become clearer later,\nit is practical to have a single unique hash to index each comment (i.e. `bytes32 =\u003e Comment`).\nLike before, the Comment is indexed in a mapping `bytes32 =\u003e Comment` `commentRegistry`.\n\n`commentHashesByPostHash`, a mapping `bytes32 =\u003e bytes32[]` is used to index and register\ncomments (by their hashes) given a post hash.\n\nAnd that's pretty much it to make it work! There are a few extra features that we could add,\nsuch as liking posts and editing them.\n\n## Extra Features\n\nNo commenting-system is complete without being able to like comments.\nThe number of likes a comment receives will be implemented as a `uint256 numLikes` stored in the `Comment` struct.\nFurthermore (in order to make sure a user can only like a comment once), we'll need to keep track of a user's likes.\nThis is done in the mapping `bytes32 =\u003e bool likedComments` available in each user's account\nto keep track of which comments they have already liked.\n\nIn order to like (and un-like) a comment, we'll add a function `toggleLikeComment` that takes in\nthe post hash and the comment index/id.\n\n```SolDisc.sol\ncontract SolDisc {\n    struct Account {\n        string name;\n        uint256 creationDate;\n        mapping(bytes32 =\u003e bool) likedComments; // add-line\n    }\n\n    struct Comment {\n        address user;\n        uint256 creationDate;\n        uint256 numLikes;   // add-line\n        string text;\n    }\n\n    ...\n\n    function toggleLikeComment(bytes32 postHash, uint256 commentId) external requiresAccount { // add-line\n        bytes32 commentHash = keccak256(abi.encode(postHash, commentId)); // add-line\n        Comment storage comment = commentRegistry[commentHash]; // add-line\n // add-line\n        require(comment.user != msg.sender, 'CANNOT_LIKE_OWN_COMMENT'); // add-line\n // add-line\n        Account storage account = accounts[msg.sender]; // add-line\n        bool like = !account.likedComments[commentHash]; // add-line\n        account.likedComments[commentHash] = like; // add-line\n // add-line\n        if (like) comment.numLikes++; // add-line\n        else comment.numLikes--; // add-line\n    } // add-line\n}\n```\n\nFinally, on the front-end, we can then generate a hash from a post's using **ethers.js**:\n\n```js\nconst encoded = ethers.utils.defaultAbiCoder.encode(['string'], [pageSlug]);\nconst postHash = ethers.utils.keccak256(encoded);\n```\n\nwhere `pageSlug` is '2021/soldisc' in this case.\n\nIn order to make the whole experience more complete, a bunch of helper functions\nthat enable us to more quickly and efficiently fetch the data from the chain are needed.\nYou can view the final implementation on [Github](https://github.com/willisk/SolDisc/blob/master/contracts/SolDisc.sol).\nPlease do try it out and leave a comment! Next versions will include comments as ERC721s and likes as ERC20s.\n\nEdit: Is it 2022 already?\n","title":"SolDisc.sol","suptitle":"On-Chain Discourse","date":"Mar 6, 2022","excerpt":"DisqusJS? Facebook Comments? You might as well be serving the devil directly. Learn to code your on-chain commenting-system using blockchain!"}]},"__N_SSG":true},"page":"/","query":{},"buildId":"Y9bbfKQ8LkQuhxCi5ZJz5","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>