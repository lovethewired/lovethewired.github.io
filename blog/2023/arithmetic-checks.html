<!DOCTYPE html><html><head><meta charSet="utf-8"/><title class="animate__fadeIn">0xPhaze</title><meta name="viewport" content="initial-scale=1.0, width=device-width"/><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/fcf81e63369216ac.css" as="style"/><link rel="stylesheet" href="/_next/static/css/fcf81e63369216ac.css" data-n-g=""/><link rel="preload" href="/_next/static/css/65875c30e26bdd78.css" as="style"/><link rel="stylesheet" href="/_next/static/css/65875c30e26bdd78.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-ede13cf31a63337e.js" defer=""></script><script src="/_next/static/chunks/framework-bb5c596eafb42b22.js" defer=""></script><script src="/_next/static/chunks/main-914fbfab4f90b52f.js" defer=""></script><script src="/_next/static/chunks/pages/_app-ad82082731d58181.js" defer=""></script><script src="/_next/static/chunks/175675d1-5e59763be147fa1f.js" defer=""></script><script src="/_next/static/chunks/634-958ce5c52c8283ef.js" defer=""></script><script src="/_next/static/chunks/pages/%5B...slug%5D-1036fd4ff48bafcd.js" defer=""></script><script src="/_next/static/P0-6OJp-GIUymjWj8O3zL/_buildManifest.js" defer=""></script><script src="/_next/static/P0-6OJp-GIUymjWj8O3zL/_ssgManifest.js" defer=""></script><script src="/_next/static/P0-6OJp-GIUymjWj8O3zL/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="app px-4 pb-20 min-h-screen flex flex-col items-center w-full max-w-screen"><header class="w-full flex flex-col px-4 sm:px-8 md:px-12 max-w-5xl sm:flex-row justify-between items-center border-white/20 overflow-hidden border-b p-4 h-16"><div class="w-full h-full flex flex-col sm:flex-row justify-start sm:justify-between items-center gap-y-4 overflow-hidden sm:overflow-visible"><div class="flex w-full sm:w-fit items-center"><h1 class="text-xl mx-auto font-display"><a href="/">0xPhaze</a></h1><div class="my-auto -ml-6 w-6 sm:hidden"><div class="text-slate-300 hover:text-secondary-400 transition-colors duration-200 cursor-pointer h-6"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="bars" class="svg-inline--fa fa-bars " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M0 96C0 78.33 14.33 64 32 64H416C433.7 64 448 78.33 448 96C448 113.7 433.7 128 416 128H32C14.33 128 0 113.7 0 96zM0 256C0 238.3 14.33 224 32 224H416C433.7 224 448 238.3 448 256C448 273.7 433.7 288 416 288H32C14.33 288 0 273.7 0 256zM416 448H32C14.33 448 0 433.7 0 416C0 398.3 14.33 384 32 384H416C433.7 384 448 398.3 448 416C448 433.7 433.7 448 416 448z"></path></svg></div></div></div><div class="flex flex-col sm:flex-row gap-x-8 md:gap-x-10 gap-y-4"><div class="flex gap-x-2 sm:gap-x-5 items-center justify-evenly"><a target="_blank" rel="noreferrer" class="link" href="https://github.com/0xPhaze/"><div><div class="text-slate-300 hover:text-secondary-400 transition-colors duration-200 cursor-pointer"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="h-4"><path style="fill:currentColor" d="M12 0C5.374 0 0 5.373 0 12c0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23A11.509 11.509 0 0 1 12 5.803c1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576C20.566 21.797 24 17.3 24 12c0-6.627-5.373-12-12-12z"></path></svg></div></div></a><a target="_blank" rel="noreferrer" class="link" href="https://twitter.com/lovethewired"><div><div class="text-slate-300 hover:text-secondary-400 transition-colors duration-200 cursor-pointer"><svg viewBox="0 0 16 14" fill="none" xmlns="http://www.w3.org/2000/svg" class="h-4"><path style="fill:currentColor" d="M15.584 1.578a7.91 7.91 0 0 1-1.57 1.807v.482c0 .965-.112 1.929-.336 2.772-.224.965-.673 1.808-1.121 2.652a17.373 17.373 0 0 1-1.794 2.29c-.785.723-1.681 1.205-2.578 1.566-1.01.362-2.13.603-3.252.603-1.793 0-3.475-.603-4.932-1.567h.784c1.458 0 2.915-.482 4.036-1.446a2.914 2.914 0 0 1-1.905-.723c-.561-.482-.897-.964-1.122-1.687h.561c.336 0 .56 0 .897-.12C2.579 8.085 1.907 7.603 1.458 7 .785 6.398.561 5.675.561 4.83c.449.242 1.01.362 1.458.483A5.531 5.531 0 0 1 .898 4.109C.673 3.626.449 3.024.449 2.42c0-.602.112-1.205.449-1.687a8.606 8.606 0 0 0 2.914 2.53c1.122.603 2.355.965 3.7 1.086 0-.241-.112-.483-.112-.844 0-.723.224-1.326.56-1.928.337-.603.897-.965 1.458-1.326.56-.241 1.233-.362 1.906-.12.672.12 1.233.481 1.681.964.673-.121 1.458-.362 2.018-.844-.224.844-.784 1.446-1.457 1.928.785-.12 1.457-.24 2.018-.602Z" fill="#081026"></path></svg></div></div></a><div><div class="text-slate-300 hover:text-secondary-400 transition-colors duration-200 cursor-pointer">ABI</div></div><div><div class="text-slate-300 hover:text-secondary-400 transition-colors duration-200 cursor-pointer">ENC</div></div></div><button class="rounded px-4 py-2 uppercase text-white select-none  transition-all duration-300 disabled:pointer-events-none bg-primary-600 hover:bg-primary-700  !outline-none normal-case text-sm w-[140px] w-36">Connect Wallet</button></div></div></header><main class="gap-y-20 mt-8 py-4 sm:px-8 md:px-12 w-full min-h-[500px] max-w-4xl"><div class="flex flex-col justify-between gap-y-20"><div class="content markdown"><h1 class="text-center">A Guide on Performing Arithmetic Checks in the EVM</h1><p class="text-slate-500 text-sm text-center">Feb 19, 2023</p><div class="mt-16"><blockquote>
<p>This post was created during my time at Trail of Bits. It is featured in the <a target="_blank" rel="noreferrer" class="link" href="https://secure-contracts.com/learn_evm/arithmetic-checks">secure-contracts/learn-evm</a>.</p>
</blockquote>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="/blog/2023/arithmetic-checks#arithmetic-checks-for-uint256-addition">Arithmetic checks for uint256 addition</a></li>
<li><a href="/blog/2023/arithmetic-checks#arithmetic-checks-for-int256-addition">Arithmetic checks for int256 addition</a>
<ul>
<li><a href="/blog/2023/arithmetic-checks#quick-primer-on-a-twos-complement-system">Quick primer on a two&#x27;s complement system</a></li>
</ul>
</li>
<li><a href="/blog/2023/arithmetic-checks#arithmetic-checks-for-uint256-subtraction">Arithmetic checks for uint256 subtraction</a></li>
<li><a href="/blog/2023/arithmetic-checks#arithmetic-checks-for-uint256-multiplication">Arithmetic checks for uint256 multiplication</a></li>
<li><a href="/blog/2023/arithmetic-checks#arithmetic-checks-for-int256-multiplication">Arithmetic checks for int256 multiplication</a></li>
<li><a href="/blog/2023/arithmetic-checks#arithmetic-checks-for-addition-with-sub-32-byte-types">Arithmetic checks for addition with sub-32-byte types</a></li>
<li><a href="/blog/2023/arithmetic-checks#arithmetic-checks-for-multiplication-with-sub-32-byte-types">Arithmetic checks for multiplication with sub-32-byte types</a></li>
<li><a href="/blog/2023/arithmetic-checks#conclusion">Conclusion</a></li>
</ul>
<p>The Ethereum Virtual Machine (EVM) distinguishes itself from other virtual machines and computer systems through several unique aspects.
One notable difference is its treatment of arithmetic checks.
While most architectures and virtual machines provide access to carry bits or an overflow flag,
these features are absent in the EVM.
Consequently, these safeguards must be incorporated within the machine&#x27;s constraints.</p>
<p>Starting with Solidity version 0.8.0 the compiler automatically includes over and underflow protection in all arithmetic operations.
Prior to version 0.8.0, developers were required to implement these checks manually, often using a library known as <a target="_blank" rel="noreferrer" class="link" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol">SafeMath</a>, originally developed by OpenZeppelin.
The compiler incorporates arithmetic checks in a manner similar to SafeMath, through additional operations.</p>
<p>As the Solidity language has evolved, the compiler has generated increasingly optimized code for arithmetic checks. This trend is also observed in smart contract development in general, where highly optimized arithmetic code written in low-level assembly is becoming more common. However, there is still a lack of comprehensive resources explaining the nuances of how the EVM handles arithmetic for signed and unsigned integers of 256 bits and less.</p>
<p>This article serves as a guide for gaining a deeper understanding of arithmetic in the EVM by exploring various ways to perform arithmetic checks. We&#x27;ll learn more about the two&#x27;s complement system and some lesser-known opcodes. This article is designed for those curious about the EVM&#x27;s inner workings and those interested in bit manipulations in general. A basic understanding of bitwise arithmetic and Solidity opcodes is assumed.</p>
<p>Additional references for complementary reading are:</p>
<ul>
<li><a target="_blank" rel="noreferrer" class="link" href="https://evm.codes">evm.codes</a></li>
<li><a target="_blank" rel="noreferrer" class="link" href="https://www.geeksforgeeks.org/twos-complement/">Understanding Two&#x27;s Complement</a></li>
</ul>
<blockquote>
<p><strong>Disclaimer:</strong> Please note that this article is for educational purposes.
It is not our intention to encourage micro optimizations in order to save gas,
as this can potentially introduce new, hard-to-detect bugs that may compromise the security and stability of a protocol.
As a developer, prioritize the safety and security of the protocol over <a target="_blank" rel="noreferrer" class="link" href="https://www.youtube.com/watch?v=tKbV6BpH-C8">premature optimizations</a>.
Including redundant checks for critical operations may be a good practice when the protocol code is still evolving.
However, we do encourage experimentation with these operations for educational purposes.</p>
</blockquote>
<h3 id="arithmetic-checks-for-uint256-addition"><a href="/blog/2023/arithmetic-checks#arithmetic-checks-for-uint256-addition"><span class="icon icon-link"></span></a>Arithmetic checks for uint256 addition</h3>
<p>To examine how the solc compiler implements arithmetic checks, we can compile the code with the <code>--asm</code> flag and inspect the resulting bytecode.
Alternatively, using the <code>--ir</code> flag allows us to examine the Yul code that is generated as an intermediate representation (IR).</p>
<blockquote>
<p>Note that Solidity aims to make the new Yul pipeline the standard.
Certain operations (including arithmetic checks) are always included as Yul code, regardless of whether the code is compiled with the new pipeline using <code>--via-ir</code>.
This provides an opportunity to examine the Yul code and gain a better understanding of how arithmetic checks are executed in Solidity.
However, keep in mind that the final bytecode may differ slightly when compiler optimizations are turned on.</p>
</blockquote>
<p>To illustrate how the compiler detects overflow in unsigned integer addition, consider the following example of Yul code produced by the compiler before version 0.8.16.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">checked_add_t_uint256</span><span class="token" style="color:#bebec5">(</span><span>x</span><span class="token" style="color:#bebec5">,</span><span> y</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">-&gt;</span><span> sum </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    x </span><span class="token" style="color:#a77afe">:=</span><span> </span><span class="token function">cleanup_t_uint256</span><span class="token" style="color:#bebec5">(</span><span>x</span><span class="token" style="color:#bebec5">)</span><span>
</span></span><span><span>    y </span><span class="token" style="color:#a77afe">:=</span><span> </span><span class="token function">cleanup_t_uint256</span><span class="token" style="color:#bebec5">(</span><span>y</span><span class="token" style="color:#bebec5">)</span><span>
</span></span><span>
</span><span><span>    </span><span class="token" style="color:#6f705e">// overflow, if x &gt; (maxValue - y)</span><span>
</span></span><span><span>    </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token function">gt</span><span class="token" style="color:#bebec5">(</span><span>x</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token function">sub</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#a77afe">0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span><span class="token" style="color:#bebec5">,</span><span> y</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span> </span><span class="token function">panic_error_0x11</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span>
</span><span><span>    sum </span><span class="token" style="color:#a77afe">:=</span><span> </span><span class="token function">add</span><span class="token" style="color:#bebec5">(</span><span>x</span><span class="token" style="color:#bebec5">,</span><span> y</span><span class="token" style="color:#bebec5">)</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>To improve readability, we can translate the Yul code back into high-level Solidity code.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#6f705e">/// @notice versions &gt;=0.8.0 &amp;&amp; &lt;0.8.16</span><span>
</span></span><span><span></span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">checkedAddUint1</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">uint256</span><span> a</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">uint256</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">uint256</span><span> c</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    unchecked </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        c </span><span class="token" style="color:#a77afe">=</span><span> a </span><span class="token" style="color:#a77afe">+</span><span> b</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span>a </span><span class="token" style="color:#a77afe">&gt;</span><span> </span><span class="token function">type</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">uint256</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">.</span><span>max </span><span class="token" style="color:#a77afe">-</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token function">arithmeticError</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<blockquote>
<p>Solidity&#x27;s arithmetic errors are encoded as <code>abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x11)</code>.</p>
</blockquote>
<p>The check for overflow in unsigned integer addition involves calculating the largest value that one summand can have when added to the other without causing an overflow.
Specifically, in this case, the maximum value <code>a</code> can have is <code>type(uint256).max - b</code>.
If <code>a</code> exceeds this value, we can conclude that <code>a + b</code> will overflow.</p>
<p>An alternative and slightly more efficient approach for computing the maximum value of <code>a</code> involves inverting the bits of <code>b</code>.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#6f705e">/// @notice versions &gt;=0.8.0 &amp;&amp; &lt;0.8.16 with compiler optimizations</span><span>
</span></span><span><span></span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">checkedAddUint2</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">uint256</span><span> a</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">uint256</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">uint256</span><span> c</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    unchecked </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        c </span><span class="token" style="color:#a77afe">=</span><span> a </span><span class="token" style="color:#a77afe">+</span><span> b</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span>a </span><span class="token" style="color:#a77afe">&gt;</span><span> </span><span class="token" style="color:#a77afe">~</span><span>b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token function">arithmeticError</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>This is process is equivalent, because <code>type(uint256).max</code> is a 256-bit integer with all its bits set to <code>1</code>.
Subtracting <code>b</code> from <code>type(uint256).max</code> can be viewed as inverting each bit in <code>b</code>.
This transformation is demonstrated by <code>~b = ~(0 ^ b) = ~0 ^ b = MAX ^ b = MAX - b</code>.</p>
<blockquote>
<p>Note that <code>a - b = a ^ b</code> is <strong>NOT</strong> a general rule, except in special cases, such as when one of the values equals <code>type(uint256).max</code>.
The relation <code>~b + 1 = 0 - b = -b</code> is also obtained if we add <code>1</code> mod <code>2**256</code> to both sides of the previous equation.</p>
</blockquote>
<p>By first calculating the result of the addition and then performing a check on the sum, the need performing extra arithmetic operations are removed.
This is how the compiler implements arithmetic checks for unsigned integer addition in versions 0.8.16 and later.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#6f705e">/// @notice versions &gt;=0.8.16</span><span>
</span></span><span><span></span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">checkedAddUint</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">uint256</span><span> a</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">uint256</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">uint256</span><span> c</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    unchecked </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        c </span><span class="token" style="color:#a77afe">=</span><span> a </span><span class="token" style="color:#a77afe">+</span><span> b</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span>a </span><span class="token" style="color:#a77afe">&gt;</span><span> c</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token function">arithmeticError</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>Overflow is detected when the sum is smaller than one of its addends.
In other words, if <code>a &gt; a + b</code>, then overflow has occurred.
To fully prove this, it is necessary to verify that overflow occurs if and only if <code>a &gt; a + b</code>.
An important observation is that <code>a &gt; a + b</code> (mod <code>2**256</code>) for <code>b &gt; 0</code> is only possible when <code>b &gt;= 2**256</code>, which exceeds the maximum possible value.</p>
<h3 id="arithmetic-checks-for-int256-addition"><a href="/blog/2023/arithmetic-checks#arithmetic-checks-for-int256-addition"><span class="icon icon-link"></span></a>Arithmetic checks for int256 addition</h3>
<p>The Solidity compiler generates the following (equivalent) code for detecting overflow in signed integer addition for versions below 0.8.16.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#6f705e">/// @notice versions &gt;=0.8.0 &amp;&amp; &lt;0.8.16</span><span>
</span></span><span><span></span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">checkedAddInt</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span> a</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">int256</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span> c</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    unchecked </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        c </span><span class="token" style="color:#a77afe">=</span><span> a </span><span class="token" style="color:#a77afe">+</span><span> b</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>        </span><span class="token" style="color:#6f705e">// If `a &gt; 0`, then `b` can&#x27;t exceed `type(int256).max - a`.</span><span>
</span></span><span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span>a </span><span class="token" style="color:#a77afe">&gt;</span><span> </span><span class="token" style="color:#a77afe">0</span><span> </span><span class="token" style="color:#a77afe">&amp;&amp;</span><span> b </span><span class="token" style="color:#a77afe">&gt;</span><span> </span><span class="token function">type</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">.</span><span>max </span><span class="token" style="color:#a77afe">-</span><span> a</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token function">arithmeticError</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>        </span><span class="token" style="color:#6f705e">// If `a &lt; 0`, then `b` can&#x27;t be less than `type(int256).min - a`.</span><span>
</span></span><span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span>a </span><span class="token" style="color:#a77afe">&lt;</span><span> </span><span class="token" style="color:#a77afe">0</span><span> </span><span class="token" style="color:#a77afe">&amp;&amp;</span><span> b </span><span class="token" style="color:#a77afe">&lt;</span><span> </span><span class="token function">type</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">.</span><span>min </span><span class="token" style="color:#a77afe">-</span><span> a</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token function">arithmeticError</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>Similar to the previous example, we can compute the maximum and minimum value of one addend, given that the other is either positive or negative.</p>
<p>For reference, this is the Yul code that is produced when compiling via IR.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">checked_add_t_int256</span><span class="token" style="color:#bebec5">(</span><span>x</span><span class="token" style="color:#bebec5">,</span><span> y</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">-&gt;</span><span> sum </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    x </span><span class="token" style="color:#a77afe">:=</span><span> </span><span class="token function">cleanup_t_int256</span><span class="token" style="color:#bebec5">(</span><span>x</span><span class="token" style="color:#bebec5">)</span><span>
</span></span><span><span>    y </span><span class="token" style="color:#a77afe">:=</span><span> </span><span class="token function">cleanup_t_int256</span><span class="token" style="color:#bebec5">(</span><span>y</span><span class="token" style="color:#bebec5">)</span><span>
</span></span><span>
</span><span><span>    </span><span class="token" style="color:#6f705e">// overflow, if x &gt;= 0 and y &gt; (maxValue - x)</span><span>
</span></span><span><span>    </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token function">and</span><span class="token" style="color:#bebec5">(</span><span class="token function">iszero</span><span class="token" style="color:#bebec5">(</span><span class="token function">slt</span><span class="token" style="color:#bebec5">(</span><span>x</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token" style="color:#a77afe">0</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token function">sgt</span><span class="token" style="color:#bebec5">(</span><span>y</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token function">sub</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#a77afe">0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span><span class="token" style="color:#bebec5">,</span><span> x</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span> </span><span class="token function">panic_error_0x11</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span>    </span><span class="token" style="color:#6f705e">// underflow, if x &lt; 0 and y &lt; (minValue - x)</span><span>
</span></span><span><span>    </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token function">and</span><span class="token" style="color:#bebec5">(</span><span class="token function">slt</span><span class="token" style="color:#bebec5">(</span><span>x</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token" style="color:#a77afe">0</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token function">slt</span><span class="token" style="color:#bebec5">(</span><span>y</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token function">sub</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#a77afe">0x8000000000000000000000000000000000000000000000000000000000000000</span><span class="token" style="color:#bebec5">,</span><span> x</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span> </span><span class="token function">panic_error_0x11</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span>
</span><span><span>    sum </span><span class="token" style="color:#a77afe">:=</span><span> </span><span class="token function">add</span><span class="token" style="color:#bebec5">(</span><span>x</span><span class="token" style="color:#bebec5">,</span><span> y</span><span class="token" style="color:#bebec5">)</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>It&#x27;s important to note that when comparing signed values, the opcodes <code>slt</code> (signed less than) and <code>sgt</code> (signed greater than) must be used to avoid interpreting signed integers as unsigned integers.
Solidity will automatically insert the correct opcode based on the value&#x27;s type. This applies to other signed operations as well.</p>
<h3 id="quick-primer-on-a-twos-complement-system"><a href="/blog/2023/arithmetic-checks#quick-primer-on-a-twos-complement-system"><span class="icon icon-link"></span></a>Quick primer on a two&#x27;s complement system</h3>
<p>In a two&#x27;s complement system, the range of possible integers is divided into two halves: the positive and negative domains.
The first bit of an integer represents the sign, with <code>0</code> indicating a positive number and <code>1</code> indicating a negative number.
For positive integers (those with a sign bit of <code>0</code>), their binary representation is the same as their unsigned bit representation.
However, the negative domain is shifted to lie &quot;above&quot; the positive domain.</p>
<div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>u</mi><mi>i</mi><mi>n</mi><mi>t</mi><mn>256</mn><mtext> domain</mtext></mrow><annotation encoding="application/x-tex">uint256 \text{ domain}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span><span class="mord">256</span><span class="mord text"><span class="mord"> domain</span></span></span></span></span></span></div>
<div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>├</mtext><mi><munder><mo><mtext>─</mtext></mo><mn>0</mn></munder></mi><mtext>────────────────────────────</mtext><mi><munder><mo><mtext>─</mtext></mo><mrow><mspace width="-2em"><msup><mn>2</mn><mn>256</mn></msup><mo>−</mo><mn>1</mn></mspace></mrow></munder></mi><mtext>┤</mtext></mrow><annotation encoding="application/x-tex">├\underset{0}{─}────────────────────────────\underset{\hskip -2em 2^{256} - 1}{─}┤</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8468em;vertical-align:-0.8468em"></span><span class="mord">├</span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0em"><span style="top:-2.3829em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop">─</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7171em"><span></span></span></span></span></span></span><span class="mord">────────────────────────────</span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0em"><span style="top:-2.3116em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mspace mtight" style="margin-right:-2.8571em"></span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em"><span style="top:-2.786em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">256</span></span></span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop">─</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8468em"><span></span></span></span></span></span></span><span class="mord">┤</span></span></span></span></span></div>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#a77afe">0x0000000000000000000000000000000000000000000000000000000000000000</span><span> </span><span class="token" style="color:#6f705e">// 0</span><span>
</span></span><span><span></span><span class="token" style="color:#a77afe">0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span><span> </span><span class="token" style="color:#6f705e">// uint256_max</span></span></code></pre></pre>
<div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>i</mi><mi>n</mi><mi>t</mi><mn>256</mn><mtext> domain</mtext></mrow><annotation encoding="application/x-tex">int256 \text{ domain}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span><span class="mord">256</span><span class="mord text"><span class="mord"> domain</span></span></span></span></span></span></div>
<div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi><mover><mo><mtext>├</mtext><mi><munder><mo><mtext>─</mtext></mo><mn>0</mn></munder></mi><mtext>────────────</mtext><mi><munder><mo><mtext>─</mtext></mo><mrow><mspace width="-2em"><msup><mn>2</mn><mn>255</mn></msup><mo>−</mo><mn>1</mn></mspace></mrow></munder></mi><mtext>┤</mtext></mo><mrow><mspace width="1em"><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi></mspace></mrow></mover></mi><mi><mover><mo><mtext>├────</mtext><mi><munder><mo><mtext>─</mtext></mo><mrow><mspace width="-3.5em"><mo>−</mo><msup><mn>2</mn><mn>255</mn></msup></mspace></mrow></munder></mi><mtext>────────</mtext><mi><munder><mo><mtext>─</mtext></mo><mrow><mspace width="-0.4em"><mo>−</mo><mn>1</mn></mspace></mrow></munder></mi><mtext>┤</mtext></mo><mrow><mspace width="1em"><mi>n</mi><mi>e</mi><mi>g</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi></mspace></mrow></mover></mi></mrow><annotation encoding="application/x-tex">\overset{\hskip 1em positive}{
    ├\underset{0}{─}────────────\underset{\hskip -2em 2^{255} - 1}{─}┤
}
\overset{\hskip 1em negative}{
    ├────\underset{\hskip -3.5em - 2^{255}}─────────\underset{\hskip -0.4 em -1}{─}┤
}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.6555em;vertical-align:-0.8468em"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8088em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop"><span class="mord">├</span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0em"><span style="top:-2.3829em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop">─</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7171em"><span></span></span></span></span></span></span><span class="mord">────────────</span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0em"><span style="top:-2.3116em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mspace mtight" style="margin-right:-2.8571em"></span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em"><span style="top:-2.786em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">255</span></span></span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop">─</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8468em"><span></span></span></span></span></span></span><span class="mord">┤</span></span></span></span><span style="top:-3.2471em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mspace mtight" style="margin-right:1.4286em"></span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">os</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">v</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8468em"><span></span></span></span></span></span></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8088em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop"><span class="mord">├────</span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0em"><span style="top:-2.3116em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mspace mtight" style="margin-right:-5em"></span><span class="mord mtight">−</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em"><span style="top:-2.786em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">255</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop">─</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8468em"><span></span></span></span></span></span></span><span class="mord">────────</span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0em"><span style="top:-2.3829em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mspace mtight" style="margin-right:-0.5714em"></span><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop">─</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7754em"><span></span></span></span></span></span></span><span class="mord">┤</span></span></span></span><span style="top:-3.2471em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mspace mtight" style="margin-right:1.4286em"></span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">g</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">v</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8468em"><span></span></span></span></span></span></span></span></span></span></span></div>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#a77afe">0x0000000000000000000000000000000000000000000000000000000000000000</span><span> </span><span class="token" style="color:#6f705e">// 0</span><span>
</span></span><span><span></span><span class="token" style="color:#a77afe">0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span><span> </span><span class="token" style="color:#6f705e">// int256_max</span><span>
</span></span><span><span></span><span class="token" style="color:#a77afe">0x8000000000000000000000000000000000000000000000000000000000000000</span><span> </span><span class="token" style="color:#6f705e">// int256_min</span><span>
</span></span><span><span></span><span class="token" style="color:#a77afe">0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span><span> </span><span class="token" style="color:#6f705e">// -1</span></span></code></pre></pre>
<p>The maximum positive integer that can be represented in a two&#x27;s complement system using 256 bits is
<code>0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</code> which is roughly equal to half of the maximum value that can be represented using uint256.
The most significant bit of this number is <code>0</code>, while all other bits are <code>1</code>.</p>
<p>On the other hand, all negative numbers start with a <code>1</code> as their first bit.
If we look at the underlying hex representation of these numbers, they are all greater than or equal to the smallest integer that can be represented using int256, which is <code>0x8000000000000000000000000000000000000000000000000000000000000000</code>. The integer&#x27;s binary representation is a <code>1</code> followed by 255 <code>0</code>&#x27;s.</p>
<p>To obtain the negative value of an integer in a two&#x27;s complement system, we flip the underlying bits and add <code>1</code>: <code>-a = ~a + 1</code>.
An example illustrates this.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#a77afe">0x0000000000000000000000000000000000000000000000000000000000000003</span><span> </span><span class="token" style="color:#6f705e">// 3</span><span>
</span></span><span><span></span><span class="token" style="color:#a77afe">0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc</span><span> </span><span class="token" style="color:#6f705e">// ~3</span><span>
</span></span><span><span></span><span class="token" style="color:#a77afe">0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd</span><span> </span><span class="token" style="color:#6f705e">// -3 = ~3 + 1</span></span></code></pre></pre>
<p>To verify that <code>-a + a = 0</code> holds for all integers, we can use the property of two&#x27;s complement arithmetic that <code>-a = ~a + 1</code>.
By substituting this into the equation, we get <code>-a + a = (~a + 1) + a = MAX + 1 = 0</code>, where <code>MAX</code> is the maximum integer value.</p>
<p>In two&#x27;s complement arithmetic, there is a unique case that warrants special attention. The smallest possible integer <code>int256).min = 0x8000000000000000000000000000000000000000000000000000000000000000 = -57896044618658097711785492504343953926634992332820282019728792003956564819968</code>
does not have a positive inverse, making it the only negative number with this property.</p>
<p>Interestingly, if we try to compute <code>-type(int256).min</code>, we obtain the same number, as <code>-type(int256).min = ~type(int256).min + 1 = type(int256).min</code>.
This means there are two fixed points for additive inverses: <code>-0 = 0</code> and <code>-type(int256).min = type(int256).min</code>.
It&#x27;s important to note that Solidity&#x27;s arithmetic checks will throw an error when evaluating <code>-type(int256).min</code> (outside of unchecked blocks).</p>
<p>Examining the underlying bit (or hex) representation emphasizes the importance of using the correct operators for signed integers, such as <code>slt</code> instead of <code>lt</code>, to prevent misinterpreting negative values as large numbers.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span>  </span><span class="token" style="color:#a77afe">0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span><span> </span><span class="token" style="color:#6f705e">// int256(-1) or type(uint256).max</span><span>
</span></span><span><span></span><span class="token" style="color:#a77afe">&lt;</span><span> </span><span class="token" style="color:#a77afe">0x0000000000000000000000000000000000000000000000000000000000000000</span><span> </span><span class="token" style="color:#6f705e">// 0</span><span>
</span></span><span><span></span><span class="token" style="color:#6f705e">// When using `slt`, the comparison is interpreted as `-1 &lt; 0 = true`.</span><span>
</span></span><span><span></span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#a77afe">0x0000000000000000000000000000000000000000000000000000000000000001</span><span>
</span></span><span><span></span><span class="token" style="color:#6f705e">// When using `lt`, the comparison is interpreted as `type(uint256).max &lt; 0 = false`.</span><span>
</span></span><span><span></span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#a77afe">0x0000000000000000000000000000000000000000000000000000000000000000</span></span></code></pre></pre>
<p>Starting with Solidity versions 0.8.16, integer overflow is prevented by using the computed result <code>c = a + b</code> to check for overflow/underflow.
However, signed addition requires two separate checks instead of one, unlike unsigned addition.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#6f705e">/// @notice versions &gt;=0.8.16</span><span>
</span></span><span><span></span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">checkedAddInt2</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span> a</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">int256</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span> c</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    unchecked </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        c </span><span class="token" style="color:#a77afe">=</span><span> a </span><span class="token" style="color:#a77afe">+</span><span> b</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>        </span><span class="token" style="color:#6f705e">// If `a` is positive, then the sum `c = a + b` can&#x27;t be less than `b`.</span><span>
</span></span><span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span>a </span><span class="token" style="color:#a77afe">&gt;</span><span> </span><span class="token" style="color:#a77afe">0</span><span> </span><span class="token" style="color:#a77afe">&amp;&amp;</span><span> c </span><span class="token" style="color:#a77afe">&lt;</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token function">arithmeticError</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>        </span><span class="token" style="color:#6f705e">// If `a` is negative, then the sum `c = a + b` can&#x27;t be greater than `b`.</span><span>
</span></span><span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span>a </span><span class="token" style="color:#a77afe">&lt;</span><span> </span><span class="token" style="color:#a77afe">0</span><span> </span><span class="token" style="color:#a77afe">&amp;&amp;</span><span> c </span><span class="token" style="color:#a77afe">&gt;</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token function">arithmeticError</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>Nevertheless, by utilizing the boolean exclusive-or, we can combine these checks into a single step.
Although Solidity does not allow the <code>xor</code> operation for boolean values, it can be used in inline-assembly.
While doing so, it is important to validate our assumptions that both inputs are genuinely boolean (either <code>0</code> or <code>1</code>), as the xor operation functions bitwise and is not limited to only boolean values.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">checkedAddInt3</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span> a</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">int256</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span> c</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    unchecked </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        c </span><span class="token" style="color:#a77afe">=</span><span> a </span><span class="token" style="color:#a77afe">+</span><span> b</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>        </span><span class="token builtin">bool</span><span> overflow</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>        </span><span class="token" style="color:#ef3b7d">assembly</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>            </span><span class="token" style="color:#6f705e">// If `a &gt;= 0`, then the sum `c = a + b` can&#x27;t be less than `b`.</span><span>
</span></span><span><span>            </span><span class="token" style="color:#6f705e">// If `a &lt;  0`, then the sum `c = a + b` can&#x27;t be greater than `b`.</span><span>
</span></span><span><span>            </span><span class="token" style="color:#6f705e">// We combine these two conditions into one using `xor`.</span><span>
</span></span><span><span>            overflow </span><span class="token" style="color:#a77afe">:=</span><span> </span><span class="token function">xor</span><span class="token" style="color:#bebec5">(</span><span class="token function">slt</span><span class="token" style="color:#bebec5">(</span><span>a</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token" style="color:#a77afe">0</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token function">sgt</span><span class="token" style="color:#bebec5">(</span><span>b</span><span class="token" style="color:#bebec5">,</span><span> c</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span>
</span></span><span><span>        </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span>
</span><span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span>overflow</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token function">arithmeticError</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>An alternative approach to detecting overflow in addition is based on the observation that adding two integers with different signs will never result in an overflow.
This simplifies the check to the case when both operands have the same sign.
If the sign of the sum differs from one of the operands, the result has overflowed.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">checkedAddInt4</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span> a</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">int256</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span> c</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    unchecked </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        c </span><span class="token" style="color:#a77afe">=</span><span> a </span><span class="token" style="color:#a77afe">+</span><span> b</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>        </span><span class="token" style="color:#6f705e">// Overflow, if the signs of `a` and `b` are the same,</span><span>
</span></span><span><span>        </span><span class="token" style="color:#6f705e">// but the sign of the result `c = a + b` differs from its summands.</span><span>
</span></span><span><span>        </span><span class="token" style="color:#6f705e">// When the signs of `a` and `b` differ overflow is not possible.</span><span>
</span></span><span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#a77afe">~</span><span>a </span><span class="token" style="color:#a77afe">^</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">&amp;</span><span> </span><span class="token" style="color:#bebec5">(</span><span>a </span><span class="token" style="color:#a77afe">^</span><span> c</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">&lt;</span><span> </span><span class="token" style="color:#a77afe">0</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token function">arithmeticError</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>Instead of checking the sign bit explicitly, which can be done by shifting the value to the right by 255 bits and verifying that it is non-zero,
we can use the <code>slt</code> operation to compare the value with <code>0</code>.</p>
<h3 id="arithmetic-checks-for-uint256-subtraction"><a href="/blog/2023/arithmetic-checks#arithmetic-checks-for-uint256-subtraction"><span class="icon icon-link"></span></a>Arithmetic checks for uint256 subtraction</h3>
<p>The process of checking for underflow in subtraction is similar to that of addition.
When subtracting <code>a - b</code>, and <code>b</code> is greater than <code>a</code>, an underflow occurs.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">checkedSubUint</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">uint256</span><span> a</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">uint256</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">uint256</span><span> c</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    unchecked </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        c </span><span class="token" style="color:#a77afe">=</span><span> a </span><span class="token" style="color:#a77afe">-</span><span> b</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span>b </span><span class="token" style="color:#a77afe">&gt;</span><span> a</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token function">arithmeticError</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>Alternatively, we could perform the check on the result itself using <code>if (c &gt; a) arithmeticError();</code>, because subtracting a positive value from <code>a</code> should yield a value less than or equal to <code>a</code>.
However, in this case, we don&#x27;t save any operations.</p>
<p>Similar to addition, for signed integers, we can combine the checks for both scenarios into a single check using <code>xor</code>.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">checkedSubInt</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span> a</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">int256</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span> c</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    unchecked </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        c </span><span class="token" style="color:#a77afe">=</span><span> a </span><span class="token" style="color:#a77afe">-</span><span> b</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>        </span><span class="token builtin">bool</span><span> overflow</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>        </span><span class="token" style="color:#ef3b7d">assembly</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>            </span><span class="token" style="color:#6f705e">// If `b &gt;= 0`, then the result `c = a - b` can&#x27;t be greater than `a`.</span><span>
</span></span><span><span>            </span><span class="token" style="color:#6f705e">// If `b &lt;  0`, then the result `c = a - b` can&#x27;t be less than `a`.</span><span>
</span></span><span><span>            overflow </span><span class="token" style="color:#a77afe">:=</span><span> </span><span class="token function">xor</span><span class="token" style="color:#bebec5">(</span><span class="token function">sgt</span><span class="token" style="color:#bebec5">(</span><span>b</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token" style="color:#a77afe">0</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token function">sgt</span><span class="token" style="color:#bebec5">(</span><span>a</span><span class="token" style="color:#bebec5">,</span><span> c</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span>
</span></span><span><span>        </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span>
</span><span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span>overflow</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token function">arithmeticError</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<h3 id="arithmetic-checks-for-uint256-multiplication"><a href="/blog/2023/arithmetic-checks#arithmetic-checks-for-uint256-multiplication"><span class="icon icon-link"></span></a>Arithmetic checks for uint256 multiplication</h3>
<p>To detect overflow when multiplying two unsigned integers, we can use the approach of computing the maximum possible value of a multiplicand and check that it isn&#x27;t exceeded.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#6f705e">/// @notice versions &gt;=0.8.0 &amp;&amp; &lt;0.8.17</span><span>
</span></span><span><span></span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">checkedMulUint1</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">uint256</span><span> a</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">uint256</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">uint256</span><span> c</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    unchecked </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        c </span><span class="token" style="color:#a77afe">=</span><span> a </span><span class="token" style="color:#a77afe">*</span><span> b</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span>a </span><span class="token" style="color:#a77afe">!=</span><span> </span><span class="token" style="color:#a77afe">0</span><span> </span><span class="token" style="color:#a77afe">&amp;&amp;</span><span> b </span><span class="token" style="color:#a77afe">&gt;</span><span> </span><span class="token function">type</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">uint256</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">.</span><span>max </span><span class="token" style="color:#a77afe">/</span><span> a</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token function">arithmeticError</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<blockquote>
<p>The Solidity compiler always includes a zero check for all division and modulo operations, irrespective of whether an unchecked block is present.
The EVM itself, however, returns <code>0</code> when dividing by <code>0</code>, which applies to inline-assembly as well.
Evaluating the boolean expression <code>a != 0 &amp;&amp; b &gt; type(uint256).max / a</code> in reverse order would cause an incorrect reversion when <code>a = 0</code>.</p>
</blockquote>
<p>We can compute the maximum value for <code>b</code> as long as <code>a</code> is non-zero. However, if <code>a</code> is zero, we know that the result will be zero as well, and there is no need to check for overflow.
Like before, we can also make use of the result and try to reconstruct one multiplicand from it. This is possible if the product didn&#x27;t overflow and the first multiplicand is non-zero.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#6f705e">/// @notice versions &gt;=0.8.17</span><span>
</span></span><span><span></span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">checkedMulUint2</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">uint256</span><span> a</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">uint256</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">uint256</span><span> c</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    unchecked </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        c </span><span class="token" style="color:#a77afe">=</span><span> a </span><span class="token" style="color:#a77afe">*</span><span> b</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span>a </span><span class="token" style="color:#a77afe">!=</span><span> </span><span class="token" style="color:#a77afe">0</span><span> </span><span class="token" style="color:#a77afe">&amp;&amp;</span><span> b </span><span class="token" style="color:#a77afe">!=</span><span> c </span><span class="token" style="color:#a77afe">/</span><span> a</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token function">arithmeticError</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>For reference, we can further remove the additional division by zero check by writing the code in assembly.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">checkedMulUint3</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">uint256</span><span> a</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">uint256</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">uint256</span><span> c</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    unchecked </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        c </span><span class="token" style="color:#a77afe">=</span><span> a </span><span class="token" style="color:#a77afe">*</span><span> b</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>        </span><span class="token builtin">bool</span><span> overflow</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>        </span><span class="token" style="color:#ef3b7d">assembly</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>            </span><span class="token" style="color:#6f705e">// This version does not include a redundant division-by-0 check</span><span>
</span></span><span><span>            </span><span class="token" style="color:#6f705e">// which the Solidity compiler includes when performing `c / a`.</span><span>
</span></span><span><span>            overflow </span><span class="token" style="color:#a77afe">:=</span><span> </span><span class="token function">iszero</span><span class="token" style="color:#bebec5">(</span><span class="token function">or</span><span class="token" style="color:#bebec5">(</span><span class="token function">iszero</span><span class="token" style="color:#bebec5">(</span><span>a</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token function">eq</span><span class="token" style="color:#bebec5">(</span><span class="token function">div</span><span class="token" style="color:#bebec5">(</span><span>c</span><span class="token" style="color:#bebec5">,</span><span> a</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">,</span><span> b</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span>
</span></span><span><span>        </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span>
</span><span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span>overflow</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token function">arithmeticError</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<h3 id="arithmetic-checks-for-int256-multiplication"><a href="/blog/2023/arithmetic-checks#arithmetic-checks-for-int256-multiplication"><span class="icon icon-link"></span></a>Arithmetic checks for int256 multiplication</h3>
<p>In versions before 0.8.17, the Solidity compiler uses four separate checks to detect integer multiplication overflow.
The produced Yul code is equivalent to the following high-level Solidity code.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#6f705e">/// @notice versions &gt;=0.8.0 &amp;&amp; &lt;0.8.17</span><span>
</span></span><span><span></span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">checkedMulInt</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span> a</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">int256</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span> c</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    unchecked </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        c </span><span class="token" style="color:#a77afe">=</span><span> a </span><span class="token" style="color:#a77afe">*</span><span> b</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span>a </span><span class="token" style="color:#a77afe">&gt;</span><span> </span><span class="token" style="color:#a77afe">0</span><span> </span><span class="token" style="color:#a77afe">&amp;&amp;</span><span> b </span><span class="token" style="color:#a77afe">&gt;</span><span> </span><span class="token" style="color:#a77afe">0</span><span> </span><span class="token" style="color:#a77afe">&amp;&amp;</span><span> a </span><span class="token" style="color:#a77afe">&gt;</span><span> </span><span class="token function">type</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">.</span><span>max </span><span class="token" style="color:#a77afe">/</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token function">arithmeticError</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span>a </span><span class="token" style="color:#a77afe">&gt;</span><span> </span><span class="token" style="color:#a77afe">0</span><span> </span><span class="token" style="color:#a77afe">&amp;&amp;</span><span> b </span><span class="token" style="color:#a77afe">&lt;</span><span> </span><span class="token" style="color:#a77afe">0</span><span> </span><span class="token" style="color:#a77afe">&amp;&amp;</span><span> a </span><span class="token" style="color:#a77afe">&lt;</span><span> </span><span class="token function">type</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">.</span><span>min </span><span class="token" style="color:#a77afe">/</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token function">arithmeticError</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span>a </span><span class="token" style="color:#a77afe">&lt;</span><span> </span><span class="token" style="color:#a77afe">0</span><span> </span><span class="token" style="color:#a77afe">&amp;&amp;</span><span> b </span><span class="token" style="color:#a77afe">&gt;</span><span> </span><span class="token" style="color:#a77afe">0</span><span> </span><span class="token" style="color:#a77afe">&amp;&amp;</span><span> a </span><span class="token" style="color:#a77afe">&lt;</span><span> </span><span class="token function">type</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">.</span><span>min </span><span class="token" style="color:#a77afe">/</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token function">arithmeticError</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span>a </span><span class="token" style="color:#a77afe">&lt;</span><span> </span><span class="token" style="color:#a77afe">0</span><span> </span><span class="token" style="color:#a77afe">&amp;&amp;</span><span> b </span><span class="token" style="color:#a77afe">&lt;</span><span> </span><span class="token" style="color:#a77afe">0</span><span> </span><span class="token" style="color:#a77afe">&amp;&amp;</span><span> a </span><span class="token" style="color:#a77afe">&lt;</span><span> </span><span class="token function">type</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">.</span><span>max </span><span class="token" style="color:#a77afe">/</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token function">arithmeticError</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>Since Solidity version 0.8.17, the check is performed by utilizing the computed product in the check.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#6f705e">/// @notice versions &gt;=0.8.17</span><span>
</span></span><span><span></span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">checkedMulInt2</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span> a</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">int256</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span> c</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    unchecked </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        c </span><span class="token" style="color:#a77afe">=</span><span> a </span><span class="token" style="color:#a77afe">*</span><span> b</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span>a </span><span class="token" style="color:#a77afe">&lt;</span><span> </span><span class="token" style="color:#a77afe">0</span><span> </span><span class="token" style="color:#a77afe">&amp;&amp;</span><span> b </span><span class="token" style="color:#a77afe">==</span><span> </span><span class="token function">type</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">.</span><span>min</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token function">arithmeticError</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span>a </span><span class="token" style="color:#a77afe">!=</span><span> </span><span class="token" style="color:#a77afe">0</span><span> </span><span class="token" style="color:#a77afe">&amp;&amp;</span><span> b </span><span class="token" style="color:#a77afe">!=</span><span> c </span><span class="token" style="color:#a77afe">/</span><span> a</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token function">arithmeticError</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>When it comes to integer multiplication, it&#x27;s important to handle the case when <code>a &lt; 0</code> and <code>b == type(int256).min</code>.
The actual case, where the product <code>c</code> will overflow, is limited to <code>a == -1</code> and <code>b == type(int256).min</code>.
This is because <code>-b</code> cannot be represented as a positive signed integer, as previously mentioned.</p>
<h3 id="arithmetic-checks-for-addition-with-sub-32-byte-types"><a href="/blog/2023/arithmetic-checks#arithmetic-checks-for-addition-with-sub-32-byte-types"><span class="icon icon-link"></span></a>Arithmetic checks for addition with sub-32-byte types</h3>
<p>When performing arithmetic checks on data types that use less than 32 bytes, there are some additional steps to consider.
First, let&#x27;s take a look at the addition of signed 64-bit integers.</p>
<p>On a 64-bit system, integer addition works in the same way as before.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span>  </span><span class="token" style="color:#a77afe">0xfffffffffffffffe</span><span> </span><span class="token" style="color:#6f705e">// int64(-2)</span><span>
</span></span><span><span></span><span class="token" style="color:#a77afe">+</span><span> </span><span class="token" style="color:#a77afe">0x0000000000000003</span><span> </span><span class="token" style="color:#6f705e">// int64(3)</span><span>
</span></span><span><span></span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#a77afe">0x0000000000000001</span><span> </span><span class="token" style="color:#6f705e">// int64(1)</span></span></code></pre></pre>
<p>However, when performing the same calculations on a 256-bit machine, we need to extend the sign of the int64 value over all unused bits,
otherwise the value won&#x27;t be interpreted correctly.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span>                                   extended sign ──┐┌── </span><span class="token" style="color:#a77afe">64</span><span class="token" style="color:#a77afe">-</span><span>bit information
</span></span><span><span>  </span><span class="token" style="color:#a77afe">0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe</span><span> </span><span class="token" style="color:#6f705e">// int64(-2)</span><span>
</span></span><span><span></span><span class="token" style="color:#a77afe">+</span><span> </span><span class="token" style="color:#a77afe">0x0000000000000000000000000000000000000000000000000000000000000003</span><span> </span><span class="token" style="color:#6f705e">// int64(3)</span><span>
</span></span><span><span></span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#a77afe">0x0000000000000000000000000000000000000000000000000000000000000001</span><span> </span><span class="token" style="color:#6f705e">// int64(1)</span></span></code></pre></pre>
<p>It&#x27;s worth noting that not all operations require clean upper bits. In fact, even if the upper bits are dirty, we can still get correct results for addition. However, the sum will usually contain dirty upper bits that will need to be cleaned. For example, we can perform addition without knowledge of the upper bits.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span>  </span><span class="token" style="color:#a77afe">0</span><span>x</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span>fffffffffffffffe </span><span class="token" style="color:#6f705e">// int64(-2)</span><span>
</span></span><span><span></span><span class="token" style="color:#a77afe">+</span><span> </span><span class="token" style="color:#a77afe">0</span><span>x</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">0000000000000003</span><span> </span><span class="token" style="color:#6f705e">// int64(3)</span><span>
</span></span><span><span></span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#a77afe">0</span><span>x</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">?</span><span class="token" style="color:#a77afe">0000000000000001</span><span> </span><span class="token" style="color:#6f705e">// int64(1)</span></span></code></pre></pre>
<p>It is crucial to be mindful of when to clean the bits before and after operations.
By default, Solidity takes care of cleaning the bits before operations on smaller types and lets the optimizer remove any redundant steps.
However, values accessed after operations included by the compiler are not guaranteed to be clean. In particular, this is the case for addition with small data types.
For example, the bit cleaning steps will be removed by the optimizer (even without optimizations enabled) if a variable is only accessed in a subsequent assembly block.
Refer to the <a target="_blank" rel="noreferrer" class="link" href="https://docs.soliditylang.org/en/v0.8.18/internals/variable_cleanup.html#cleaning-up-variables">Solidity documentation</a> for further information on this matter.</p>
<p>When performing arithmetic checks in the same way as before, it is necessary to include a step to clean the bits on the sum.
One approach to achieve this is by performing <code>signextend(7, value)</code>, which extends the sign of a 64-bit (7 + 1 = 8 bytes) integer over all upper bits.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">checkedAddInt64_1</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int64</span><span> a</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">int64</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int64</span><span> c</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    unchecked </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        </span><span class="token builtin">bool</span><span> overflow</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>        c </span><span class="token" style="color:#a77afe">=</span><span> a </span><span class="token" style="color:#a77afe">+</span><span> b</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>        </span><span class="token" style="color:#ef3b7d">assembly</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>            </span><span class="token" style="color:#6f705e">// Note that we must manually clean the upper bits in this case.</span><span>
</span></span><span><span>            </span><span class="token" style="color:#6f705e">// Solidity will optimize the cleaning away otherwise.</span><span>
</span></span><span><span>            </span><span class="token" style="color:#6f705e">// Extend the sign of the sum to 256 bits.</span><span>
</span></span><span><span>            c </span><span class="token" style="color:#a77afe">:=</span><span> </span><span class="token function">signextend</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#a77afe">7</span><span class="token" style="color:#bebec5">,</span><span> c</span><span class="token" style="color:#bebec5">)</span><span>
</span></span><span>
</span><span><span>            </span><span class="token" style="color:#6f705e">// Perform the same arithmetic overflow check as before.</span><span>
</span></span><span><span>            overflow </span><span class="token" style="color:#a77afe">:=</span><span> </span><span class="token function">xor</span><span class="token" style="color:#bebec5">(</span><span class="token function">slt</span><span class="token" style="color:#bebec5">(</span><span>a</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token" style="color:#a77afe">0</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token function">sgt</span><span class="token" style="color:#bebec5">(</span><span>b</span><span class="token" style="color:#bebec5">,</span><span> c</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span>
</span></span><span><span>        </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span>
</span><span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span>overflow</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token function">arithmeticError</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>If we remove the line that includes <code>c := signextend(7, c)</code> the overflow check will not function correctly.
This is because Solidity does not take into account the fact that the variable is used in an assembly block, and the optimizer removes the bit cleaning operation, even if the Yul code includes it after the addition.</p>
<p>One thing to keep in mind is that since we are performing a 64-bit addition in 256 bits, we practically have access to the carry/overflow bits.
If our computed value does not overflow, then it will fall within the correct bounds <code>type(int64).min &lt;= c &lt;= type(int64).max</code>.
The actual overflow check in Solidity involves verifying both the upper and lower bounds.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#6f705e">/// @notice version &gt;= 0.8.16</span><span>
</span></span><span><span></span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">checkedAddInt64_2</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int64</span><span> a</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">int64</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int64</span><span> c</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    unchecked </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        </span><span class="token" style="color:#6f705e">// Perform the addition in int256.</span><span>
</span></span><span><span>        </span><span class="token builtin">int256</span><span> uc </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token builtin">int256</span><span class="token" style="color:#bebec5">(</span><span>a</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">+</span><span> b</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>        </span><span class="token" style="color:#6f705e">// If the value can not be represented by a int64, there is overflow.</span><span>
</span></span><span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span>uc </span><span class="token" style="color:#a77afe">&gt;</span><span> </span><span class="token function">type</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int64</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">.</span><span>max </span><span class="token" style="color:#a77afe">||</span><span> uc </span><span class="token" style="color:#a77afe">&lt;</span><span> </span><span class="token function">type</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int64</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">.</span><span>min</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token function">arithmeticError</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>        </span><span class="token" style="color:#6f705e">// We can safely cast the result.</span><span>
</span></span><span><span>        c </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token builtin">int64</span><span class="token" style="color:#bebec5">(</span><span>uc</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>There are a few ways to verify that the result in its 256-bit representation will fit into the expected data type.
This is only true when all upper bits are the same.
The most direct method, as previously shown, involves verifying both the lower and upper bounds.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#6f705e">/// @notice Check used in int64 addition for version &gt;= 0.8.16.</span><span>
</span></span><span><span></span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">overflowInt64</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span> value</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">bool</span><span> overflow</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    overflow </span><span class="token" style="color:#a77afe">=</span><span> value </span><span class="token" style="color:#a77afe">&gt;</span><span> </span><span class="token function">type</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int64</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">.</span><span>max </span><span class="token" style="color:#a77afe">||</span><span> value </span><span class="token" style="color:#a77afe">&lt;</span><span> </span><span class="token function">type</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int64</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">.</span><span>min</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>We can simplify the expression to a single comparison if we can shift the disjointed number domain back so that it&#x27;s connected.
To accomplish this, we subtract the smallest negative int64 <code>type(int64).min</code> from a value (or add the underlying unsigned value).
A better way to understand this is by visualizing the signed integer number domain in relation to the unsigned domain (which is demonstrated here using int128).</p>
<div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>u</mi><mi>i</mi><mi>n</mi><mi>t</mi><mn>256</mn><mtext> domain</mtext></mrow><annotation encoding="application/x-tex">uint256 \text{ domain}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span><span class="mord">256</span><span class="mord text"><span class="mord"> domain</span></span></span></span></span></span></div>
<div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>├</mtext><mi><munder><mo><mtext>─</mtext></mo><mn>0</mn></munder></mi><mtext>────────────────────────────</mtext><mi><munder><mo><mtext>─</mtext></mo><mrow><mspace width="-2em"><msup><mn>2</mn><mn>256</mn></msup><mo>−</mo><mn>1</mn></mspace></mrow></munder></mi><mtext>┤</mtext></mrow><annotation encoding="application/x-tex">├\underset{0}{─}────────────────────────────\underset{\hskip -2em 2^{256} - 1}{─}┤</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8468em;vertical-align:-0.8468em"></span><span class="mord">├</span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0em"><span style="top:-2.3829em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop">─</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7171em"><span></span></span></span></span></span></span><span class="mord">────────────────────────────</span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0em"><span style="top:-2.3116em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mspace mtight" style="margin-right:-2.8571em"></span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em"><span style="top:-2.786em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">256</span></span></span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop">─</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8468em"><span></span></span></span></span></span></span><span class="mord">┤</span></span></span></span></span></div>
<div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>i</mi><mi>n</mi><mi>t</mi><mn>256</mn><mtext> domain</mtext></mrow><annotation encoding="application/x-tex">int256 \text{ domain}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span><span class="mord">256</span><span class="mord text"><span class="mord"> domain</span></span></span></span></span></span></div>
<div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi><mover><mo><mtext>├</mtext><mi><munder><mo><mtext>─</mtext></mo><mn>0</mn></munder></mi><mtext>────────────</mtext><mi><munder><mo><mtext>─</mtext></mo><mrow><mspace width="-2em"><msup><mn>2</mn><mn>255</mn></msup><mo>−</mo><mn>1</mn></mspace></mrow></munder></mi><mtext>┤</mtext></mo><mrow><mspace width="1em"><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi></mspace></mrow></mover></mi><mi><mover><mo><mtext>├────</mtext><mi><munder><mo><mtext>─</mtext></mo><mrow><mspace width="-3.5em"><mo>−</mo><msup><mn>2</mn><mn>255</mn></msup></mspace></mrow></munder></mi><mtext>────────</mtext><mi><munder><mo><mtext>─</mtext></mo><mrow><mspace width="-0.4em"><mo>−</mo><mn>1</mn></mspace></mrow></munder></mi><mtext>┤</mtext></mo><mrow><mspace width="1em"><mi>n</mi><mi>e</mi><mi>g</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi></mspace></mrow></mover></mi></mrow><annotation encoding="application/x-tex">\overset{\hskip 1em positive}{
    ├\underset{0}{─}────────────\underset{\hskip -2em 2^{255} - 1}{─}┤
}
\overset{\hskip 1em negative}{
    ├────\underset{\hskip -3.5em - 2^{255}}─────────\underset{\hskip -0.4 em -1}{─}┤
}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.6555em;vertical-align:-0.8468em"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8088em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop"><span class="mord">├</span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0em"><span style="top:-2.3829em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop">─</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7171em"><span></span></span></span></span></span></span><span class="mord">────────────</span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0em"><span style="top:-2.3116em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mspace mtight" style="margin-right:-2.8571em"></span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em"><span style="top:-2.786em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">255</span></span></span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop">─</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8468em"><span></span></span></span></span></span></span><span class="mord">┤</span></span></span></span><span style="top:-3.2471em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mspace mtight" style="margin-right:1.4286em"></span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">os</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">v</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8468em"><span></span></span></span></span></span></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8088em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop"><span class="mord">├────</span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0em"><span style="top:-2.3116em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mspace mtight" style="margin-right:-5em"></span><span class="mord mtight">−</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em"><span style="top:-2.786em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">255</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop">─</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8468em"><span></span></span></span></span></span></span><span class="mord">────────</span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0em"><span style="top:-2.3829em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mspace mtight" style="margin-right:-0.5714em"></span><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop">─</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7754em"><span></span></span></span></span></span></span><span class="mord">┤</span></span></span></span><span style="top:-3.2471em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mspace mtight" style="margin-right:1.4286em"></span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">g</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">v</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8468em"><span></span></span></span></span></span></span></span></span></span></span></div>
<p>The domain for uint128/int128 can be visualized as follows.</p>
<div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>u</mi><mi>i</mi><mi>n</mi><mi>t</mi><mn>128</mn><mtext> domain</mtext></mrow><annotation encoding="application/x-tex">uint128 \text{ domain}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span><span class="mord">128</span><span class="mord text"><span class="mord"> domain</span></span></span></span></span></span></div>
<div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>├</mtext><mi><munder><mo><mtext>─</mtext></mo><mn>0</mn></munder></mi><mtext>────────────</mtext><mi><munder><mo><mtext>─</mtext></mo><mrow><mspace width="-2em"><msup><mn>2</mn><mn>128</mn></msup><mo>−</mo><mn>1</mn></mspace></mrow></munder></mi><mtext>┤</mtext><mphantom><mtext>───────────────</mtext></mphantom><mtext>┆</mtext></mrow><annotation encoding="application/x-tex">├\underset{0}─────────────\underset{\hskip -2em 2^{128}-1}─┤
\phantom{───────────────}┆</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8468em;vertical-align:-0.8468em"></span><span class="mord">├</span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0em"><span style="top:-2.3829em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop">─</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7171em"><span></span></span></span></span></span></span><span class="mord">────────────</span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0em"><span style="top:-2.3116em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mspace mtight" style="margin-right:-2.8571em"></span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em"><span style="top:-2.786em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">128</span></span></span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop">─</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8468em"><span></span></span></span></span></span></span><span class="mord">┤</span><span class="mord" style="color:transparent">───────────────</span><span class="mord">┆</span></span></span></span></span></div>
<div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>i</mi><mi>n</mi><mi>t</mi><mn>128</mn><mtext> domain</mtext></mrow><annotation encoding="application/x-tex">int128 \text{ domain}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">in</span><span class="mord mathnormal">t</span><span class="mord">128</span><span class="mord text"><span class="mord"> domain</span></span></span></span></span></span></div>
<div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi><mover><mo><mtext>├</mtext><mi><munder><mo><mtext>─</mtext></mo><mn>0</mn></munder></mi><mtext>────</mtext><mi><munder><mo><mtext>─</mtext></mo><mrow><mspace width="-2em"><msup><mn>2</mn><mn>127</mn></msup><mo>−</mo><mn>1</mn></mspace></mrow></munder></mi><mtext>┤</mtext></mo><mrow><mspace width="1em"><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi></mspace></mrow></mover></mi><mphantom><mtext>────────────────</mtext></mphantom><mi><mover><mo><mtext>├────</mtext><mi><munder><mo><mtext>─</mtext></mo><mrow><mspace width="-3.5em"><mo>−</mo><msup><mn>2</mn><mn>127</mn></msup></mspace></mrow></munder></mi><mi><munder><mo><mtext>─</mtext></mo><mrow><mspace width="-0.4em"><mo>−</mo><mn>1</mn></mspace></mrow></munder></mi><mtext>┤</mtext></mo><mrow><mspace width="1em"><mi>n</mi><mi>e</mi><mi>g</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi></mspace></mrow></mover></mi></mrow><annotation encoding="application/x-tex">\overset{\hskip 1em positive}{
    ├\underset{0}{─}────\underset{\hskip -2em 2^{127} - 1}{─}┤
}
\phantom{────────────────}
\overset{\hskip 1em negative}{
    ├────\underset{\hskip -3.5em - 2^{127}}─\underset{\hskip -0.4 em -1}{─}┤
}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.6555em;vertical-align:-0.8468em"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8088em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop"><span class="mord">├</span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0em"><span style="top:-2.3829em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop">─</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7171em"><span></span></span></span></span></span></span><span class="mord">────</span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0em"><span style="top:-2.3116em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mspace mtight" style="margin-right:-2.8571em"></span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em"><span style="top:-2.786em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">127</span></span></span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop">─</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8468em"><span></span></span></span></span></span></span><span class="mord">┤</span></span></span></span><span style="top:-3.2471em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mspace mtight" style="margin-right:1.4286em"></span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">os</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">v</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8468em"><span></span></span></span></span></span></span><span class="mord" style="color:transparent">────────────────</span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8088em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop"><span class="mord">├────</span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0em"><span style="top:-2.3116em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mspace mtight" style="margin-right:-5em"></span><span class="mord mtight">−</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em"><span style="top:-2.786em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">127</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop">─</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8468em"><span></span></span></span></span></span></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0em"><span style="top:-2.3829em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mspace mtight" style="margin-right:-0.5714em"></span><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop">─</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7754em"><span></span></span></span></span></span></span><span class="mord">┤</span></span></span></span><span style="top:-3.2471em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mspace mtight" style="margin-right:1.4286em"></span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">g</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">v</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8468em"><span></span></span></span></span></span></span></span></span></span></span></div>
<p>Note that the scales of the number ranges in the previous section do not accurately depict the magnitude of numbers that are representable with the different types and only serve as a visualization. We can represent twice as many numbers with only one additional bit, yet the uint256 domain has twice the number of bits compared to uint128.</p>
<p>After subtracting <code>type(int128).min</code> (or adding <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>127</mn></msup></mrow><annotation encoding="application/x-tex">2^{127}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">127</span></span></span></span></span></span></span></span></span></span></span></span></span>) and essentially shifting the domains to the right, we get the following, connected set of values.</p>
<div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>├</mtext><mi><munder><mo><mtext>─</mtext></mo><mn>0</mn></munder></mi><mtext>────────────</mtext><mi><munder><mo><mtext>─</mtext></mo><mrow><mspace width="-2em"><msup><mn>2</mn><mn>128</mn></msup><mo>−</mo><mn>1</mn></mspace></mrow></munder></mi><mtext>┤</mtext><mphantom><mtext>───────────────</mtext></mphantom><mtext>┆</mtext></mrow><annotation encoding="application/x-tex">├\underset{0}─────────────\underset{\hskip -2em 2^{128}-1}─┤
\phantom{───────────────}┆</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8468em;vertical-align:-0.8468em"></span><span class="mord">├</span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0em"><span style="top:-2.3829em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop">─</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7171em"><span></span></span></span></span></span></span><span class="mord">────────────</span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0em"><span style="top:-2.3116em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mspace mtight" style="margin-right:-2.8571em"></span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463em"><span style="top:-2.786em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">128</span></span></span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop">─</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8468em"><span></span></span></span></span></span></span><span class="mord">┤</span><span class="mord" style="color:transparent">───────────────</span><span class="mord">┆</span></span></span></span></span></div>
<div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi><mover><mo><mtext>├──────┤</mtext></mo><mrow><mspace width="1em"><mi>n</mi><mi>e</mi><mi>g</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi></mspace></mrow></mover></mi><mi><mover><mo><mtext>├──────┤</mtext></mo><mrow><mspace width="1em"><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi></mspace></mrow></mover></mi><mphantom><mtext>───────────────</mtext></mphantom><mtext>┆</mtext></mrow><annotation encoding="application/x-tex">\overset{\hskip 1em negative}{├──────┤}
\overset{\hskip 1em positive}{├──────┤}
\phantom{───────────────}┆</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8088em"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8088em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop">├──────┤</span></span></span><span style="top:-3.2471em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mspace mtight" style="margin-right:1.4286em"></span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">g</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">v</span><span class="mord mathnormal mtight">e</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mop op-limits"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8088em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span><span class="mop">├──────┤</span></span></span><span style="top:-3.2471em;margin-left:0em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mspace mtight" style="margin-right:1.4286em"></span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">os</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">v</span><span class="mord mathnormal mtight">e</span></span></span></span></span></span></span></span></span><span class="mord" style="color:transparent">───────────────</span><span class="mord">┆</span></span></span></span></span></div>
<p>If we interpret the shifted value as an unsigned integer, we only need to check whether it exceeds the maximum unsigned integer <code>type(uint128).max</code>.
The corresponding check in Solidity is shown below.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">overflowInt64_2</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span> value</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">bool</span><span> overflow</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    unchecked </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        overflow </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token builtin">uint256</span><span class="token" style="color:#bebec5">(</span><span>value</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">-</span><span> </span><span class="token builtin">uint256</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span class="token" style="color:#bebec5">(</span><span class="token function">type</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int64</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">.</span><span>min</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">&gt;</span><span> </span><span class="token function">type</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">uint64</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">.</span><span>max</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>In this case the verbose assembly code might actually be easier to follow than the Solidity code which sometimes contains implicit operations.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token builtin">int64</span><span> </span><span class="token" style="color:#ef3b7d">constant</span><span> INT64_MIN </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#a77afe">-</span><span class="token" style="color:#a77afe">0x8000000000000000</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span></span><span class="token builtin">uint64</span><span> </span><span class="token" style="color:#ef3b7d">constant</span><span> UINT64_MAX </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#a77afe">0xffffffffffffffff</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span></span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">overflowInt64_2_yul</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span> value</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">bool</span><span> overflow</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    </span><span class="token" style="color:#ef3b7d">assembly</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        overflow </span><span class="token" style="color:#a77afe">:=</span><span> </span><span class="token function">gt</span><span class="token" style="color:#bebec5">(</span><span class="token function">sub</span><span class="token" style="color:#bebec5">(</span><span>value</span><span class="token" style="color:#bebec5">,</span><span> INT64_MIN</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">,</span><span> UINT64_MAX</span><span class="token" style="color:#bebec5">)</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>As mentioned earlier, this approach is only effective for negative numbers when all of their upper bits are set to <code>1</code>, allowing us to overflow back into the positive domain.
An alternative and more straightforward method would be to simply verify that all of the upper bits are equivalent to the sign bit for all integers.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">overflowInt64_3</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span> value</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">bool</span><span> overflow</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    overflow </span><span class="token" style="color:#a77afe">=</span><span> value </span><span class="token" style="color:#a77afe">!=</span><span> </span><span class="token builtin">int64</span><span class="token" style="color:#bebec5">(</span><span>value</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>In Yul, the equivalent resembles the following.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">overflowInt64_3_yul</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span> value</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">bool</span><span> overflow</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    </span><span class="token" style="color:#ef3b7d">assembly</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        overflow </span><span class="token" style="color:#a77afe">:=</span><span> </span><span class="token function">iszero</span><span class="token" style="color:#bebec5">(</span><span class="token function">eq</span><span class="token" style="color:#bebec5">(</span><span>value</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token function">signextend</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#a77afe">7</span><span class="token" style="color:#bebec5">,</span><span> value</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>Another way of extending the sign is to make use of <code>sar</code> (signed arithmetic right shift).</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">overflowInt64_4</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span> value</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">bool</span><span> overflow</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    overflow </span><span class="token" style="color:#a77afe">=</span><span> value </span><span class="token" style="color:#a77afe">!=</span><span> </span><span class="token" style="color:#bebec5">(</span><span>value </span><span class="token" style="color:#a77afe">&lt;&lt;</span><span> </span><span class="token" style="color:#a77afe">192</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">&gt;&gt;</span><span> </span><span class="token" style="color:#a77afe">192</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span>
</span><span><span></span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">overflowInt64_4_yul</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span> value</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">bool</span><span> overflow</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    </span><span class="token" style="color:#ef3b7d">assembly</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        overflow </span><span class="token" style="color:#a77afe">:=</span><span> </span><span class="token function">iszero</span><span class="token" style="color:#bebec5">(</span><span class="token function">eq</span><span class="token" style="color:#bebec5">(</span><span>value</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token function">sar</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#a77afe">192</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token function">shl</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#a77afe">192</span><span class="token" style="color:#bebec5">,</span><span> value</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>Finally, a full example for detecting signed 64-bit integer overflow, implemented in Solidity can be seen below:</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">checkedAddInt64_2</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int64</span><span> a</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">int64</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int64</span><span> c</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    unchecked </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        </span><span class="token" style="color:#6f705e">// Cast the first summand.</span><span>
</span></span><span><span>        </span><span class="token" style="color:#6f705e">// The second summand is implicitly casted.</span><span>
</span></span><span><span>        </span><span class="token builtin">int256</span><span> uc </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token builtin">int256</span><span class="token" style="color:#bebec5">(</span><span>a</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">+</span><span> b</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>        </span><span class="token" style="color:#6f705e">// Check whether the result `uc` can be represented by 64 bits</span><span>
</span></span><span><span>        </span><span class="token" style="color:#6f705e">// by shifting the values to the uint64 domain.</span><span>
</span></span><span><span>        </span><span class="token" style="color:#6f705e">// This is done by subtracting the smallest value in int64.</span><span>
</span></span><span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">uint256</span><span class="token" style="color:#bebec5">(</span><span>uc</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">-</span><span> </span><span class="token builtin">uint256</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int256</span><span class="token" style="color:#bebec5">(</span><span class="token function">type</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int64</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">.</span><span>min</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">&gt;</span><span> </span><span class="token function">type</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">uint64</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">.</span><span>max</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token function">arithmeticError</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>        </span><span class="token" style="color:#6f705e">// We can safely cast the result.</span><span>
</span></span><span><span>        c </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token builtin">int64</span><span class="token" style="color:#bebec5">(</span><span>uc</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>One further optimization that we could perform is to add <code>-type(int64).min</code> instead of subtracting <code>type(int64).min</code>. This would not reduce computation costs, however it could end up reducing bytecode size. This is because when we subtract <code>-type(int64).min</code>, we need to push 32 bytes (<code>0xffffffffffffffffffffffffffffffffffffffffffffffff8000000000000000</code>), whereas when we add <code>-type(int64).min</code>, we only end up pushing 8 bytes (<code>0x8000000000000000</code>). However, as soon as we turn on compiler optimizations, the produced bytecode ends up being the same.</p>
<h3 id="arithmetic-checks-for-multiplication-with-sub-32-byte-types"><a href="/blog/2023/arithmetic-checks#arithmetic-checks-for-multiplication-with-sub-32-byte-types"><span class="icon icon-link"></span></a>Arithmetic checks for multiplication with sub-32-byte types</h3>
<p>When the product <code>c = a * b</code> can be calculated in 256 bits without the possibility of overflowing, we can verify whether the result can fit into the anticipated data type. This is also the way Solidity handles the check in versions 0.8.17 and later.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#6f705e">/// @notice version &gt;= 0.8.17</span><span>
</span></span><span><span></span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">checkedMulInt64</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int64</span><span> a</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">int64</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int64</span><span> c</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    unchecked </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        </span><span class="token builtin">int256</span><span> uc </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token builtin">int256</span><span class="token" style="color:#bebec5">(</span><span>a</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">*</span><span> </span><span class="token builtin">int256</span><span class="token" style="color:#bebec5">(</span><span>b</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>        </span><span class="token" style="color:#6f705e">// If the product can not be represented with 64 bits,</span><span>
</span></span><span><span>        </span><span class="token" style="color:#6f705e">// there is overflow.</span><span>
</span></span><span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token function">overflowInt64</span><span class="token" style="color:#bebec5">(</span><span>uc</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token function">arithmeticError</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>        c </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token builtin">int64</span><span class="token" style="color:#bebec5">(</span><span>uc</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>However, if the maximum value of a product exceeds 256 bits, then this method won&#x27;t be effective.
This happens, for instance, when working with int192. The product <code>type(int192).min * type(int192).min</code> requires 192 + 192 = 384 bits to be stored, which exceeds the maximum of 256 bits.
Overflow occurs in 256 bits, causing a loss of information, and it won&#x27;t be logical to check if the result fits into 192 bits.
In this scenario, we can rely on the previous checks and, for example, attempt to reconstruct one of the multiplicands.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">checkedMulInt192_1</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int192</span><span> a</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">int192</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int192</span><span> c</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    unchecked </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        c </span><span class="token" style="color:#a77afe">=</span><span> a </span><span class="token" style="color:#a77afe">*</span><span> b</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span>a </span><span class="token" style="color:#a77afe">!=</span><span> </span><span class="token" style="color:#a77afe">0</span><span> </span><span class="token" style="color:#a77afe">&amp;&amp;</span><span> b </span><span class="token" style="color:#a77afe">!=</span><span> c </span><span class="token" style="color:#a77afe">/</span><span> a</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token function">arithmeticError</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span>a </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#a77afe">-</span><span class="token" style="color:#a77afe">1</span><span> </span><span class="token" style="color:#a77afe">&amp;&amp;</span><span> b </span><span class="token" style="color:#a77afe">==</span><span> </span><span class="token function">type</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int192</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">.</span><span>min</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token function">arithmeticError</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>We must consider the two special circumstances:</p>
<ol>
<li>When one of the multiplicands is zero (<code>a == 0</code>), the other multiplicand cannot be retrieved. However, this case never results in overflow.</li>
<li>Even if the multiplication is correct in 256 bits, the calculation overflows when only examining the least-significant 192 bits if the first multiplicand is negative one (<code>a = -1</code>) and the other multiplicand is the minimum value.</li>
</ol>
<p>An example might help explain the second case.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span>  </span><span class="token" style="color:#a77afe">0xffffffffffffffff800000000000000000000000000000000000000000000000</span><span> </span><span class="token" style="color:#6f705e">// type(int192).min</span><span>
</span></span><span><span></span><span class="token" style="color:#a77afe">*</span><span> </span><span class="token" style="color:#a77afe">0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span><span> </span><span class="token" style="color:#6f705e">// -1</span><span>
</span></span><span><span></span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#a77afe">0x0000000000000000800000000000000000000000000000000000000000000000</span><span> </span><span class="token" style="color:#6f705e">// type(int192).min (when seen as a int192)</span></span></code></pre></pre>
<p>A method to address this issue is to always start by sign-extending or cleaning the result before attempting to reconstruct the other multiplicand.
By doing so, it eliminates the need to check for the special condition.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#6f705e">/// @notice version &gt;= 0.8.17</span><span>
</span></span><span><span></span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">checkedMulInt192_2</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int192</span><span> a</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">int192</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int192</span><span> c</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    unchecked </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        </span><span class="token builtin">bool</span><span> overflow</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>        </span><span class="token" style="color:#ef3b7d">assembly</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>            </span><span class="token" style="color:#6f705e">// Extend the sign for int192 (24 = 23 + 1 bytes).</span><span>
</span></span><span><span>            c </span><span class="token" style="color:#a77afe">:=</span><span> </span><span class="token function">signextend</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#a77afe">23</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token function">mul</span><span class="token" style="color:#bebec5">(</span><span>a</span><span class="token" style="color:#bebec5">,</span><span> b</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span>
</span></span><span>
</span><span><span>            </span><span class="token" style="color:#6f705e">// Overflow, if `a != 0 &amp;&amp; b != c / a`.</span><span>
</span></span><span><span>            overflow </span><span class="token" style="color:#a77afe">:=</span><span> </span><span class="token function">iszero</span><span class="token" style="color:#bebec5">(</span><span class="token function">or</span><span class="token" style="color:#bebec5">(</span><span class="token function">iszero</span><span class="token" style="color:#bebec5">(</span><span>a</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token function">eq</span><span class="token" style="color:#bebec5">(</span><span>b</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token function">sdiv</span><span class="token" style="color:#bebec5">(</span><span>c</span><span class="token" style="color:#bebec5">,</span><span> a</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span>
</span></span><span><span>        </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span>
</span><span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span>overflow</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token function">arithmeticError</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<h3 id="conclusion"><a href="/blog/2023/arithmetic-checks#conclusion"><span class="icon icon-link"></span></a>Conclusion</h3>
<p>In conclusion, we hope this article has served as an informative guide on signed integer arithmetic within the EVM and the two&#x27;s complement system.
We have explored:</p>
<ul>
<li>the added complexity from handling signed over unsigned integers</li>
<li>the intricacies involved in managing sub 32-byte types</li>
<li>the significance of <code>signextend</code> and opcodes related to signed integers</li>
<li>the importance of bit-cleaning</li>
</ul>
<p>While low-level optimizations are attractive, they are also heavily error-prone. This article aims to deepen one&#x27;s understanding of low-level arithmetic, to reduce these risks. Nevertheless, it is crucial to integrate custom low-level optimizations only after thorough manual analysis, automated testing, and to document any non-obvious assumptions.</p></div></div></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"slug":["blog","2023","arithmetic-checks"],"contentRaw":"\n\u003e This post was created during my time at Trail of Bits. It is featured in the [secure-contracts/learn-evm](https://secure-contracts.com/learn_evm/arithmetic-checks).\n\n**Table of Contents**\n\n- [Arithmetic checks for uint256 addition](#arithmetic-checks-for-uint256-addition)\n- [Arithmetic checks for int256 addition](#arithmetic-checks-for-int256-addition)\n  - [Quick primer on a two's complement system](#quick-primer-on-a-twos-complement-system)\n- [Arithmetic checks for uint256 subtraction](#arithmetic-checks-for-uint256-subtraction)\n- [Arithmetic checks for uint256 multiplication](#arithmetic-checks-for-uint256-multiplication)\n- [Arithmetic checks for int256 multiplication](#arithmetic-checks-for-int256-multiplication)\n- [Arithmetic checks for addition with sub-32-byte types](#arithmetic-checks-for-addition-with-sub-32-byte-types)\n- [Arithmetic checks for multiplication with sub-32-byte types](#arithmetic-checks-for-multiplication-with-sub-32-byte-types)\n- [Conclusion](#conclusion)\n\nThe Ethereum Virtual Machine (EVM) distinguishes itself from other virtual machines and computer systems through several unique aspects.\nOne notable difference is its treatment of arithmetic checks.\nWhile most architectures and virtual machines provide access to carry bits or an overflow flag,\nthese features are absent in the EVM.\nConsequently, these safeguards must be incorporated within the machine's constraints.\n\nStarting with Solidity version 0.8.0 the compiler automatically includes over and underflow protection in all arithmetic operations.\nPrior to version 0.8.0, developers were required to implement these checks manually, often using a library known as [SafeMath](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol), originally developed by OpenZeppelin.\nThe compiler incorporates arithmetic checks in a manner similar to SafeMath, through additional operations.\n\nAs the Solidity language has evolved, the compiler has generated increasingly optimized code for arithmetic checks. This trend is also observed in smart contract development in general, where highly optimized arithmetic code written in low-level assembly is becoming more common. However, there is still a lack of comprehensive resources explaining the nuances of how the EVM handles arithmetic for signed and unsigned integers of 256 bits and less.\n\nThis article serves as a guide for gaining a deeper understanding of arithmetic in the EVM by exploring various ways to perform arithmetic checks. We'll learn more about the two's complement system and some lesser-known opcodes. This article is designed for those curious about the EVM's inner workings and those interested in bit manipulations in general. A basic understanding of bitwise arithmetic and Solidity opcodes is assumed.\n\nAdditional references for complementary reading are:\n\n- [evm.codes](https://evm.codes)\n- [Understanding Two's Complement](https://www.geeksforgeeks.org/twos-complement/)\n\n\u003e **Disclaimer:** Please note that this article is for educational purposes.\n\u003e It is not our intention to encourage micro optimizations in order to save gas,\n\u003e as this can potentially introduce new, hard-to-detect bugs that may compromise the security and stability of a protocol.\n\u003e As a developer, prioritize the safety and security of the protocol over [premature optimizations](https://www.youtube.com/watch?v=tKbV6BpH-C8).\n\u003e Including redundant checks for critical operations may be a good practice when the protocol code is still evolving.\n\u003e However, we do encourage experimentation with these operations for educational purposes.\n\n## Arithmetic checks for uint256 addition\n\nTo examine how the solc compiler implements arithmetic checks, we can compile the code with the `--asm` flag and inspect the resulting bytecode.\nAlternatively, using the `--ir` flag allows us to examine the Yul code that is generated as an intermediate representation (IR).\n\n\u003e Note that Solidity aims to make the new Yul pipeline the standard.\n\u003e Certain operations (including arithmetic checks) are always included as Yul code, regardless of whether the code is compiled with the new pipeline using `--via-ir`.\n\u003e This provides an opportunity to examine the Yul code and gain a better understanding of how arithmetic checks are executed in Solidity.\n\u003e However, keep in mind that the final bytecode may differ slightly when compiler optimizations are turned on.\n\nTo illustrate how the compiler detects overflow in unsigned integer addition, consider the following example of Yul code produced by the compiler before version 0.8.16.\n\n```solidity\nfunction checked_add_t_uint256(x, y) -\u003e sum {\n    x := cleanup_t_uint256(x)\n    y := cleanup_t_uint256(y)\n\n    // overflow, if x \u003e (maxValue - y)\n    if gt(x, sub(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, y)) { panic_error_0x11() }\n\n    sum := add(x, y)\n}\n```\n\nTo improve readability, we can translate the Yul code back into high-level Solidity code.\n\n```solidity\n/// @notice versions \u003e=0.8.0 \u0026\u0026 \u003c0.8.16\nfunction checkedAddUint1(uint256 a, uint256 b) public pure returns (uint256 c) {\n    unchecked {\n        c = a + b;\n\n        if (a \u003e type(uint256).max - b) arithmeticError();\n    }\n}\n```\n\n\u003e Solidity's arithmetic errors are encoded as `abi.encodeWithSignature(\"Panic(uint256)\", 0x11)`.\n\nThe check for overflow in unsigned integer addition involves calculating the largest value that one summand can have when added to the other without causing an overflow.\nSpecifically, in this case, the maximum value `a` can have is `type(uint256).max - b`.\nIf `a` exceeds this value, we can conclude that `a + b` will overflow.\n\nAn alternative and slightly more efficient approach for computing the maximum value of `a` involves inverting the bits of `b`.\n\n```solidity\n/// @notice versions \u003e=0.8.0 \u0026\u0026 \u003c0.8.16 with compiler optimizations\nfunction checkedAddUint2(uint256 a, uint256 b) public pure returns (uint256 c) {\n    unchecked {\n        c = a + b;\n\n        if (a \u003e ~b) arithmeticError();\n    }\n}\n```\n\nThis is process is equivalent, because `type(uint256).max` is a 256-bit integer with all its bits set to `1`.\nSubtracting `b` from `type(uint256).max` can be viewed as inverting each bit in `b`.\nThis transformation is demonstrated by `~b = ~(0 ^ b) = ~0 ^ b = MAX ^ b = MAX - b`.\n\n\u003e Note that `a - b = a ^ b` is **NOT** a general rule, except in special cases, such as when one of the values equals `type(uint256).max`.\n\u003e The relation `~b + 1 = 0 - b = -b` is also obtained if we add `1` mod `2**256` to both sides of the previous equation.\n\nBy first calculating the result of the addition and then performing a check on the sum, the need performing extra arithmetic operations are removed.\nThis is how the compiler implements arithmetic checks for unsigned integer addition in versions 0.8.16 and later.\n\n```solidity\n/// @notice versions \u003e=0.8.16\nfunction checkedAddUint(uint256 a, uint256 b) public pure returns (uint256 c) {\n    unchecked {\n        c = a + b;\n\n        if (a \u003e c) arithmeticError();\n    }\n}\n```\n\nOverflow is detected when the sum is smaller than one of its addends.\nIn other words, if `a \u003e a + b`, then overflow has occurred.\nTo fully prove this, it is necessary to verify that overflow occurs if and only if `a \u003e a + b`.\nAn important observation is that `a \u003e a + b` (mod `2**256`) for `b \u003e 0` is only possible when `b \u003e= 2**256`, which exceeds the maximum possible value.\n\n## Arithmetic checks for int256 addition\n\nThe Solidity compiler generates the following (equivalent) code for detecting overflow in signed integer addition for versions below 0.8.16.\n\n```solidity\n/// @notice versions \u003e=0.8.0 \u0026\u0026 \u003c0.8.16\nfunction checkedAddInt(int256 a, int256 b) public pure returns (int256 c) {\n    unchecked {\n        c = a + b;\n\n        // If `a \u003e 0`, then `b` can't exceed `type(int256).max - a`.\n        if (a \u003e 0 \u0026\u0026 b \u003e type(int256).max - a) arithmeticError();\n        // If `a \u003c 0`, then `b` can't be less than `type(int256).min - a`.\n        if (a \u003c 0 \u0026\u0026 b \u003c type(int256).min - a) arithmeticError();\n    }\n}\n```\n\nSimilar to the previous example, we can compute the maximum and minimum value of one addend, given that the other is either positive or negative.\n\nFor reference, this is the Yul code that is produced when compiling via IR.\n\n```solidity\nfunction checked_add_t_int256(x, y) -\u003e sum {\n    x := cleanup_t_int256(x)\n    y := cleanup_t_int256(y)\n\n    // overflow, if x \u003e= 0 and y \u003e (maxValue - x)\n    if and(iszero(slt(x, 0)), sgt(y, sub(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, x))) { panic_error_0x11() }\n    // underflow, if x \u003c 0 and y \u003c (minValue - x)\n    if and(slt(x, 0), slt(y, sub(0x8000000000000000000000000000000000000000000000000000000000000000, x))) { panic_error_0x11() }\n\n    sum := add(x, y)\n}\n```\n\nIt's important to note that when comparing signed values, the opcodes `slt` (signed less than) and `sgt` (signed greater than) must be used to avoid interpreting signed integers as unsigned integers.\nSolidity will automatically insert the correct opcode based on the value's type. This applies to other signed operations as well.\n\n### Quick primer on a two's complement system\n\nIn a two's complement system, the range of possible integers is divided into two halves: the positive and negative domains.\nThe first bit of an integer represents the sign, with `0` indicating a positive number and `1` indicating a negative number.\nFor positive integers (those with a sign bit of `0`), their binary representation is the same as their unsigned bit representation.\nHowever, the negative domain is shifted to lie \"above\" the positive domain.\n\n$$\nuint256 \\text{ domain}\n$$\n\n$$\n├\\underset{0}{─}────────────────────────────\\underset{\\hskip -2em 2^{256} - 1}{─}┤\n$$\n\n```solidity\n0x0000000000000000000000000000000000000000000000000000000000000000 // 0\n0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff // uint256_max\n```\n\n$$\nint256 \\text{ domain}\n$$\n\n$$\n\\overset{\\hskip 1em positive}{\n    ├\\underset{0}{─}────────────\\underset{\\hskip -2em 2^{255} - 1}{─}┤\n}\n\\overset{\\hskip 1em negative}{\n    ├────\\underset{\\hskip -3.5em - 2^{255}}─────────\\underset{\\hskip -0.4 em -1}{─}┤\n}\n$$\n\n```solidity\n0x0000000000000000000000000000000000000000000000000000000000000000 // 0\n0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff // int256_max\n0x8000000000000000000000000000000000000000000000000000000000000000 // int256_min\n0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff // -1\n```\n\nThe maximum positive integer that can be represented in a two's complement system using 256 bits is\n`0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff` which is roughly equal to half of the maximum value that can be represented using uint256.\nThe most significant bit of this number is `0`, while all other bits are `1`.\n\nOn the other hand, all negative numbers start with a `1` as their first bit.\nIf we look at the underlying hex representation of these numbers, they are all greater than or equal to the smallest integer that can be represented using int256, which is `0x8000000000000000000000000000000000000000000000000000000000000000`. The integer's binary representation is a `1` followed by 255 `0`'s.\n\nTo obtain the negative value of an integer in a two's complement system, we flip the underlying bits and add `1`: `-a = ~a + 1`.\nAn example illustrates this.\n\n```solidity\n0x0000000000000000000000000000000000000000000000000000000000000003 // 3\n0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc // ~3\n0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd // -3 = ~3 + 1\n```\n\nTo verify that `-a + a = 0` holds for all integers, we can use the property of two's complement arithmetic that `-a = ~a + 1`.\nBy substituting this into the equation, we get `-a + a = (~a + 1) + a = MAX + 1 = 0`, where `MAX` is the maximum integer value.\n\nIn two's complement arithmetic, there is a unique case that warrants special attention. The smallest possible integer `int256).min = 0x8000000000000000000000000000000000000000000000000000000000000000 = -57896044618658097711785492504343953926634992332820282019728792003956564819968`\ndoes not have a positive inverse, making it the only negative number with this property.\n\nInterestingly, if we try to compute `-type(int256).min`, we obtain the same number, as `-type(int256).min = ~type(int256).min + 1 = type(int256).min`.\nThis means there are two fixed points for additive inverses: `-0 = 0` and `-type(int256).min = type(int256).min`.\nIt's important to note that Solidity's arithmetic checks will throw an error when evaluating `-type(int256).min` (outside of unchecked blocks).\n\nExamining the underlying bit (or hex) representation emphasizes the importance of using the correct operators for signed integers, such as `slt` instead of `lt`, to prevent misinterpreting negative values as large numbers.\n\n```solidity\n  0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff // int256(-1) or type(uint256).max\n\u003c 0x0000000000000000000000000000000000000000000000000000000000000000 // 0\n// When using `slt`, the comparison is interpreted as `-1 \u003c 0 = true`.\n= 0x0000000000000000000000000000000000000000000000000000000000000001\n// When using `lt`, the comparison is interpreted as `type(uint256).max \u003c 0 = false`.\n= 0x0000000000000000000000000000000000000000000000000000000000000000\n```\n\nStarting with Solidity versions 0.8.16, integer overflow is prevented by using the computed result `c = a + b` to check for overflow/underflow.\nHowever, signed addition requires two separate checks instead of one, unlike unsigned addition.\n\n```solidity\n/// @notice versions \u003e=0.8.16\nfunction checkedAddInt2(int256 a, int256 b) public pure returns (int256 c) {\n    unchecked {\n        c = a + b;\n\n        // If `a` is positive, then the sum `c = a + b` can't be less than `b`.\n        if (a \u003e 0 \u0026\u0026 c \u003c b) arithmeticError();\n        // If `a` is negative, then the sum `c = a + b` can't be greater than `b`.\n        if (a \u003c 0 \u0026\u0026 c \u003e b) arithmeticError();\n    }\n}\n```\n\nNevertheless, by utilizing the boolean exclusive-or, we can combine these checks into a single step.\nAlthough Solidity does not allow the `xor` operation for boolean values, it can be used in inline-assembly.\nWhile doing so, it is important to validate our assumptions that both inputs are genuinely boolean (either `0` or `1`), as the xor operation functions bitwise and is not limited to only boolean values.\n\n```solidity\nfunction checkedAddInt3(int256 a, int256 b) public pure returns (int256 c) {\n    unchecked {\n        c = a + b;\n\n        bool overflow;\n\n        assembly {\n            // If `a \u003e= 0`, then the sum `c = a + b` can't be less than `b`.\n            // If `a \u003c  0`, then the sum `c = a + b` can't be greater than `b`.\n            // We combine these two conditions into one using `xor`.\n            overflow := xor(slt(a, 0), sgt(b, c))\n        }\n\n        if (overflow) arithmeticError();\n    }\n}\n```\n\nAn alternative approach to detecting overflow in addition is based on the observation that adding two integers with different signs will never result in an overflow.\nThis simplifies the check to the case when both operands have the same sign.\nIf the sign of the sum differs from one of the operands, the result has overflowed.\n\n```solidity\nfunction checkedAddInt4(int256 a, int256 b) public pure returns (int256 c) {\n    unchecked {\n        c = a + b;\n\n        // Overflow, if the signs of `a` and `b` are the same,\n        // but the sign of the result `c = a + b` differs from its summands.\n        // When the signs of `a` and `b` differ overflow is not possible.\n        if ((~a ^ b) \u0026 (a ^ c) \u003c 0) arithmeticError();\n    }\n}\n```\n\nInstead of checking the sign bit explicitly, which can be done by shifting the value to the right by 255 bits and verifying that it is non-zero,\nwe can use the `slt` operation to compare the value with `0`.\n\n## Arithmetic checks for uint256 subtraction\n\nThe process of checking for underflow in subtraction is similar to that of addition.\nWhen subtracting `a - b`, and `b` is greater than `a`, an underflow occurs.\n\n```solidity\nfunction checkedSubUint(uint256 a, uint256 b) public pure returns (uint256 c) {\n    unchecked {\n        c = a - b;\n\n        if (b \u003e a) arithmeticError();\n    }\n}\n```\n\nAlternatively, we could perform the check on the result itself using `if (c \u003e a) arithmeticError();`, because subtracting a positive value from `a` should yield a value less than or equal to `a`.\nHowever, in this case, we don't save any operations.\n\nSimilar to addition, for signed integers, we can combine the checks for both scenarios into a single check using `xor`.\n\n```solidity\nfunction checkedSubInt(int256 a, int256 b) public pure returns (int256 c) {\n    unchecked {\n        c = a - b;\n\n        bool overflow;\n\n        assembly {\n            // If `b \u003e= 0`, then the result `c = a - b` can't be greater than `a`.\n            // If `b \u003c  0`, then the result `c = a - b` can't be less than `a`.\n            overflow := xor(sgt(b, 0), sgt(a, c))\n        }\n\n        if (overflow) arithmeticError();\n    }\n}\n```\n\n## Arithmetic checks for uint256 multiplication\n\nTo detect overflow when multiplying two unsigned integers, we can use the approach of computing the maximum possible value of a multiplicand and check that it isn't exceeded.\n\n```solidity\n/// @notice versions \u003e=0.8.0 \u0026\u0026 \u003c0.8.17\nfunction checkedMulUint1(uint256 a, uint256 b) public pure returns (uint256 c) {\n    unchecked {\n        c = a * b;\n\n        if (a != 0 \u0026\u0026 b \u003e type(uint256).max / a) arithmeticError();\n    }\n}\n```\n\n\u003e The Solidity compiler always includes a zero check for all division and modulo operations, irrespective of whether an unchecked block is present.\n\u003e The EVM itself, however, returns `0` when dividing by `0`, which applies to inline-assembly as well.\n\u003e Evaluating the boolean expression `a != 0 \u0026\u0026 b \u003e type(uint256).max / a` in reverse order would cause an incorrect reversion when `a = 0`.\n\nWe can compute the maximum value for `b` as long as `a` is non-zero. However, if `a` is zero, we know that the result will be zero as well, and there is no need to check for overflow.\nLike before, we can also make use of the result and try to reconstruct one multiplicand from it. This is possible if the product didn't overflow and the first multiplicand is non-zero.\n\n```solidity\n/// @notice versions \u003e=0.8.17\nfunction checkedMulUint2(uint256 a, uint256 b) public pure returns (uint256 c) {\n    unchecked {\n        c = a * b;\n\n        if (a != 0 \u0026\u0026 b != c / a) arithmeticError();\n    }\n}\n```\n\nFor reference, we can further remove the additional division by zero check by writing the code in assembly.\n\n```solidity\nfunction checkedMulUint3(uint256 a, uint256 b) public pure returns (uint256 c) {\n    unchecked {\n        c = a * b;\n\n        bool overflow;\n\n        assembly {\n            // This version does not include a redundant division-by-0 check\n            // which the Solidity compiler includes when performing `c / a`.\n            overflow := iszero(or(iszero(a), eq(div(c, a), b)))\n        }\n\n        if (overflow) arithmeticError();\n    }\n}\n```\n\n## Arithmetic checks for int256 multiplication\n\nIn versions before 0.8.17, the Solidity compiler uses four separate checks to detect integer multiplication overflow.\nThe produced Yul code is equivalent to the following high-level Solidity code.\n\n```solidity\n/// @notice versions \u003e=0.8.0 \u0026\u0026 \u003c0.8.17\nfunction checkedMulInt(int256 a, int256 b) public pure returns (int256 c) {\n    unchecked {\n        c = a * b;\n\n        if (a \u003e 0 \u0026\u0026 b \u003e 0 \u0026\u0026 a \u003e type(int256).max / b) arithmeticError();\n        if (a \u003e 0 \u0026\u0026 b \u003c 0 \u0026\u0026 a \u003c type(int256).min / b) arithmeticError();\n        if (a \u003c 0 \u0026\u0026 b \u003e 0 \u0026\u0026 a \u003c type(int256).min / b) arithmeticError();\n        if (a \u003c 0 \u0026\u0026 b \u003c 0 \u0026\u0026 a \u003c type(int256).max / b) arithmeticError();\n    }\n}\n```\n\nSince Solidity version 0.8.17, the check is performed by utilizing the computed product in the check.\n\n```solidity\n/// @notice versions \u003e=0.8.17\nfunction checkedMulInt2(int256 a, int256 b) public pure returns (int256 c) {\n    unchecked {\n        c = a * b;\n\n        if (a \u003c 0 \u0026\u0026 b == type(int256).min) arithmeticError();\n        if (a != 0 \u0026\u0026 b != c / a) arithmeticError();\n    }\n}\n```\n\nWhen it comes to integer multiplication, it's important to handle the case when `a \u003c 0` and `b == type(int256).min`.\nThe actual case, where the product `c` will overflow, is limited to `a == -1` and `b == type(int256).min`.\nThis is because `-b` cannot be represented as a positive signed integer, as previously mentioned.\n\n## Arithmetic checks for addition with sub-32-byte types\n\nWhen performing arithmetic checks on data types that use less than 32 bytes, there are some additional steps to consider.\nFirst, let's take a look at the addition of signed 64-bit integers.\n\nOn a 64-bit system, integer addition works in the same way as before.\n\n```solidity\n  0xfffffffffffffffe // int64(-2)\n+ 0x0000000000000003 // int64(3)\n= 0x0000000000000001 // int64(1)\n```\n\nHowever, when performing the same calculations on a 256-bit machine, we need to extend the sign of the int64 value over all unused bits,\notherwise the value won't be interpreted correctly.\n\n```solidity\n                                   extended sign ──┐┌── 64-bit information\n  0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe // int64(-2)\n+ 0x0000000000000000000000000000000000000000000000000000000000000003 // int64(3)\n= 0x0000000000000000000000000000000000000000000000000000000000000001 // int64(1)\n```\n\nIt's worth noting that not all operations require clean upper bits. In fact, even if the upper bits are dirty, we can still get correct results for addition. However, the sum will usually contain dirty upper bits that will need to be cleaned. For example, we can perform addition without knowledge of the upper bits.\n\n```solidity\n  0x????????????????????????????????????????????????fffffffffffffffe // int64(-2)\n+ 0x????????????????????????????????????????????????0000000000000003 // int64(3)\n= 0x????????????????????????????????????????????????0000000000000001 // int64(1)\n```\n\nIt is crucial to be mindful of when to clean the bits before and after operations.\nBy default, Solidity takes care of cleaning the bits before operations on smaller types and lets the optimizer remove any redundant steps.\nHowever, values accessed after operations included by the compiler are not guaranteed to be clean. In particular, this is the case for addition with small data types.\nFor example, the bit cleaning steps will be removed by the optimizer (even without optimizations enabled) if a variable is only accessed in a subsequent assembly block.\nRefer to the [Solidity documentation](https://docs.soliditylang.org/en/v0.8.18/internals/variable_cleanup.html#cleaning-up-variables) for further information on this matter.\n\nWhen performing arithmetic checks in the same way as before, it is necessary to include a step to clean the bits on the sum.\nOne approach to achieve this is by performing `signextend(7, value)`, which extends the sign of a 64-bit (7 + 1 = 8 bytes) integer over all upper bits.\n\n```solidity\nfunction checkedAddInt64_1(int64 a, int64 b) public pure returns (int64 c) {\n    unchecked {\n        bool overflow;\n\n        c = a + b;\n\n        assembly {\n            // Note that we must manually clean the upper bits in this case.\n            // Solidity will optimize the cleaning away otherwise.\n            // Extend the sign of the sum to 256 bits.\n            c := signextend(7, c)\n\n            // Perform the same arithmetic overflow check as before.\n            overflow := xor(slt(a, 0), sgt(b, c))\n        }\n\n        if (overflow) arithmeticError();\n    }\n}\n```\n\nIf we remove the line that includes `c := signextend(7, c)` the overflow check will not function correctly.\nThis is because Solidity does not take into account the fact that the variable is used in an assembly block, and the optimizer removes the bit cleaning operation, even if the Yul code includes it after the addition.\n\nOne thing to keep in mind is that since we are performing a 64-bit addition in 256 bits, we practically have access to the carry/overflow bits.\nIf our computed value does not overflow, then it will fall within the correct bounds `type(int64).min \u003c= c \u003c= type(int64).max`.\nThe actual overflow check in Solidity involves verifying both the upper and lower bounds.\n\n```solidity\n/// @notice version \u003e= 0.8.16\nfunction checkedAddInt64_2(int64 a, int64 b) public pure returns (int64 c) {\n    unchecked {\n        // Perform the addition in int256.\n        int256 uc = int256(a) + b;\n\n        // If the value can not be represented by a int64, there is overflow.\n        if (uc \u003e type(int64).max || uc \u003c type(int64).min) arithmeticError();\n\n        // We can safely cast the result.\n        c = int64(uc);\n    }\n}\n```\n\nThere are a few ways to verify that the result in its 256-bit representation will fit into the expected data type.\nThis is only true when all upper bits are the same.\nThe most direct method, as previously shown, involves verifying both the lower and upper bounds.\n\n```solidity\n/// @notice Check used in int64 addition for version \u003e= 0.8.16.\nfunction overflowInt64(int256 value) public pure returns (bool overflow) {\n    overflow = value \u003e type(int64).max || value \u003c type(int64).min;\n}\n```\n\nWe can simplify the expression to a single comparison if we can shift the disjointed number domain back so that it's connected.\nTo accomplish this, we subtract the smallest negative int64 `type(int64).min` from a value (or add the underlying unsigned value).\nA better way to understand this is by visualizing the signed integer number domain in relation to the unsigned domain (which is demonstrated here using int128).\n\n$$\nuint256 \\text{ domain}\n$$\n\n$$\n├\\underset{0}{─}────────────────────────────\\underset{\\hskip -2em 2^{256} - 1}{─}┤\n$$\n\n$$\nint256 \\text{ domain}\n$$\n\n$$\n\\overset{\\hskip 1em positive}{\n    ├\\underset{0}{─}────────────\\underset{\\hskip -2em 2^{255} - 1}{─}┤\n}\n\\overset{\\hskip 1em negative}{\n    ├────\\underset{\\hskip -3.5em - 2^{255}}─────────\\underset{\\hskip -0.4 em -1}{─}┤\n}\n$$\n\nThe domain for uint128/int128 can be visualized as follows.\n\n$$\nuint128 \\text{ domain}\n$$\n\n$$\n├\\underset{0}─────────────\\underset{\\hskip -2em 2^{128}-1}─┤\n\\phantom{───────────────}┆\n$$\n\n$$\nint128 \\text{ domain}\n$$\n\n$$\n\\overset{\\hskip 1em positive}{\n    ├\\underset{0}{─}────\\underset{\\hskip -2em 2^{127} - 1}{─}┤\n}\n\\phantom{────────────────}\n\\overset{\\hskip 1em negative}{\n    ├────\\underset{\\hskip -3.5em - 2^{127}}─\\underset{\\hskip -0.4 em -1}{─}┤\n}\n$$\n\nNote that the scales of the number ranges in the previous section do not accurately depict the magnitude of numbers that are representable with the different types and only serve as a visualization. We can represent twice as many numbers with only one additional bit, yet the uint256 domain has twice the number of bits compared to uint128.\n\nAfter subtracting `type(int128).min` (or adding $2^{127}$) and essentially shifting the domains to the right, we get the following, connected set of values.\n\n$$\n├\\underset{0}─────────────\\underset{\\hskip -2em 2^{128}-1}─┤\n\\phantom{───────────────}┆\n$$\n\n$$\n\\overset{\\hskip 1em negative}{├──────┤}\n\\overset{\\hskip 1em positive}{├──────┤}\n\\phantom{───────────────}┆\n$$\n\nIf we interpret the shifted value as an unsigned integer, we only need to check whether it exceeds the maximum unsigned integer `type(uint128).max`.\nThe corresponding check in Solidity is shown below.\n\n```solidity\nfunction overflowInt64_2(int256 value) public pure returns (bool overflow) {\n    unchecked {\n        overflow = uint256(value) - uint256(int256(type(int64).min)) \u003e type(uint64).max;\n    }\n}\n```\n\nIn this case the verbose assembly code might actually be easier to follow than the Solidity code which sometimes contains implicit operations.\n\n```solidity\nint64 constant INT64_MIN = -0x8000000000000000;\nuint64 constant UINT64_MAX = 0xffffffffffffffff;\n\nfunction overflowInt64_2_yul(int256 value) public pure returns (bool overflow) {\n    assembly {\n        overflow := gt(sub(value, INT64_MIN), UINT64_MAX)\n    }\n}\n```\n\nAs mentioned earlier, this approach is only effective for negative numbers when all of their upper bits are set to `1`, allowing us to overflow back into the positive domain.\nAn alternative and more straightforward method would be to simply verify that all of the upper bits are equivalent to the sign bit for all integers.\n\n```solidity\nfunction overflowInt64_3(int256 value) public pure returns (bool overflow) {\n    overflow = value != int64(value);\n}\n```\n\nIn Yul, the equivalent resembles the following.\n\n```solidity\nfunction overflowInt64_3_yul(int256 value) public pure returns (bool overflow) {\n    assembly {\n        overflow := iszero(eq(value, signextend(7, value)))\n    }\n}\n```\n\nAnother way of extending the sign is to make use of `sar` (signed arithmetic right shift).\n\n```solidity\nfunction overflowInt64_4(int256 value) public pure returns (bool overflow) {\n    overflow = value != (value \u003c\u003c 192) \u003e\u003e 192;\n}\n\nfunction overflowInt64_4_yul(int256 value) public pure returns (bool overflow) {\n    assembly {\n        overflow := iszero(eq(value, sar(192, shl(192, value))))\n    }\n}\n```\n\nFinally, a full example for detecting signed 64-bit integer overflow, implemented in Solidity can be seen below:\n\n```solidity\nfunction checkedAddInt64_2(int64 a, int64 b) public pure returns (int64 c) {\n    unchecked {\n        // Cast the first summand.\n        // The second summand is implicitly casted.\n        int256 uc = int256(a) + b;\n\n        // Check whether the result `uc` can be represented by 64 bits\n        // by shifting the values to the uint64 domain.\n        // This is done by subtracting the smallest value in int64.\n        if (uint256(uc) - uint256(int256(type(int64).min)) \u003e type(uint64).max) arithmeticError();\n\n        // We can safely cast the result.\n        c = int64(uc);\n    }\n}\n```\n\nOne further optimization that we could perform is to add `-type(int64).min` instead of subtracting `type(int64).min`. This would not reduce computation costs, however it could end up reducing bytecode size. This is because when we subtract `-type(int64).min`, we need to push 32 bytes (`0xffffffffffffffffffffffffffffffffffffffffffffffff8000000000000000`), whereas when we add `-type(int64).min`, we only end up pushing 8 bytes (`0x8000000000000000`). However, as soon as we turn on compiler optimizations, the produced bytecode ends up being the same.\n\n## Arithmetic checks for multiplication with sub-32-byte types\n\nWhen the product `c = a * b` can be calculated in 256 bits without the possibility of overflowing, we can verify whether the result can fit into the anticipated data type. This is also the way Solidity handles the check in versions 0.8.17 and later.\n\n```solidity\n/// @notice version \u003e= 0.8.17\nfunction checkedMulInt64(int64 a, int64 b) public pure returns (int64 c) {\n    unchecked {\n        int256 uc = int256(a) * int256(b);\n\n        // If the product can not be represented with 64 bits,\n        // there is overflow.\n        if (overflowInt64(uc)) arithmeticError();\n\n        c = int64(uc);\n    }\n}\n```\n\nHowever, if the maximum value of a product exceeds 256 bits, then this method won't be effective.\nThis happens, for instance, when working with int192. The product `type(int192).min * type(int192).min` requires 192 + 192 = 384 bits to be stored, which exceeds the maximum of 256 bits.\nOverflow occurs in 256 bits, causing a loss of information, and it won't be logical to check if the result fits into 192 bits.\nIn this scenario, we can rely on the previous checks and, for example, attempt to reconstruct one of the multiplicands.\n\n```solidity\nfunction checkedMulInt192_1(int192 a, int192 b) public pure returns (int192 c) {\n    unchecked {\n        c = a * b;\n\n        if (a != 0 \u0026\u0026 b != c / a) arithmeticError();\n        if (a = -1 \u0026\u0026 b == type(int192).min) arithmeticError();\n    }\n}\n```\n\nWe must consider the two special circumstances:\n\n1. When one of the multiplicands is zero (`a == 0`), the other multiplicand cannot be retrieved. However, this case never results in overflow.\n2. Even if the multiplication is correct in 256 bits, the calculation overflows when only examining the least-significant 192 bits if the first multiplicand is negative one (`a = -1`) and the other multiplicand is the minimum value.\n\nAn example might help explain the second case.\n\n```solidity\n  0xffffffffffffffff800000000000000000000000000000000000000000000000 // type(int192).min\n* 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff // -1\n= 0x0000000000000000800000000000000000000000000000000000000000000000 // type(int192).min (when seen as a int192)\n```\n\nA method to address this issue is to always start by sign-extending or cleaning the result before attempting to reconstruct the other multiplicand.\nBy doing so, it eliminates the need to check for the special condition.\n\n```solidity\n/// @notice version \u003e= 0.8.17\nfunction checkedMulInt192_2(int192 a, int192 b) public pure returns (int192 c) {\n    unchecked {\n        bool overflow;\n\n        assembly {\n            // Extend the sign for int192 (24 = 23 + 1 bytes).\n            c := signextend(23, mul(a, b))\n\n            // Overflow, if `a != 0 \u0026\u0026 b != c / a`.\n            overflow := iszero(or(iszero(a), eq(b, sdiv(c, a))))\n        }\n\n        if (overflow) arithmeticError();\n    }\n}\n```\n\n## Conclusion\n\nIn conclusion, we hope this article has served as an informative guide on signed integer arithmetic within the EVM and the two's complement system.\nWe have explored:\n\n- the added complexity from handling signed over unsigned integers\n- the intricacies involved in managing sub 32-byte types\n- the significance of `signextend` and opcodes related to signed integers\n- the importance of bit-cleaning\n\nWhile low-level optimizations are attractive, they are also heavily error-prone. This article aims to deepen one's understanding of low-level arithmetic, to reduce these risks. Nevertheless, it is crucial to integrate custom low-level optimizations only after thorough manual analysis, automated testing, and to document any non-obvious assumptions.\n","title":"A Guide on Performing Arithmetic Checks in the EVM","date":"Feb 19, 2023","excerpt":"A post created during my time at Trail of Bits. It features the many ways that arithmetic checks can be performed in the EVM."}},"__N_SSG":true},"page":"/[...slug]","query":{"slug":["blog","2023","arithmetic-checks"]},"buildId":"P0-6OJp-GIUymjWj8O3zL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>