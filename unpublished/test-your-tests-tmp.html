<!DOCTYPE html><html><head><meta charSet="utf-8"/><title class="animate__fadeIn">0xPhaze</title><meta name="viewport" content="initial-scale=1.0, width=device-width"/><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/fcf81e63369216ac.css" as="style"/><link rel="stylesheet" href="/_next/static/css/fcf81e63369216ac.css" data-n-g=""/><link rel="preload" href="/_next/static/css/65875c30e26bdd78.css" as="style"/><link rel="stylesheet" href="/_next/static/css/65875c30e26bdd78.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-ede13cf31a63337e.js" defer=""></script><script src="/_next/static/chunks/framework-bb5c596eafb42b22.js" defer=""></script><script src="/_next/static/chunks/main-914fbfab4f90b52f.js" defer=""></script><script src="/_next/static/chunks/pages/_app-ad82082731d58181.js" defer=""></script><script src="/_next/static/chunks/175675d1-5e59763be147fa1f.js" defer=""></script><script src="/_next/static/chunks/634-958ce5c52c8283ef.js" defer=""></script><script src="/_next/static/chunks/pages/%5B...slug%5D-1036fd4ff48bafcd.js" defer=""></script><script src="/_next/static/b06NupxvtES2cDfarn2Io/_buildManifest.js" defer=""></script><script src="/_next/static/b06NupxvtES2cDfarn2Io/_ssgManifest.js" defer=""></script><script src="/_next/static/b06NupxvtES2cDfarn2Io/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="app px-4 pb-20 min-h-screen flex flex-col items-center w-full max-w-screen"><header class="w-full flex flex-col px-4 sm:px-8 md:px-12 max-w-5xl sm:flex-row justify-between items-center border-white/20 overflow-hidden border-b p-4 h-16"><div class="w-full h-full flex flex-col sm:flex-row justify-start sm:justify-between items-center gap-y-4 overflow-hidden sm:overflow-visible"><div class="flex w-full sm:w-fit items-center"><h1 class="text-xl mx-auto font-display"><a href="/">0xPhaze</a></h1><div class="my-auto -ml-6 w-6 sm:hidden"><div class="text-slate-300 hover:text-secondary-400 transition-colors duration-200 cursor-pointer h-6"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="bars" class="svg-inline--fa fa-bars " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M0 96C0 78.33 14.33 64 32 64H416C433.7 64 448 78.33 448 96C448 113.7 433.7 128 416 128H32C14.33 128 0 113.7 0 96zM0 256C0 238.3 14.33 224 32 224H416C433.7 224 448 238.3 448 256C448 273.7 433.7 288 416 288H32C14.33 288 0 273.7 0 256zM416 448H32C14.33 448 0 433.7 0 416C0 398.3 14.33 384 32 384H416C433.7 384 448 398.3 448 416C448 433.7 433.7 448 416 448z"></path></svg></div></div></div><div class="flex flex-col sm:flex-row gap-x-8 md:gap-x-10 gap-y-4"><div class="flex gap-x-2 sm:gap-x-5 items-center justify-evenly"><a target="_blank" rel="noreferrer" class="link" href="https://github.com/0xPhaze/"><div><div class="text-slate-300 hover:text-secondary-400 transition-colors duration-200 cursor-pointer"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="h-4"><path style="fill:currentColor" d="M12 0C5.374 0 0 5.373 0 12c0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23A11.509 11.509 0 0 1 12 5.803c1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576C20.566 21.797 24 17.3 24 12c0-6.627-5.373-12-12-12z"></path></svg></div></div></a><a target="_blank" rel="noreferrer" class="link" href="https://twitter.com/lovethewired"><div><div class="text-slate-300 hover:text-secondary-400 transition-colors duration-200 cursor-pointer"><svg viewBox="0 0 16 14" fill="none" xmlns="http://www.w3.org/2000/svg" class="h-4"><path style="fill:currentColor" d="M15.584 1.578a7.91 7.91 0 0 1-1.57 1.807v.482c0 .965-.112 1.929-.336 2.772-.224.965-.673 1.808-1.121 2.652a17.373 17.373 0 0 1-1.794 2.29c-.785.723-1.681 1.205-2.578 1.566-1.01.362-2.13.603-3.252.603-1.793 0-3.475-.603-4.932-1.567h.784c1.458 0 2.915-.482 4.036-1.446a2.914 2.914 0 0 1-1.905-.723c-.561-.482-.897-.964-1.122-1.687h.561c.336 0 .56 0 .897-.12C2.579 8.085 1.907 7.603 1.458 7 .785 6.398.561 5.675.561 4.83c.449.242 1.01.362 1.458.483A5.531 5.531 0 0 1 .898 4.109C.673 3.626.449 3.024.449 2.42c0-.602.112-1.205.449-1.687a8.606 8.606 0 0 0 2.914 2.53c1.122.603 2.355.965 3.7 1.086 0-.241-.112-.483-.112-.844 0-.723.224-1.326.56-1.928.337-.603.897-.965 1.458-1.326.56-.241 1.233-.362 1.906-.12.672.12 1.233.481 1.681.964.673-.121 1.458-.362 2.018-.844-.224.844-.784 1.446-1.457 1.928.785-.12 1.457-.24 2.018-.602Z" fill="#081026"></path></svg></div></div></a><div><div class="text-slate-300 hover:text-secondary-400 transition-colors duration-200 cursor-pointer">ABI</div></div><div><div class="text-slate-300 hover:text-secondary-400 transition-colors duration-200 cursor-pointer">ENC</div></div></div><button class="rounded px-4 py-2 uppercase text-white select-none  transition-all duration-300 disabled:pointer-events-none bg-primary-600 hover:bg-primary-700  !outline-none normal-case text-sm w-[140px] w-36">Connect Wallet</button></div></div></header><main class="gap-y-20 mt-8 py-4 sm:px-8 md:px-12 w-full min-h-[500px] max-w-4xl"><div class="flex flex-col justify-between gap-y-20"><div class="content markdown"><h1 class="text-center">Test Your Tests</h1><h2 class="text-center">What makes a good and a bad test</h2><p class="text-slate-500 text-sm text-center">Feb 19, 2023</p><div class="mt-16"><p>PRB:</p>
<ul>
<li>start with naming conventions</li>
<li>structure</li>
<li>unit vs integration vs fuzz vs fork (foundry book)</li>
<li>english specification</li>
<li>contract inheritance (Base.t.sol)</li>
</ul>
<p>Tests are written in order to give a higher confidence about a function&#x27;s behavior. This is all the more important when writing high assurance software, like smart contracts that could end up handling millions of dollars on a immutable ledger.</p>
<p>When writing tests, they should be dealt with in a similar manner as runtime code. By that I mean that we should be thinking about what control-flow paths are being covered and what kind of assurance can be given for the function&#x27;s behavior on what range of inputs. Inputs and edge-cases that are not covered should be considered without any behavioral guarantees.</p>
<p>Let&#x27;s look at some examples to make this less obscure.</p>
<h2 id="recommendations"><a href="/unpublished/test-your-tests-tmp#recommendations"><span class="icon icon-link"></span></a>Recommendations</h2>
<h3 id="arrange-act-assert"><a href="/unpublished/test-your-tests-tmp#arrange-act-assert"><span class="icon icon-link"></span></a>Arrange Act Assert</h3>
<ul>
<li><strong>Guarantees for function execution or reversion for all possible input ranges:</strong>
It&#x27;s essential to know under what conditions a function passes and when it reverts. If we don&#x27;t have any guarantees on the successful execution or failure of the function and this is not obviously detected in other tests, then all of our tests might appear meaningless.</li>
<li><strong>Correctly constraining input values:</strong>
We don&#x27;t want zero or low coverage on tests. Ideally (and I think in almost all cases we can), we should be able to explicitly define the input ranges for which the properties hold and constrain our inputs to those ranges without discarding tests. This ensures that we get sufficient coverage for those properties.</li>
<li><strong>Reverts should be explicitly handled or seen as test-failures:</strong>
This is my biggest pain-point. Assertion mode makes sense for exploring large and complex stateful code, but I think it has little justification for these kind of stateless tests. We do not want silent reverts. We need the assurance that the test has successfully executed and we need to be explicit about when it reverts. At the moment it seems like the best solution is to run a campaign in <code>dapptest</code> mode.</li>
<li><strong>Avoid testing trivial properties:</strong>
There are some trivial properties that are being checked. If we can clearly define one counter-cases where the property does not hold, then it is at least not trivial.</li>
<li><strong>Testing complex helper functions:</strong>
The helper functions in this test suite are sufficiently complex to warrant tests themselves. I don&#x27;t think that they all work as expected. The requirements of the helper functions should be made clear and if they are not satisfied, this should be immediately reported as a test-failure. Not checking these requirements for helper functions will end up as foot-guns when writing tests.</li>
<li><strong>Testing one property at a time:</strong>
It&#x27;s easier to track and comprehend tests that focus on a single property at a time. This also helps avoiding unintended interactions with multiple properties or early exits. It also helps when constraining inputs and their edge cases.</li>
<li><strong>Minimizing nested &#x27;if&#x27; statements in tests:</strong>
Nested &#x27;if&#x27; conditions can be difficult to understand and prone to errors. We should consider early returns or breaking up tests into smaller, more manageable parts.</li>
<li><strong>Tight testing bounds:</strong>
Tests that check for bounds should be tight, meaning an expansion of the bound should result in test failure. The edges of these bounds should be explicitly tested for the counter-case to ensure that the bounds are valid.</li>
</ul>
<p>The rest shows some examples in the code.</p>
<h3 id="ensuring-function-execution-success"><a href="/unpublished/test-your-tests-tmp#ensuring-function-execution-success"><span class="icon icon-link"></span></a>Ensuring function execution success</h3>
<p>A big problem with the current test setup that I see is that it looks like the any of the ABDKMath functions could revert and the tests would pass nonetheless. E.g. the functions could be</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">add</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int128</span><span> x</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">int128</span><span> y</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">internal</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int128</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    </span><span class="token" style="color:#ef3b7d">revert</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>and many tests would still pass. It might sound trivial that it won&#x27;t happen in this case, but it is less obvious for more complex functions. Also reversions can occur through division by zero checks or similar or through developer mistakes.</p>
<p>There is the coverage report, however inspecting it is cumbersome when prototyping tests or the library itself. It also doesn&#x27;t report how often a path was taken, so it could be that there is one trivial case that is executed for the function and all other cases revert.</p>
<h3 id="testing-trivial-statements"><a href="/unpublished/test-your-tests-tmp#testing-trivial-statements"><span class="icon icon-link"></span></a>Testing trivial statements</h3>
<p>The function <code>mul_test_range</code> tests the output range of the returned value from the <code>mul</code> function.</p>
<!-- -->
<p><strong><a target="_blank" rel="noreferrer" class="link" href="https://github.com/crytic/properties/blob/d3855861df5ff2f87fe2157de60417f9fc8cb4e3/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L583-L593">ABDKMath64x64PropertyTests.sol</a></strong></p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#6f705e">// The result of the multiplication must be between the maximum</span><span>
</span></span><span><span></span><span class="token" style="color:#6f705e">// and minimum allowed values for 64x64</span><span>
</span></span><span><span></span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">mul_test_range</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int128</span><span> x</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">int128</span><span> y</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">view</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    </span><span class="token builtin">int128</span><span> result</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    try </span><span class="token" style="color:#ef3b7d">this</span><span class="token" style="color:#bebec5">.</span><span class="token function">mul</span><span class="token" style="color:#bebec5">(</span><span>x</span><span class="token" style="color:#bebec5">,</span><span> y</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        result </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#ef3b7d">this</span><span class="token" style="color:#bebec5">.</span><span class="token function">mul</span><span class="token" style="color:#bebec5">(</span><span>x</span><span class="token" style="color:#bebec5">,</span><span> y</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>        </span><span class="token" style="color:#ef3b7d">assert</span><span class="token" style="color:#bebec5">(</span><span>result </span><span class="token" style="color:#a77afe">&lt;=</span><span> MAX_64x64 </span><span class="token" style="color:#a77afe">&amp;&amp;</span><span> result </span><span class="token" style="color:#a77afe">&gt;=</span><span> MIN_64x64</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span> catch </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        </span><span class="token" style="color:#6f705e">// If it reverts, just ignore</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>When translating what the test covers back into natural language, it tests that &quot;if the mul function is successful, then my output should be in the valid range, if it reverts, then that&#x27;s ok&quot;. The problem I see with this function is that the output of the <code>mul</code> function is a <code>int128</code> and the range that is being tested is essentially <code>type(int128).min &lt;= int128(result) &lt;= type(int128).max</code>. This test is trivial and does not give any meaningful result. I also find the syntax to be hard to read and it could be simplified to this:</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span>    </span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">mul_test_range</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int128</span><span> x</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">int128</span><span> y</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">view</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        </span><span class="token builtin">int128</span><span> result </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#ef3b7d">this</span><span class="token" style="color:#bebec5">.</span><span class="token function">mul</span><span class="token" style="color:#bebec5">(</span><span>x</span><span class="token" style="color:#bebec5">,</span><span> y</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>        </span><span class="token" style="color:#ef3b7d">assert</span><span class="token" style="color:#bebec5">(</span><span>result </span><span class="token" style="color:#a77afe">&lt;=</span><span> MAX_64x64 </span><span class="token" style="color:#a77afe">&amp;&amp;</span><span> result </span><span class="token" style="color:#a77afe">&gt;=</span><span> MIN_64x64</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>Though again, this test will always pass, regardless of the implementation of <code>mul</code>.</p>
<h3 id="not-all-input-cases-covered"><a href="/unpublished/test-your-tests-tmp#not-all-input-cases-covered"><span class="icon icon-link"></span></a>Not all input cases covered</h3>
<p>One of the first and most important questions that I would want to know when testing a function is: For all input ranges, when does the function revert and when does it pass?</p>
<p>This function gives some guarantee that the <code>this.mul</code> function doesn&#x27;t revert.</p>
<!-- -->
<p><strong><a target="_blank" rel="noreferrer" class="link" href="https://github.com/crytic/properties/blob/d3855861df5ff2f87fe2157de60417f9fc8cb4e3/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L595-L606">ABDKMath64x64PropertyTests.sol</a></strong></p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#6f705e">// Multiplying the maximum value times one shouldn&#x27;t revert, as it is valid</span><span>
</span></span><span><span></span><span class="token" style="color:#6f705e">// Moreover, the result must be MAX_64x64</span><span>
</span></span><span><span></span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">mul_test_maximum_value</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">view</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    </span><span class="token builtin">int128</span><span> result</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    try </span><span class="token" style="color:#ef3b7d">this</span><span class="token" style="color:#bebec5">.</span><span class="token function">mul</span><span class="token" style="color:#bebec5">(</span><span>MAX_64x64</span><span class="token" style="color:#bebec5">,</span><span> ONE_FP</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        </span><span class="token" style="color:#6f705e">// Expected behaviour, does not revert</span><span>
</span></span><span><span>        result </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#ef3b7d">this</span><span class="token" style="color:#bebec5">.</span><span class="token function">mul</span><span class="token" style="color:#bebec5">(</span><span>MAX_64x64</span><span class="token" style="color:#bebec5">,</span><span> ONE_FP</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>        </span><span class="token" style="color:#ef3b7d">assert</span><span class="token" style="color:#bebec5">(</span><span>result </span><span class="token" style="color:#a77afe">==</span><span> MAX_64x64</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span> catch </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        </span><span class="token" style="color:#ef3b7d">assert</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#a77afe">false</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>However it is only a unit-test and does not give me sufficient guarantees over the whole input range of all values.</p>
<h3 id="tests-should-not-be-testing-multiple-things-at-once"><a href="/unpublished/test-your-tests-tmp#tests-should-not-be-testing-multiple-things-at-once"><span class="icon icon-link"></span></a>Tests should not be testing multiple things at once</h3>
<p>The <code>div_test_division_identity</code> test tests both, division by <code>1</code> and by <code>0</code>.</p>
<!-- -->
<p><strong><a target="_blank" rel="noreferrer" class="link" href="https://github.com/crytic/properties/blob/d3855861df5ff2f87fe2157de60417f9fc8cb4e3/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L635-L653">ABDKMath64x64PropertyTests.sol</a></strong></p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#6f705e">// Test for identity property</span><span>
</span></span><span><span></span><span class="token" style="color:#6f705e">// x / 1 == x (equivalent to x / x == 1)</span><span>
</span></span><span><span></span><span class="token" style="color:#6f705e">// Moreover, x/x should not revert unless x == 0</span><span>
</span></span><span><span></span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">div_test_division_identity</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int128</span><span> x</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">view</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    </span><span class="token builtin">int128</span><span> div_1 </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token function">div</span><span class="token" style="color:#bebec5">(</span><span>x</span><span class="token" style="color:#bebec5">,</span><span> ONE_FP</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#ef3b7d">assert</span><span class="token" style="color:#bebec5">(</span><span>x </span><span class="token" style="color:#a77afe">==</span><span> div_1</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>    </span><span class="token builtin">int128</span><span> div_x</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>    try </span><span class="token" style="color:#ef3b7d">this</span><span class="token" style="color:#bebec5">.</span><span class="token function">div</span><span class="token" style="color:#bebec5">(</span><span>x</span><span class="token" style="color:#bebec5">,</span><span> x</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        </span><span class="token" style="color:#6f705e">// This should always equal one</span><span>
</span></span><span><span>        div_x </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token function">div</span><span class="token" style="color:#bebec5">(</span><span>x</span><span class="token" style="color:#bebec5">,</span><span> x</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>        </span><span class="token" style="color:#ef3b7d">assert</span><span class="token" style="color:#bebec5">(</span><span>div_x </span><span class="token" style="color:#a77afe">==</span><span> ONE_FP</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span> catch </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        </span><span class="token" style="color:#6f705e">// The only allowed case to revert is if x == 0</span><span>
</span></span><span><span>        </span><span class="token" style="color:#ef3b7d">assert</span><span class="token" style="color:#bebec5">(</span><span>x </span><span class="token" style="color:#a77afe">==</span><span> ZERO_FP</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span>
</span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>While it&#x27;s tempting to test multiple properties at once, the issue I see here is that the second test depends on the successful execution of the first. This would be ok if I had the guarantee that the division by <code>1</code> would always succeed and indeed return the same value.</p>
<h3 id="tested-bounds-are-not-tight"><a href="/unpublished/test-your-tests-tmp#tested-bounds-are-not-tight"><span class="icon icon-link"></span></a>Tested bounds are not tight</h3>
<p>When reviewing the test for <code>neg_test_maximum</code>, I noticed that the test is being performed on <code>MAX_64x64 - 1</code>.</p>
<!-- -->
<p><strong><a target="_blank" rel="noreferrer" class="link" href="https://github.com/crytic/properties/blob/d3855861df5ff2f87fe2157de60417f9fc8cb4e3/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L786-L794">ABDKMath64x64PropertyTests.sol</a></strong></p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#6f705e">// Test for the maximum value case</span><span>
</span></span><span><span></span><span class="token" style="color:#6f705e">// Since this is implementation-dependant, we will actually test with MAX_64x64-EPS</span><span>
</span></span><span><span></span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">neg_test_maximum</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">view</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    try </span><span class="token" style="color:#ef3b7d">this</span><span class="token" style="color:#bebec5">.</span><span class="token function">neg</span><span class="token" style="color:#bebec5">(</span><span class="token function">sub</span><span class="token" style="color:#bebec5">(</span><span>MAX_64x64</span><span class="token" style="color:#bebec5">,</span><span> EPSILON</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        </span><span class="token" style="color:#6f705e">// Expected behaviour, does not revert</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span> catch </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        </span><span class="token" style="color:#ef3b7d">assert</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#a77afe">false</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>This is ok, however the bounds are not tight (i.e. the maximal value is not being checked). Furthermore, <code>neg</code> should be expected to work for any input except for <code>MIN_64x64</code> (including <code>MAX_64x64 </code>).</p>
<h3 id="helper-functions-not-tested"><a href="/unpublished/test-your-tests-tmp#helper-functions-not-tested"><span class="icon icon-link"></span></a>Helper functions not tested</h3>
<p>Helper functions, such as <code>most_significant_bits</code> are sufficiently complex that they would warrant their own tests to ensure that their functionality is correct.</p>
<!-- -->
<p><strong><a target="_blank" rel="noreferrer" class="link" href="https://github.com/crytic/properties/blob/d3855861df5ff2f87fe2157de60417f9fc8cb4e3/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L106-L122">ABDKMath64x64PropertyTests.sol</a></strong></p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#6f705e">// Return the i most significant bits from |n|. If n has less than i significant bits, return |n|</span><span>
</span></span><span><span></span><span class="token" style="color:#6f705e">// Uses functions from the library under test!</span><span>
</span></span><span><span></span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">most_significant_bits</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int128</span><span> n</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">uint256</span><span> i</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">uint256</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    </span><span class="token" style="color:#6f705e">// Create a mask consisting of i bits set to 1</span><span>
</span></span><span><span>    </span><span class="token builtin">uint256</span><span> mask </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#a77afe">2</span><span class="token" style="color:#a77afe">**</span><span>i</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">-</span><span> </span><span class="token" style="color:#a77afe">1</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>    </span><span class="token" style="color:#6f705e">// Get the position of the MSB set to 1 of n</span><span>
</span></span><span><span>    </span><span class="token builtin">uint256</span><span> pos </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token builtin">uint64</span><span class="token" style="color:#bebec5">(</span><span class="token function">toInt</span><span class="token" style="color:#bebec5">(</span><span class="token function">log_2</span><span class="token" style="color:#bebec5">(</span><span>n</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">+</span><span> </span><span class="token" style="color:#a77afe">64</span><span> </span><span class="token" style="color:#a77afe">+</span><span> </span><span class="token" style="color:#a77afe">1</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>    </span><span class="token" style="color:#6f705e">// Get the positive value of n</span><span>
</span></span><span><span>    </span><span class="token builtin">uint256</span><span> value </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#bebec5">(</span><span>n</span><span class="token" style="color:#a77afe">&gt;</span><span class="token" style="color:#a77afe">0</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">?</span><span> </span><span class="token builtin">uint128</span><span class="token" style="color:#bebec5">(</span><span>n</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token builtin">uint128</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#a77afe">-</span><span>n</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>    </span><span class="token" style="color:#6f705e">// Shift the mask to match the rightmost 1-set bit</span><span>
</span></span><span><span>    </span><span class="token" style="color:#ef3b7d">if</span><span class="token" style="color:#bebec5">(</span><span>pos </span><span class="token" style="color:#a77afe">&gt;</span><span> i</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span> mask </span><span class="token" style="color:#a77afe">&lt;&lt;=</span><span> </span><span class="token" style="color:#bebec5">(</span><span>pos </span><span class="token" style="color:#a77afe">-</span><span> i</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span> </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span>
</span><span><span>    </span><span class="token" style="color:#ef3b7d">return</span><span> </span><span class="token" style="color:#bebec5">(</span><span>value </span><span class="token" style="color:#a77afe">&amp;</span><span> mask</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>If this function were to always return <code>0x0</code> for example, then many other tests would trivially pass. Also, touching on the first issue, if they were to revert, these tests would also trivially &quot;pass&quot;.</p>
<p>The <code>most_significant_bits</code> function for example uses <code>log_2</code>, which has a <code>require(x &gt; 0)</code> statement. Judging from the comment in the function description, this function should not revert for negative numbers. What&#x27;s more, the line <code>-n</code> can also revert when <code>n = type(int128).min</code>. This case does not seem to be handled and it is unclear what the output should be.</p>
<p>The same can be said for almost all helper functions.</p>
<!-- -->
<p><strong><a target="_blank" rel="noreferrer" class="link" href="https://github.com/crytic/properties/blob/091654413501207323a4980f81e1349b09cf3a91/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L109-L122">ABDKMath64x64PropertyTests.sol</a></strong></p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">significant_bits_after_mult</span><span class="token" style="color:#bebec5">(</span><span>
</span></span><span><span>    </span><span class="token builtin">int128</span><span> a</span><span class="token" style="color:#bebec5">,</span><span>
</span></span><span><span>    </span><span class="token builtin">int128</span><span> b
</span></span><span><span></span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">uint256</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    </span><span class="token builtin">int128</span><span> x </span><span class="token" style="color:#a77afe">=</span><span> a </span><span class="token" style="color:#a77afe">&gt;=</span><span> </span><span class="token" style="color:#a77afe">0</span><span> </span><span class="token" style="color:#a77afe">?</span><span> a </span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token" style="color:#a77afe">-</span><span>a</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token builtin">int128</span><span> y </span><span class="token" style="color:#a77afe">=</span><span> b </span><span class="token" style="color:#a77afe">&gt;=</span><span> </span><span class="token" style="color:#a77afe">0</span><span> </span><span class="token" style="color:#a77afe">?</span><span> b </span><span class="token" style="color:#bebec5">:</span><span> </span><span class="token" style="color:#a77afe">-</span><span>b</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>    </span><span class="token builtin">int128</span><span> lx </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token function">toInt</span><span class="token" style="color:#bebec5">(</span><span class="token function">log_2</span><span class="token" style="color:#bebec5">(</span><span>x</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token builtin">int128</span><span> ly </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token function">toInt</span><span class="token" style="color:#bebec5">(</span><span class="token function">log_2</span><span class="token" style="color:#bebec5">(</span><span>y</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token builtin">int256</span><span> prec </span><span class="token" style="color:#a77afe">=</span><span> lx </span><span class="token" style="color:#a77afe">+</span><span> ly </span><span class="token" style="color:#a77afe">-</span><span> </span><span class="token" style="color:#a77afe">1</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>    </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span>prec </span><span class="token" style="color:#a77afe">&lt;</span><span> </span><span class="token" style="color:#a77afe">-</span><span class="token" style="color:#a77afe">64</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">return</span><span> </span><span class="token" style="color:#a77afe">0</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#ef3b7d">else</span><span> </span><span class="token" style="color:#ef3b7d">return</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#a77afe">64</span><span> </span><span class="token" style="color:#a77afe">+</span><span> </span><span class="token builtin">uint256</span><span class="token" style="color:#bebec5">(</span><span>prec</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>There is also the <code>equal_within_precision</code> function which computes <code>(max - min)</code> for two <code>int128</code>s. And if this overflows the function will silently revert...</p>
<!-- -->
<p><strong><a target="_blank" rel="noreferrer" class="link" href="https://github.com/crytic/properties/blob/091654413501207323a4980f81e1349b09cf3a91/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L51-L65">ABDKMath64x64PropertyTests.sol</a></strong></p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#6f705e">// These functions allows to compare a and b for equality, discarding</span><span>
</span></span><span><span></span><span class="token" style="color:#6f705e">// the last precision_bits bits.</span><span>
</span></span><span><span></span><span class="token" style="color:#6f705e">// An absolute value function is implemented inline in order to not use</span><span>
</span></span><span><span></span><span class="token" style="color:#6f705e">// the implementation from the library under test.</span><span>
</span></span><span><span></span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">equal_within_precision</span><span class="token" style="color:#bebec5">(</span><span>
</span></span><span><span>    </span><span class="token builtin">int128</span><span> a</span><span class="token" style="color:#bebec5">,</span><span>
</span></span><span><span>    </span><span class="token builtin">int128</span><span> b</span><span class="token" style="color:#bebec5">,</span><span>
</span></span><span><span>    </span><span class="token builtin">uint256</span><span> precision_bits
</span></span><span><span></span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">pure</span><span> </span><span class="token" style="color:#ef3b7d">returns</span><span> </span><span class="token" style="color:#bebec5">(</span><span class="token builtin">bool</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    </span><span class="token builtin">int128</span><span> max </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#bebec5">(</span><span>a </span><span class="token" style="color:#a77afe">&gt;</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">?</span><span> a </span><span class="token" style="color:#bebec5">:</span><span> b</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token builtin">int128</span><span> min </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#bebec5">(</span><span>a </span><span class="token" style="color:#a77afe">&gt;</span><span> b</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">?</span><span> b </span><span class="token" style="color:#bebec5">:</span><span> a</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token builtin">int128</span><span> r </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#bebec5">(</span><span>max </span><span class="token" style="color:#a77afe">-</span><span> min</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">&gt;&gt;</span><span> precision_bits</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>    </span><span class="token" style="color:#ef3b7d">return</span><span> </span><span class="token" style="color:#bebec5">(</span><span>r </span><span class="token" style="color:#a77afe">==</span><span> </span><span class="token" style="color:#a77afe">0</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<h3 id="conditional-branches-for-unit-tests"><a href="/unpublished/test-your-tests-tmp#conditional-branches-for-unit-tests"><span class="icon icon-link"></span></a>Conditional branches for unit-tests</h3>
<p>There are some tests that are effectively constructed as unit-tests. We (or the developer) should know with certainty what happens in those cases and we should not allow either outcome to pass.</p>
<!-- -->
<p><strong><a target="_blank" rel="noreferrer" class="link" href="https://github.com/crytic/properties/blob/091654413501207323a4980f81e1349b09cf3a91/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L905-L925">ABDKMath64x64PropertyTests.sol</a></strong></p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#6f705e">// Test the maximum value</span><span>
</span></span><span><span></span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">abs_test_maximum</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">view</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    </span><span class="token builtin">int128</span><span> abs_max</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>    try </span><span class="token" style="color:#ef3b7d">this</span><span class="token" style="color:#bebec5">.</span><span class="token function">abs</span><span class="token" style="color:#bebec5">(</span><span>MAX_64x64</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        </span><span class="token" style="color:#6f705e">// If it doesn&#x27;t revert, the value must be MAX_64x64</span><span>
</span></span><span><span>        abs_max </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#ef3b7d">this</span><span class="token" style="color:#bebec5">.</span><span class="token function">abs</span><span class="token" style="color:#bebec5">(</span><span>MAX_64x64</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>        </span><span class="token" style="color:#ef3b7d">assert</span><span class="token" style="color:#bebec5">(</span><span>abs_max </span><span class="token" style="color:#a77afe">==</span><span> MAX_64x64</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span> catch </span><span class="token" style="color:#bebec5">{</span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span>
</span><span><span></span><span class="token" style="color:#6f705e">// Test the minimum value</span><span>
</span></span><span><span></span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">abs_test_minimum</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">view</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    </span><span class="token builtin">int128</span><span> abs_min</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>    try </span><span class="token" style="color:#ef3b7d">this</span><span class="token" style="color:#bebec5">.</span><span class="token function">abs</span><span class="token" style="color:#bebec5">(</span><span>MIN_64x64</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        </span><span class="token" style="color:#6f705e">// If it doesn&#x27;t revert, the value must be the negative of MIN_64x64</span><span>
</span></span><span><span>        abs_min </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#ef3b7d">this</span><span class="token" style="color:#bebec5">.</span><span class="token function">abs</span><span class="token" style="color:#bebec5">(</span><span>MIN_64x64</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>        </span><span class="token" style="color:#ef3b7d">assert</span><span class="token" style="color:#bebec5">(</span><span>abs_min </span><span class="token" style="color:#a77afe">==</span><span> </span><span class="token function">neg</span><span class="token" style="color:#bebec5">(</span><span>MIN_64x64</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span> catch </span><span class="token" style="color:#bebec5">{</span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>The test for the <code>abs</code> function is an example of this. The test passes if the function reverts, but it also passes if the function doesn&#x27;t revert.</p>
<p>The <code>gavg</code> function uses conditional testing and has the comment that the overflow might be implementation specific.</p>
<!-- -->
<p><strong><a target="_blank" rel="noreferrer" class="link" href="https://github.com/crytic/properties/blob/091654413501207323a4980f81e1349b09cf3a91/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L1213-L1223">ABDKMath64x64PropertyTests.sol</a></strong></p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#6f705e">// Test for the maximum value</span><span>
</span></span><span><span></span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">gavg_test_maximum</span><span class="token" style="color:#bebec5">(</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">view</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    </span><span class="token builtin">int128</span><span> result</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>    </span><span class="token" style="color:#6f705e">// This may revert due to overflow depending on implementation</span><span>
</span></span><span><span>    </span><span class="token" style="color:#6f705e">// If it doesn&#x27;t revert, the result must be MAX_64x64</span><span>
</span></span><span><span>    try </span><span class="token" style="color:#ef3b7d">this</span><span class="token" style="color:#bebec5">.</span><span class="token function">gavg</span><span class="token" style="color:#bebec5">(</span><span>MAX_64x64</span><span class="token" style="color:#bebec5">,</span><span> MAX_64x64</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        result </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#ef3b7d">this</span><span class="token" style="color:#bebec5">.</span><span class="token function">gavg</span><span class="token" style="color:#bebec5">(</span><span>MAX_64x64</span><span class="token" style="color:#bebec5">,</span><span> MAX_64x64</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>        </span><span class="token" style="color:#ef3b7d">assert</span><span class="token" style="color:#bebec5">(</span><span>result </span><span class="token" style="color:#a77afe">==</span><span> MAX_64x64</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span> catch </span><span class="token" style="color:#bebec5">{</span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>But I&#x27;m wondering why we have tests that are constructed for multiple different 64x64 libraries, when we are only testing one specific one. And whether we should even be writing tests that can handle multiple different libraries with different behavior.</p>
<h3 id="assumptions-are-not-clear"><a href="/unpublished/test-your-tests-tmp#assumptions-are-not-clear"><span class="icon icon-link"></span></a>Assumptions are not clear</h3>
<p>When reviewing the <code>inv_test_double_inverse</code> function, I noticed that because of the way the <code>loss</code> is computed, the function will reject any values where <code>x &lt; ONE_FP</code> (because the log would become negative and the <code>toUint</code> would then throw).</p>
<!-- -->
<p><strong><a target="_blank" rel="noreferrer" class="link" href="https://github.com/crytic/properties/blob/091654413501207323a4980f81e1349b09cf3a91/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L939-L950">ABDKMath64x64PropertyTests.sol</a></strong></p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#6f705e">// Test that the inverse of the inverse is close enough to the</span><span>
</span></span><span><span></span><span class="token" style="color:#6f705e">// original number</span><span>
</span></span><span><span></span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">inv_test_double_inverse</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int128</span><span> x</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">view</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    </span><span class="token" style="color:#ef3b7d">require</span><span class="token" style="color:#bebec5">(</span><span>x </span><span class="token" style="color:#a77afe">!=</span><span> ZERO_FP</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>    </span><span class="token builtin">int128</span><span> double_inv_x </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token function">inv</span><span class="token" style="color:#bebec5">(</span><span class="token function">inv</span><span class="token" style="color:#bebec5">(</span><span>x</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>    </span><span class="token" style="color:#6f705e">// The maximum loss of precision will be 2 * log2(x) bits rounded up</span><span>
</span></span><span><span>    </span><span class="token builtin">uint256</span><span> loss </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token" style="color:#a77afe">2</span><span> </span><span class="token" style="color:#a77afe">*</span><span> </span><span class="token function">toUInt</span><span class="token" style="color:#bebec5">(</span><span class="token function">log_2</span><span class="token" style="color:#bebec5">(</span><span>x</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">+</span><span> </span><span class="token" style="color:#a77afe">2</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>    </span><span class="token" style="color:#ef3b7d">assert</span><span class="token" style="color:#bebec5">(</span><span class="token function">equal_within_precision</span><span class="token" style="color:#bebec5">(</span><span>x</span><span class="token" style="color:#bebec5">,</span><span> double_inv_x</span><span class="token" style="color:#bebec5">,</span><span> loss</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>The only requirement for the test shows that <code>require(x != ZERO_FP)</code> which can give misleading guarantees. This is not the only function that does that.</p>
<h3 id="properties-are-not-clear"><a href="/unpublished/test-your-tests-tmp#properties-are-not-clear"><span class="icon icon-link"></span></a>Properties are not clear</h3>
<p>The properties checked in <code>mul_test_values</code> are not very clear (or are not tightly bound).</p>
<!-- -->
<p><strong><a target="_blank" rel="noreferrer" class="link" href="https://github.com/crytic/properties/blob/d3855861df5ff2f87fe2157de60417f9fc8cb4e3/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L552-L574">ABDKMath64x64PropertyTests.sol</a></strong></p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span class="token" style="color:#6f705e">// Test that the result increases or decreases depending</span><span>
</span></span><span><span></span><span class="token" style="color:#6f705e">// on the value to be added</span><span>
</span></span><span><span></span><span class="token" style="color:#ef3b7d">function</span><span> </span><span class="token function">mul_test_values</span><span class="token" style="color:#bebec5">(</span><span class="token builtin">int128</span><span> x</span><span class="token" style="color:#bebec5">,</span><span> </span><span class="token builtin">int128</span><span> y</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#ef3b7d">public</span><span> </span><span class="token" style="color:#ef3b7d">view</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>    </span><span class="token" style="color:#ef3b7d">require</span><span class="token" style="color:#bebec5">(</span><span>x </span><span class="token" style="color:#a77afe">!=</span><span> ZERO_FP </span><span class="token" style="color:#a77afe">&amp;&amp;</span><span> y </span><span class="token" style="color:#a77afe">!=</span><span> ZERO_FP</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>    </span><span class="token builtin">int128</span><span> x_y </span><span class="token" style="color:#a77afe">=</span><span> </span><span class="token function">mul</span><span class="token" style="color:#bebec5">(</span><span>x</span><span class="token" style="color:#bebec5">,</span><span> y</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>    </span><span class="token" style="color:#ef3b7d">require</span><span class="token" style="color:#bebec5">(</span><span class="token function">significant_digits_lost_in_mult</span><span class="token" style="color:#bebec5">(</span><span>x</span><span class="token" style="color:#bebec5">,</span><span> y</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#a77afe">==</span><span> </span><span class="token" style="color:#a77afe">false</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span>
</span><span><span>    </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span>x </span><span class="token" style="color:#a77afe">&gt;=</span><span> ZERO_FP</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span>y </span><span class="token" style="color:#a77afe">&gt;=</span><span> ONE_FP</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>            </span><span class="token" style="color:#ef3b7d">assert</span><span class="token" style="color:#bebec5">(</span><span>x_y </span><span class="token" style="color:#a77afe">&gt;=</span><span> x</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>        </span><span class="token" style="color:#bebec5">}</span><span> </span><span class="token" style="color:#ef3b7d">else</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>            </span><span class="token" style="color:#ef3b7d">assert</span><span class="token" style="color:#bebec5">(</span><span>x_y </span><span class="token" style="color:#a77afe">&lt;=</span><span> x</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>        </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span> </span><span class="token" style="color:#ef3b7d">else</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>        </span><span class="token" style="color:#ef3b7d">if</span><span> </span><span class="token" style="color:#bebec5">(</span><span>y </span><span class="token" style="color:#a77afe">&gt;=</span><span> ONE_FP</span><span class="token" style="color:#bebec5">)</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>            </span><span class="token" style="color:#ef3b7d">assert</span><span class="token" style="color:#bebec5">(</span><span>x_y </span><span class="token" style="color:#a77afe">&lt;=</span><span> x</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>        </span><span class="token" style="color:#bebec5">}</span><span> </span><span class="token" style="color:#ef3b7d">else</span><span> </span><span class="token" style="color:#bebec5">{</span><span>
</span></span><span><span>            </span><span class="token" style="color:#ef3b7d">assert</span><span class="token" style="color:#bebec5">(</span><span>x_y </span><span class="token" style="color:#a77afe">&gt;=</span><span> x</span><span class="token" style="color:#bebec5">)</span><span class="token" style="color:#bebec5">;</span><span>
</span></span><span><span>        </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span>    </span><span class="token" style="color:#bebec5">}</span><span>
</span></span><span><span></span><span class="token" style="color:#bebec5">}</span></span></code></pre></pre>
<p>This essentially translates to</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span>x &gt; 0 and y &gt;= 1: x * y &gt;= x
</span></span><span>x &lt; 0 and y &gt;= 1: x * y &lt;= x
</span><span>x &gt; 0 and y &lt;  1: x * y &lt;= x
</span><span>x &lt; 0 and y &lt;  1: x * y &gt;= x
</span></code></pre></pre>
<p>The first two cases show that the product will grow (or stay the same) in absolute value relative to <code>x</code> when <code>y &gt;= 1</code>.
And the second two cases show that the product shrinks in absolute value relative to <code>x</code> when <code>y &lt; 1</code>.</p>
<p>This could be better summarized as</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span>|y| &gt;= 1: |x * y| &gt;= |x|
</span></span><span>|y| &lt;  1: |x * y| &lt;  |x|
</span></code></pre></pre>
<p>Also, because the cases only check for positive bounds on <code>y &gt;= 1</code>, but not the negative <code>y &lt;= -1</code> (which would be captured by using <code>abs</code>).</p>
<h3 id="insufficient-coverage"><a href="/unpublished/test-your-tests-tmp#insufficient-coverage"><span class="icon icon-link"></span></a>Insufficient coverage</h3>
<p>There are functions that don&#x27;t seem to be covered correctly. For example, the <code>inv_test_multiplication</code> shows the following coverage after 50k runs.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span>  958 |     |     // Test the multiplication of inverses
</span></span><span>  959 |     |     // 1/(x * y) == 1/x * 1/y
</span><span>  960 | r   |     function inv_test_multiplication(int128 x, int128 y) public view {
</span><span>  961 | r   |         require(x != ZERO_FP &amp;&amp; y != ZERO_FP);
</span><span>  962 |     |
</span><span>  963 | r   |         int128 inv_x = inv(x);
</span><span>  964 | r   |         int128 inv_y = inv(y);
</span><span>  965 | r   |         int128 inv_x_times_inv_y = mul(inv_x, inv_y);
</span><span>  966 |     |
</span><span>  967 | r   |         int128 x_y = mul(x, y);
</span><span>  968 | r   |         int128 inv_x_y = inv(x_y);
</span><span>  969 |     |
</span><span>  970 | r   |         require(significant_bits_after_mult(x, y) &gt; REQUIRED_SIGNIFICANT_BITS);
</span><span>  971 | r   |         require(significant_bits_after_mult(inv_x, inv_y) &gt; REQUIRED_SIGNIFICANT_BITS);
</span><span>  972 |     |
</span><span>  973 |     |         // The maximum loss of precision is given by the formula:
</span><span>  974 |     |         // 2 * | log_2(x) - log_2(y) | + 1
</span><span>  975 |     |         uint256 loss = 2 * toUInt(abs(log_2(x) - log_2(y))) + 1;
</span><span>  976 |     |
</span><span>  977 |     |         assert(equal_within_precision(inv_x_y, inv_x_times_inv_y, loss));
</span><span>  978 |     |     }
</span></code></pre></pre>
<p>There are other cases where the full test paths are insufficiently covered after 50k runs.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span> 1516 |     |     // Test for logarithm of a power
</span></span><span> 1517 |     |     // log2(x ** y) = y * log2(x)
</span><span> 1518 | r   |     function log2_test_power(int128 x, uint256 y) public pure {
</span><span> 1519 | r   |         int128 x_y = pow(x, y);
</span><span> 1520 | r   |         int128 log2_x_y = log_2(x_y);
</span><span> 1521 |     |
</span><span> 1522 | r   |         uint256 y_log2_x = mulu(log_2(x), y);
</span><span> 1523 |     |
</span><span> 1524 |     |         assert(y_log2_x == toUInt(log2_x_y));
</span><span> 1525 |     |     }
</span></code></pre></pre>
<p>There are also certain branches that are not covered. Here, the if condition always reverts.</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span> 1682 |     |     // Test for inverse function
</span></span><span> 1683 |     |     // If y = log_2(x) then exp_2(y) == x
</span><span> 1684 | *r  |     function exp2_test_inverse(int128 x) public view {
</span><span> 1685 | *r  |         int128 log2_x = log_2(x);
</span><span> 1686 | *r  |         int128 exp2_x = exp_2(log2_x);
</span><span> 1687 |     |
</span><span> 1688 | *r  |         uint256 bits = 50;
</span><span> 1689 |     |
</span><span> 1690 | *r  |         if(log2_x &lt; ZERO_FP) {
</span><span> 1691 | r   |             bits = uint256(int256(bits) + int256(log2_x));
</span><span> 1692 |     |         }
</span><span> 1693 |     |
</span><span> 1694 | *r  |         assert(equal_most_significant_bits_within_precision(x, exp2_x, bits));
</span><span> 1695 |     |     }
</span></code></pre></pre>
<p>If we don&#x27;t reach the final <code>assert</code> statement after 50k runs, then I think we&#x27;re doing something wrong. The functions should not revert at all if we constrain it correctly (or only for single values). That would also give us assurance as to the valid intervals where this invariant holds true.</p>
<h3 id="failed-test-cases"><a href="/unpublished/test-your-tests-tmp#failed-test-cases"><span class="icon icon-link"></span></a>Failed test cases</h3>
<p>When I run the tests I get a reported test failure</p>
<pre><pre before="" class="" style="-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;white-space:pre-wrap;word-wrap:normal;font-family:Menlo, Monaco, &quot;Courier New&quot;, monospace;font-size:14px;color:#76d9e6;text-shadow:none;background:#2a2a2a;padding:15px;border-radius:4px;border:1px solid #e1e1e8;overflow:auto;position:relative"><code style="white-space:pre"><span><span>ln_test_distributive_mul(int128,int128): failed!💥
</span></span><span>  Call sequence:
</span><span>    ln_test_distributive_mul(118234586596974386564027176417986829418,9)
</span><span>
</span><span>Event sequence: Panic(1): Using assert.
</span></code></pre></pre>
<p>We should run the tests long enough to make sure that we actually catch failing tests. I believe this function is also so hard to test for the fuzzer, because of all the hard requirements on the input. This could be improved with better input bounding.</p>
<p><a target="_blank" rel="noreferrer" class="link" href="https://github.com/crytic/properties/blob/091654413501207323a4980f81e1349b09cf3a91/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#LL1611C1-L1630C6">https://github.com/crytic/properties/blob/091654413501207323a4980f81e1349b09cf3a91/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#LL1611C1-L1630C6</a></p>
<p>I think many of the issues stem from some design decisions around how Echidna tests work in general and we might need to re-think how we approach stateless tests with Echidna. Going through these made me consider that we might want to create some kind of more formalized guidelines for writing tests in general.</p></div></div></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"slug":["unpublished","test-your-tests-tmp"],"contentRaw":"\nPRB:\n\n- start with naming conventions\n- structure\n- unit vs integration vs fuzz vs fork (foundry book)\n- english specification\n- contract inheritance (Base.t.sol)\n\nTests are written in order to give a higher confidence about a function's behavior. This is all the more important when writing high assurance software, like smart contracts that could end up handling millions of dollars on a immutable ledger.\n\nWhen writing tests, they should be dealt with in a similar manner as runtime code. By that I mean that we should be thinking about what control-flow paths are being covered and what kind of assurance can be given for the function's behavior on what range of inputs. Inputs and edge-cases that are not covered should be considered without any behavioral guarantees.\n\nLet's look at some examples to make this less obscure.\n\n# Recommendations\n\n## Arrange Act Assert\n\n- **Guarantees for function execution or reversion for all possible input ranges:**\n  It's essential to know under what conditions a function passes and when it reverts. If we don't have any guarantees on the successful execution or failure of the function and this is not obviously detected in other tests, then all of our tests might appear meaningless.\n- **Correctly constraining input values:**\n  We don't want zero or low coverage on tests. Ideally (and I think in almost all cases we can), we should be able to explicitly define the input ranges for which the properties hold and constrain our inputs to those ranges without discarding tests. This ensures that we get sufficient coverage for those properties.\n- **Reverts should be explicitly handled or seen as test-failures:**\n  This is my biggest pain-point. Assertion mode makes sense for exploring large and complex stateful code, but I think it has little justification for these kind of stateless tests. We do not want silent reverts. We need the assurance that the test has successfully executed and we need to be explicit about when it reverts. At the moment it seems like the best solution is to run a campaign in `dapptest` mode.\n- **Avoid testing trivial properties:**\n  There are some trivial properties that are being checked. If we can clearly define one counter-cases where the property does not hold, then it is at least not trivial.\n- **Testing complex helper functions:**\n  The helper functions in this test suite are sufficiently complex to warrant tests themselves. I don't think that they all work as expected. The requirements of the helper functions should be made clear and if they are not satisfied, this should be immediately reported as a test-failure. Not checking these requirements for helper functions will end up as foot-guns when writing tests.\n- **Testing one property at a time:**\n  It's easier to track and comprehend tests that focus on a single property at a time. This also helps avoiding unintended interactions with multiple properties or early exits. It also helps when constraining inputs and their edge cases.\n- **Minimizing nested 'if' statements in tests:**\n  Nested 'if' conditions can be difficult to understand and prone to errors. We should consider early returns or breaking up tests into smaller, more manageable parts.\n- **Tight testing bounds:**\n  Tests that check for bounds should be tight, meaning an expansion of the bound should result in test failure. The edges of these bounds should be explicitly tested for the counter-case to ensure that the bounds are valid.\n\nThe rest shows some examples in the code.\n\n### Ensuring function execution success\n\nA big problem with the current test setup that I see is that it looks like the any of the ABDKMath functions could revert and the tests would pass nonetheless. E.g. the functions could be\n\n```solidity\nfunction add(int128 x, int128 y) internal pure returns (int128) {\n    revert();\n}\n```\n\nand many tests would still pass. It might sound trivial that it won't happen in this case, but it is less obvious for more complex functions. Also reversions can occur through division by zero checks or similar or through developer mistakes.\n\nThere is the coverage report, however inspecting it is cumbersome when prototyping tests or the library itself. It also doesn't report how often a path was taken, so it could be that there is one trivial case that is executed for the function and all other cases revert.\n\n### Testing trivial statements\n\nThe function `mul_test_range` tests the output range of the returned value from the `mul` function.\n\n\u003c!-- gh-embed:crytic:properties:d3855861df5ff2f87fe2157de60417f9fc8cb4e3:contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol:583:593 --\u003e\n\n**[ABDKMath64x64PropertyTests.sol](https://github.com/crytic/properties/blob/d3855861df5ff2f87fe2157de60417f9fc8cb4e3/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L583-L593)**\n\n```sol\n// The result of the multiplication must be between the maximum\n// and minimum allowed values for 64x64\nfunction mul_test_range(int128 x, int128 y) public view {\n    int128 result;\n    try this.mul(x, y) {\n        result = this.mul(x, y);\n        assert(result \u003c= MAX_64x64 \u0026\u0026 result \u003e= MIN_64x64);\n    } catch {\n        // If it reverts, just ignore\n    }\n}\n```\n\nWhen translating what the test covers back into natural language, it tests that \"if the mul function is successful, then my output should be in the valid range, if it reverts, then that's ok\". The problem I see with this function is that the output of the `mul` function is a `int128` and the range that is being tested is essentially `type(int128).min \u003c= int128(result) \u003c= type(int128).max`. This test is trivial and does not give any meaningful result. I also find the syntax to be hard to read and it could be simplified to this:\n\n```solidity\n    function mul_test_range(int128 x, int128 y) public view {\n        int128 result = this.mul(x, y);\n        assert(result \u003c= MAX_64x64 \u0026\u0026 result \u003e= MIN_64x64);\n    }\n```\n\nThough again, this test will always pass, regardless of the implementation of `mul`.\n\n### Not all input cases covered\n\nOne of the first and most important questions that I would want to know when testing a function is: For all input ranges, when does the function revert and when does it pass?\n\nThis function gives some guarantee that the `this.mul` function doesn't revert.\n\n\u003c!-- gh-embed:crytic:properties:d3855861df5ff2f87fe2157de60417f9fc8cb4e3:contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol:595:606 --\u003e\n\n**[ABDKMath64x64PropertyTests.sol](https://github.com/crytic/properties/blob/d3855861df5ff2f87fe2157de60417f9fc8cb4e3/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L595-L606)**\n\n```sol\n// Multiplying the maximum value times one shouldn't revert, as it is valid\n// Moreover, the result must be MAX_64x64\nfunction mul_test_maximum_value() public view {\n    int128 result;\n    try this.mul(MAX_64x64, ONE_FP) {\n        // Expected behaviour, does not revert\n        result = this.mul(MAX_64x64, ONE_FP);\n        assert(result == MAX_64x64);\n    } catch {\n        assert(false);\n    }\n}\n```\n\nHowever it is only a unit-test and does not give me sufficient guarantees over the whole input range of all values.\n\n### Tests should not be testing multiple things at once\n\nThe `div_test_division_identity` test tests both, division by `1` and by `0`.\n\n\u003c!-- gh-embed:crytic:properties:d3855861df5ff2f87fe2157de60417f9fc8cb4e3:contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol:635:653 --\u003e\n\n**[ABDKMath64x64PropertyTests.sol](https://github.com/crytic/properties/blob/d3855861df5ff2f87fe2157de60417f9fc8cb4e3/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L635-L653)**\n\n```sol\n// Test for identity property\n// x / 1 == x (equivalent to x / x == 1)\n// Moreover, x/x should not revert unless x == 0\nfunction div_test_division_identity(int128 x) public view {\n    int128 div_1 = div(x, ONE_FP);\n    assert(x == div_1);\n\n    int128 div_x;\n\n    try this.div(x, x) {\n        // This should always equal one\n        div_x = div(x, x);\n        assert(div_x == ONE_FP);\n    } catch {\n        // The only allowed case to revert is if x == 0\n        assert(x == ZERO_FP);\n    }\n\n}\n```\n\nWhile it's tempting to test multiple properties at once, the issue I see here is that the second test depends on the successful execution of the first. This would be ok if I had the guarantee that the division by `1` would always succeed and indeed return the same value.\n\n### Tested bounds are not tight\n\nWhen reviewing the test for `neg_test_maximum`, I noticed that the test is being performed on `MAX_64x64 - 1`.\n\n\u003c!-- gh-embed:crytic:properties:d3855861df5ff2f87fe2157de60417f9fc8cb4e3:contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol:786:794 --\u003e\n\n**[ABDKMath64x64PropertyTests.sol](https://github.com/crytic/properties/blob/d3855861df5ff2f87fe2157de60417f9fc8cb4e3/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L786-L794)**\n\n```sol\n// Test for the maximum value case\n// Since this is implementation-dependant, we will actually test with MAX_64x64-EPS\nfunction neg_test_maximum() public view {\n    try this.neg(sub(MAX_64x64, EPSILON)) {\n        // Expected behaviour, does not revert\n    } catch {\n        assert(false);\n    }\n}\n```\n\nThis is ok, however the bounds are not tight (i.e. the maximal value is not being checked). Furthermore, `neg` should be expected to work for any input except for `MIN_64x64` (including `MAX_64x64 `).\n\n### Helper functions not tested\n\nHelper functions, such as `most_significant_bits` are sufficiently complex that they would warrant their own tests to ensure that their functionality is correct.\n\n\u003c!-- gh-embed:crytic:properties:d3855861df5ff2f87fe2157de60417f9fc8cb4e3:contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol:106:122 --\u003e\n\n**[ABDKMath64x64PropertyTests.sol](https://github.com/crytic/properties/blob/d3855861df5ff2f87fe2157de60417f9fc8cb4e3/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L106-L122)**\n\n```sol\n// Return the i most significant bits from |n|. If n has less than i significant bits, return |n|\n// Uses functions from the library under test!\nfunction most_significant_bits(int128 n, uint256 i) public pure returns (uint256) {\n    // Create a mask consisting of i bits set to 1\n    uint256 mask = (2**i) - 1;\n\n    // Get the position of the MSB set to 1 of n\n    uint256 pos = uint64(toInt(log_2(n)) + 64 + 1);\n\n    // Get the positive value of n\n    uint256 value = (n\u003e0) ? uint128(n) : uint128(-n);\n\n    // Shift the mask to match the rightmost 1-set bit\n    if(pos \u003e i) { mask \u003c\u003c= (pos - i); }\n\n    return (value \u0026 mask);\n}\n```\n\nIf this function were to always return `0x0` for example, then many other tests would trivially pass. Also, touching on the first issue, if they were to revert, these tests would also trivially \"pass\".\n\nThe `most_significant_bits` function for example uses `log_2`, which has a `require(x \u003e 0)` statement. Judging from the comment in the function description, this function should not revert for negative numbers. What's more, the line `-n` can also revert when `n = type(int128).min`. This case does not seem to be handled and it is unclear what the output should be.\n\nThe same can be said for almost all helper functions.\n\n\u003c!-- gh-embed:crytic:properties:091654413501207323a4980f81e1349b09cf3a91:contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol:109:122 --\u003e\n\n**[ABDKMath64x64PropertyTests.sol](https://github.com/crytic/properties/blob/091654413501207323a4980f81e1349b09cf3a91/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L109-L122)**\n\n```sol\nfunction significant_bits_after_mult(\n    int128 a,\n    int128 b\n) public pure returns (uint256) {\n    int128 x = a \u003e= 0 ? a : -a;\n    int128 y = b \u003e= 0 ? b : -b;\n\n    int128 lx = toInt(log_2(x));\n    int128 ly = toInt(log_2(y));\n    int256 prec = lx + ly - 1;\n\n    if (prec \u003c -64) return 0;\n    else return (64 + uint256(prec));\n}\n```\n\nThere is also the `equal_within_precision` function which computes `(max - min)` for two `int128`s. And if this overflows the function will silently revert...\n\n\u003c!-- gh-embed:crytic:properties:091654413501207323a4980f81e1349b09cf3a91:contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol:51:65 --\u003e\n\n**[ABDKMath64x64PropertyTests.sol](https://github.com/crytic/properties/blob/091654413501207323a4980f81e1349b09cf3a91/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L51-L65)**\n\n```sol\n// These functions allows to compare a and b for equality, discarding\n// the last precision_bits bits.\n// An absolute value function is implemented inline in order to not use\n// the implementation from the library under test.\nfunction equal_within_precision(\n    int128 a,\n    int128 b,\n    uint256 precision_bits\n) public pure returns (bool) {\n    int128 max = (a \u003e b) ? a : b;\n    int128 min = (a \u003e b) ? b : a;\n    int128 r = (max - min) \u003e\u003e precision_bits;\n\n    return (r == 0);\n}\n```\n\n### Conditional branches for unit-tests\n\nThere are some tests that are effectively constructed as unit-tests. We (or the developer) should know with certainty what happens in those cases and we should not allow either outcome to pass.\n\n\u003c!-- gh-embed:crytic:properties:091654413501207323a4980f81e1349b09cf3a91:contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol:905:925 --\u003e\n\n**[ABDKMath64x64PropertyTests.sol](https://github.com/crytic/properties/blob/091654413501207323a4980f81e1349b09cf3a91/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L905-L925)**\n\n```sol\n// Test the maximum value\nfunction abs_test_maximum() public view {\n    int128 abs_max;\n\n    try this.abs(MAX_64x64) {\n        // If it doesn't revert, the value must be MAX_64x64\n        abs_max = this.abs(MAX_64x64);\n        assert(abs_max == MAX_64x64);\n    } catch {}\n}\n\n// Test the minimum value\nfunction abs_test_minimum() public view {\n    int128 abs_min;\n\n    try this.abs(MIN_64x64) {\n        // If it doesn't revert, the value must be the negative of MIN_64x64\n        abs_min = this.abs(MIN_64x64);\n        assert(abs_min == neg(MIN_64x64));\n    } catch {}\n}\n```\n\nThe test for the `abs` function is an example of this. The test passes if the function reverts, but it also passes if the function doesn't revert.\n\nThe `gavg` function uses conditional testing and has the comment that the overflow might be implementation specific.\n\n\u003c!-- gh-embed:crytic:properties:091654413501207323a4980f81e1349b09cf3a91:contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol:1213:1223 --\u003e\n\n**[ABDKMath64x64PropertyTests.sol](https://github.com/crytic/properties/blob/091654413501207323a4980f81e1349b09cf3a91/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L1213-L1223)**\n\n```sol\n// Test for the maximum value\nfunction gavg_test_maximum() public view {\n    int128 result;\n\n    // This may revert due to overflow depending on implementation\n    // If it doesn't revert, the result must be MAX_64x64\n    try this.gavg(MAX_64x64, MAX_64x64) {\n        result = this.gavg(MAX_64x64, MAX_64x64);\n        assert(result == MAX_64x64);\n    } catch {}\n}\n```\n\nBut I'm wondering why we have tests that are constructed for multiple different 64x64 libraries, when we are only testing one specific one. And whether we should even be writing tests that can handle multiple different libraries with different behavior.\n\n### Assumptions are not clear\n\nWhen reviewing the `inv_test_double_inverse` function, I noticed that because of the way the `loss` is computed, the function will reject any values where `x \u003c ONE_FP` (because the log would become negative and the `toUint` would then throw).\n\n\u003c!-- gh-embed:crytic:properties:091654413501207323a4980f81e1349b09cf3a91:contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol:939:950 --\u003e\n\n**[ABDKMath64x64PropertyTests.sol](https://github.com/crytic/properties/blob/091654413501207323a4980f81e1349b09cf3a91/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L939-L950)**\n\n```sol\n// Test that the inverse of the inverse is close enough to the\n// original number\nfunction inv_test_double_inverse(int128 x) public view {\n    require(x != ZERO_FP);\n\n    int128 double_inv_x = inv(inv(x));\n\n    // The maximum loss of precision will be 2 * log2(x) bits rounded up\n    uint256 loss = 2 * toUInt(log_2(x)) + 2;\n\n    assert(equal_within_precision(x, double_inv_x, loss));\n}\n```\n\nThe only requirement for the test shows that `require(x != ZERO_FP)` which can give misleading guarantees. This is not the only function that does that.\n\n### Properties are not clear\n\nThe properties checked in `mul_test_values` are not very clear (or are not tightly bound).\n\n\u003c!-- gh-embed:crytic:properties:d3855861df5ff2f87fe2157de60417f9fc8cb4e3:contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol:552:574 --\u003e\n\n**[ABDKMath64x64PropertyTests.sol](https://github.com/crytic/properties/blob/d3855861df5ff2f87fe2157de60417f9fc8cb4e3/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#L552-L574)**\n\n```sol\n// Test that the result increases or decreases depending\n// on the value to be added\nfunction mul_test_values(int128 x, int128 y) public view {\n    require(x != ZERO_FP \u0026\u0026 y != ZERO_FP);\n\n    int128 x_y = mul(x, y);\n\n    require(significant_digits_lost_in_mult(x, y) == false);\n\n    if (x \u003e= ZERO_FP) {\n        if (y \u003e= ONE_FP) {\n            assert(x_y \u003e= x);\n        } else {\n            assert(x_y \u003c= x);\n        }\n    } else {\n        if (y \u003e= ONE_FP) {\n            assert(x_y \u003c= x);\n        } else {\n            assert(x_y \u003e= x);\n        }\n    }\n}\n```\n\nThis essentially translates to\n\n```\nx \u003e 0 and y \u003e= 1: x * y \u003e= x\nx \u003c 0 and y \u003e= 1: x * y \u003c= x\nx \u003e 0 and y \u003c  1: x * y \u003c= x\nx \u003c 0 and y \u003c  1: x * y \u003e= x\n```\n\nThe first two cases show that the product will grow (or stay the same) in absolute value relative to `x` when `y \u003e= 1`.\nAnd the second two cases show that the product shrinks in absolute value relative to `x` when `y \u003c 1`.\n\nThis could be better summarized as\n\n```\n|y| \u003e= 1: |x * y| \u003e= |x|\n|y| \u003c  1: |x * y| \u003c  |x|\n```\n\nAlso, because the cases only check for positive bounds on `y \u003e= 1`, but not the negative `y \u003c= -1` (which would be captured by using `abs`).\n\n### Insufficient coverage\n\nThere are functions that don't seem to be covered correctly. For example, the `inv_test_multiplication` shows the following coverage after 50k runs.\n\n```\n  958 |     |     // Test the multiplication of inverses\n  959 |     |     // 1/(x * y) == 1/x * 1/y\n  960 | r   |     function inv_test_multiplication(int128 x, int128 y) public view {\n  961 | r   |         require(x != ZERO_FP \u0026\u0026 y != ZERO_FP);\n  962 |     |\n  963 | r   |         int128 inv_x = inv(x);\n  964 | r   |         int128 inv_y = inv(y);\n  965 | r   |         int128 inv_x_times_inv_y = mul(inv_x, inv_y);\n  966 |     |\n  967 | r   |         int128 x_y = mul(x, y);\n  968 | r   |         int128 inv_x_y = inv(x_y);\n  969 |     |\n  970 | r   |         require(significant_bits_after_mult(x, y) \u003e REQUIRED_SIGNIFICANT_BITS);\n  971 | r   |         require(significant_bits_after_mult(inv_x, inv_y) \u003e REQUIRED_SIGNIFICANT_BITS);\n  972 |     |\n  973 |     |         // The maximum loss of precision is given by the formula:\n  974 |     |         // 2 * | log_2(x) - log_2(y) | + 1\n  975 |     |         uint256 loss = 2 * toUInt(abs(log_2(x) - log_2(y))) + 1;\n  976 |     |\n  977 |     |         assert(equal_within_precision(inv_x_y, inv_x_times_inv_y, loss));\n  978 |     |     }\n```\n\nThere are other cases where the full test paths are insufficiently covered after 50k runs.\n\n```\n 1516 |     |     // Test for logarithm of a power\n 1517 |     |     // log2(x ** y) = y * log2(x)\n 1518 | r   |     function log2_test_power(int128 x, uint256 y) public pure {\n 1519 | r   |         int128 x_y = pow(x, y);\n 1520 | r   |         int128 log2_x_y = log_2(x_y);\n 1521 |     |\n 1522 | r   |         uint256 y_log2_x = mulu(log_2(x), y);\n 1523 |     |\n 1524 |     |         assert(y_log2_x == toUInt(log2_x_y));\n 1525 |     |     }\n```\n\nThere are also certain branches that are not covered. Here, the if condition always reverts.\n\n```\n 1682 |     |     // Test for inverse function\n 1683 |     |     // If y = log_2(x) then exp_2(y) == x\n 1684 | *r  |     function exp2_test_inverse(int128 x) public view {\n 1685 | *r  |         int128 log2_x = log_2(x);\n 1686 | *r  |         int128 exp2_x = exp_2(log2_x);\n 1687 |     |\n 1688 | *r  |         uint256 bits = 50;\n 1689 |     |\n 1690 | *r  |         if(log2_x \u003c ZERO_FP) {\n 1691 | r   |             bits = uint256(int256(bits) + int256(log2_x));\n 1692 |     |         }\n 1693 |     |\n 1694 | *r  |         assert(equal_most_significant_bits_within_precision(x, exp2_x, bits));\n 1695 |     |     }\n```\n\nIf we don't reach the final `assert` statement after 50k runs, then I think we're doing something wrong. The functions should not revert at all if we constrain it correctly (or only for single values). That would also give us assurance as to the valid intervals where this invariant holds true.\n\n### Failed test cases\n\nWhen I run the tests I get a reported test failure\n\n```\nln_test_distributive_mul(int128,int128): failed!:boom:\n  Call sequence:\n    ln_test_distributive_mul(118234586596974386564027176417986829418,9)\n\nEvent sequence: Panic(1): Using assert.\n```\n\nWe should run the tests long enough to make sure that we actually catch failing tests. I believe this function is also so hard to test for the fuzzer, because of all the hard requirements on the input. This could be improved with better input bounding.\n\nhttps://github.com/crytic/properties/blob/091654413501207323a4980f81e1349b09cf3a91/contracts/Math/ABDKMath64x64/ABDKMath64x64PropertyTests.sol#LL1611C1-L1630C6\n\nI think many of the issues stem from some design decisions around how Echidna tests work in general and we might need to re-think how we approach stateless tests with Echidna. Going through these made me consider that we might want to create some kind of more formalized guidelines for writing tests in general.\n","title":"Test Your Tests","date":"Feb 19, 2023","suptitle":"What makes a good and a bad test"}},"__N_SSG":true},"page":"/[...slug]","query":{"slug":["unpublished","test-your-tests-tmp"]},"buildId":"b06NupxvtES2cDfarn2Io","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>