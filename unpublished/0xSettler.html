<!DOCTYPE html><html><head><meta charSet="utf-8"/><title class="animate__fadeIn">0xPhaze</title><meta name="viewport" content="initial-scale=1.0, width=device-width"/><meta name="next-head-count" content="3"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/23a2b3bc93956487.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/23a2b3bc93956487.css" crossorigin="" data-n-g=""/><link rel="preload" href="/_next/static/css/5b6964bdff897f88.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/5b6964bdff897f88.css" crossorigin="" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-dcf4136cb4ed4a3e.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-10fac88913917d91.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-f2a13320fa311176.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-d2563c831d8a01f7.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/5423ad26-9ee507e8c57e7e9a.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/175675d1-b1f16020bd9e4fee.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/264-01fb23d8f50dfdd3.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/%5B...slug%5D-c108991d8dc26594.js" defer="" crossorigin=""></script><script src="/_next/static/AocSisQRIhnO2ZxvvO6f8/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/AocSisQRIhnO2ZxvvO6f8/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><div class="app px-4 pb-20 min-h-screen flex flex-col items-center w-full max-w-screen"><header class="w-full flex flex-col px-4 sm:px-8 md:px-12 max-w-5xl sm:flex-row justify-between items-center border-white/20 overflow-hidden border-b p-4 h-16"><div class="w-full h-full flex flex-col sm:flex-row justify-start sm:justify-between items-center gap-y-4 overflow-hidden sm:overflow-visible"><div class="flex w-full sm:w-fit items-center"><h1 class="text-xl mx-auto font-display"><a href="/">0xPhaze</a></h1><div class="my-auto -ml-6 w-6 sm:hidden"><div class="text-slate-300 hover:text-secondary-400 transition-colors duration-200 cursor-pointer h-6"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="bars" class="svg-inline--fa fa-bars " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M0 96C0 78.33 14.33 64 32 64H416C433.7 64 448 78.33 448 96C448 113.7 433.7 128 416 128H32C14.33 128 0 113.7 0 96zM0 256C0 238.3 14.33 224 32 224H416C433.7 224 448 238.3 448 256C448 273.7 433.7 288 416 288H32C14.33 288 0 273.7 0 256zM416 448H32C14.33 448 0 433.7 0 416C0 398.3 14.33 384 32 384H416C433.7 384 448 398.3 448 416C448 433.7 433.7 448 416 448z"></path></svg></div></div></div><div class="flex flex-col sm:flex-row gap-x-8 md:gap-x-10 gap-y-4"><div class="flex gap-x-2 sm:gap-x-5 items-center justify-evenly"><a target="_blank" rel="noreferrer" class="link" href="https://github.com/0xPhaze/"><div><div class="text-slate-300 hover:text-secondary-400 transition-colors duration-200 cursor-pointer"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="h-4"><path style="fill:currentColor" d="M12 0C5.374 0 0 5.373 0 12c0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23A11.509 11.509 0 0 1 12 5.803c1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576C20.566 21.797 24 17.3 24 12c0-6.627-5.373-12-12-12z"></path></svg></div></div></a><a target="_blank" rel="noreferrer" class="link" href="https://twitter.com/lovethewired"><div><div class="text-slate-300 hover:text-secondary-400 transition-colors duration-200 cursor-pointer"><svg viewBox="0 0 16 14" fill="none" xmlns="http://www.w3.org/2000/svg" class="h-4"><path style="fill:currentColor" d="M15.584 1.578a7.91 7.91 0 0 1-1.57 1.807v.482c0 .965-.112 1.929-.336 2.772-.224.965-.673 1.808-1.121 2.652a17.373 17.373 0 0 1-1.794 2.29c-.785.723-1.681 1.205-2.578 1.566-1.01.362-2.13.603-3.252.603-1.793 0-3.475-.603-4.932-1.567h.784c1.458 0 2.915-.482 4.036-1.446a2.914 2.914 0 0 1-1.905-.723c-.561-.482-.897-.964-1.122-1.687h.561c.336 0 .56 0 .897-.12C2.579 8.085 1.907 7.603 1.458 7 .785 6.398.561 5.675.561 4.83c.449.242 1.01.362 1.458.483A5.531 5.531 0 0 1 .898 4.109C.673 3.626.449 3.024.449 2.42c0-.602.112-1.205.449-1.687a8.606 8.606 0 0 0 2.914 2.53c1.122.603 2.355.965 3.7 1.086 0-.241-.112-.483-.112-.844 0-.723.224-1.326.56-1.928.337-.603.897-.965 1.458-1.326.56-.241 1.233-.362 1.906-.12.672.12 1.233.481 1.681.964.673-.121 1.458-.362 2.018-.844-.224.844-.784 1.446-1.457 1.928.785-.12 1.457-.24 2.018-.602Z" fill="#081026"></path></svg></div></div></a><div><div class="text-slate-300 hover:text-secondary-400 transition-colors duration-200 cursor-pointer">ABI</div></div><div><div class="text-slate-300 hover:text-secondary-400 transition-colors duration-200 cursor-pointer">ENC</div></div></div><button class="rounded px-4 py-2 uppercase text-white select-none  transition-all duration-300 disabled:pointer-events-none bg-primary-600 hover:bg-primary-700  !outline-none normal-case text-sm w-[140px] w-36">Connect Wallet</button></div></div></header><main class="gap-y-20 mt-8 py-4 sm:px-8 md:px-12 w-full min-h-[500px] max-w-4xl"><div class="flex flex-col justify-between gap-y-20"><div class="content markdown"><h1 class="text-center">0x Protocol Settler bug</h1><p class="text-slate-500 text-sm text-center">Dec 28, 2023</p><div class="mt-16"><ul>
<li><a href="/unpublished/0xSettler#intro">Intro</a></li>
<li><a href="/unpublished/0xSettler#overview">Overview</a></li>
<li><a href="/unpublished/0xSettler#the-sequencer">The sequencer</a></li>
<li><a href="/unpublished/0xSettler#before-the-malicious-transaction">Before the malicious transaction</a></li>
</ul>
<h2 id="intro"><a href="/unpublished/0xSettler#intro"><span class="icon icon-link"></span></a>Intro</h2>
<p>Arbitrum is an optimistic rollup on Ethereum. An optimistic rollup is a layer 2 scaling solution where transactions are posted in batches to a base layer—Ethereum. Ignoring the problem of decentralized sequencing—Rollup solutions build on some of Ethereum&#x27;s safety guarantees through its consensus mechanism, data availability and finality. In an optimistic scenario where every node participant is honest the optimistic rollup protocol requires minimal work and intervention, since every proposed rollup block can simply be accepted as canonical after passing its confirmation delay. However, in the case that a malicious actor is involved, the protocol must be prepared to efficiently determine the correct state all the while protecting itself from DoS attacks and finally punishing bad actors and reward the good. We will inspect this fraud proof mechanism in detail while looking at the source code.</p>
<p>So what happens exactly when, for example, Eve proposes a block that ends with her balance having increased by 100 Ether coming out of thin air? How does Arbitrum Nitro catch such an act and punish Eve?</p>
<p>It&#x27;s clear that any deviation resulting in the processing of transaction outcomes should be caught. Since computing the transaction results happens in <a target="_blank" rel="noreferrer" class="link" href="https://github.com/OffchainLabs/nitro">Arbitrum Nitro</a>—which builds on top of <a target="_blank" rel="noreferrer" class="link" href="https://github.com/ethereum/go-ethereum">Go-Ethereum</a>—another approach is to simply punish any deviation from running the Nitro node client. One problem to address for this approach is that the exact instructions being executed in the compiled binaries will vary depending on the target architectures (x86, ARM, ...). For this reason we need another layer of abstraction that will produce consistent outcomes independent of the machine. This is where WebAssembly (WASM) comes into play.</p>
<p>[rec][./recommendations.md]</p>
<p>I always wanted to write a book with <a href="http://daringfireball.net/projects/markdown">markdown</a>.</p>
<h2 id="overview"><a href="/unpublished/0xSettler#overview"><span class="icon icon-link"></span></a>Overview</h2>
<p>Github repositories:</p>
<p>Deployed to Ethereum:</p>




















<table><thead><tr><th>Description</th><th>Nitro</th><th>Stylus</th></tr></thead><tbody><tr><td></td><td><a target="_blank" rel="noreferrer" class="link" href="https://github.com/OffchainLabs/nitro">nitro</a></td><td><a target="_blank" rel="noreferrer" class="link" href="https://github.com/OffchainLabs/stylus">stylus</a></td></tr><tr><td>Core rollup contracts in <em>Solidity</em> deployed to <em>Ethereum</em></td><td><a target="_blank" rel="noreferrer" class="link" href="https://github.com/OffchainLabs/nitro-contracts">nitro-contracts</a></td><td><a target="_blank" rel="noreferrer" class="link" href="https://github.com/OffchainLabs/stylus-contracts">stylus-contracts</a></td></tr></tbody></table>
<ul>
<li>Nitro&#x27;s core rollup contracts (Solidity)</li>
<li><a target="_blank" rel="noreferrer" class="link" href="https://github.com/OffchainLabs/token-bridge-contracts">token-bridge-contracts</a>: ERC20 token bridge contracts (Solidity)</li>
</ul>
<p>Run by validators:</p>
<ul>
<li>(fork of ):</li>
</ul>
<h2 id="the-sequencer"><a href="/unpublished/0xSettler#the-sequencer"><span class="icon icon-link"></span></a>The sequencer</h2>
<p>The sequencer is the currently centralized entity that determines an order for incoming L2 transactions into L2 blocks. This order is committed to the parent chain (Ethereum) to ensure data availability and finality of the ordering. From here on, the state transition of the rollup is determined deterministically. This means that anyone can process and simulate the sequencer transactions locally to calculate the future state of the rollup without waiting the full 7 day finality period for proposed L2 blocks. This also means that it&#x27;s not required for Arbitrum nodes to communicate with each other, since the sequencer is the only entity that is able to influence the L2 end state.</p>
<p>Questions:</p>
<ul>
<li>How even include a malicious transaction? The node doesn&#x27;t provide apis for malicious actions, and invalid transactions will be discarded.</li>
<li>What parts of the protocol are involved?</li>
<li>How does fraud proving work?</li>
</ul>
<h2 id="before-the-malicious-transaction"><a href="/unpublished/0xSettler#before-the-malicious-transaction"><span class="icon icon-link"></span></a>Before the malicious transaction</h2>
<p>In this section we&#x27;ll briefly describe the protocol in its optimistic workings—when all transactions are valid.</p>
<p>Alice sends a signed transaction to the sequencer that will end up paying Bob 1 Ether. Currently, there is only a single sequencer controlled by Arbitrum (active work is being put in to change this in the future with systems such as <a target="_blank" rel="noreferrer" class="link" href="https://twitter.com/sgoldfed/status/1740109895494693334">Espresso Systems</a> working on a shared, decentralized sequencer).</p>
<p>TODO: sequencing mechanics in ArbOS and sequence posting + feed.</p>
<p>Once the sequence is committed with finality and readily available to everyone, the future state of Arbitrum&#x27;s rollup is known, since it&#x27;s a deterministic process from here on. Arbitrum validators can create new attestations to the new rollup block state. This is done in</p>
<p>X</p>
<p>X</p>
<p>X</p>
<p>X</p>
<p>X</p>
<p>X</p>
<p>X</p>
<p>X</p>
<p>X</p>
<p>X</p>
<p>X</p>
<p>X</p>
<p>X</p>
<p>X</p>
<p>X</p>
<p>X</p>
<p>X</p>
<p>X</p>
<p>X</p>
<p>X</p>
<p>X</p>
<p>X</p>
<p>X</p>
<p>X</p>
<p>X</p>
<p>X</p>
<p>X</p>
<p>X</p>
<p>X</p>
<p>X</p>
<p>X</p>
<p>X</p></div></div></div></main></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"postData":{"slug":["unpublished","0xSettler"],"contentRaw":"\n- [Intro](#intro)\n- [Overview](#overview)\n- [The sequencer](#the-sequencer)\n- [Before the malicious transaction](#before-the-malicious-transaction)\n\n# Intro\n\nArbitrum is an optimistic rollup on Ethereum. An optimistic rollup is a layer 2 scaling solution where transactions are posted in batches to a base layer—Ethereum. Ignoring the problem of decentralized sequencing—Rollup solutions build on some of Ethereum's safety guarantees through its consensus mechanism, data availability and finality. In an optimistic scenario where every node participant is honest the optimistic rollup protocol requires minimal work and intervention, since every proposed rollup block can simply be accepted as canonical after passing its confirmation delay. However, in the case that a malicious actor is involved, the protocol must be prepared to efficiently determine the correct state all the while protecting itself from DoS attacks and finally punishing bad actors and reward the good. We will inspect this fraud proof mechanism in detail while looking at the source code.\n\nSo what happens exactly when, for example, Eve proposes a block that ends with her balance having increased by 100 Ether coming out of thin air? How does Arbitrum Nitro catch such an act and punish Eve?\n\nIt's clear that any deviation resulting in the processing of transaction outcomes should be caught. Since computing the transaction results happens in [Arbitrum Nitro](https://github.com/OffchainLabs/nitro)—which builds on top of [Go-Ethereum](https://github.com/ethereum/go-ethereum)—another approach is to simply punish any deviation from running the Nitro node client. One problem to address for this approach is that the exact instructions being executed in the compiled binaries will vary depending on the target architectures (x86, ARM, ...). For this reason we need another layer of abstraction that will produce consistent outcomes independent of the machine. This is where WebAssembly (WASM) comes into play.\n\n[rec][./recommendations.md]\n\nI always wanted to write a book with [markdown][mkdnlink].\n\n[mkdnlink]: http://daringfireball.net/projects/markdown\n\n# Overview\n\nGithub repositories:\n\nDeployed to Ethereum:\n\n| Description                                                | Nitro                                                              | Stylus                                                               |\n| ---------------------------------------------------------- | ------------------------------------------------------------------ | -------------------------------------------------------------------- |\n|                                                            | [nitro](https://github.com/OffchainLabs/nitro)                     | [stylus](https://github.com/OffchainLabs/stylus)                     |\n| Core rollup contracts in _Solidity_ deployed to _Ethereum_ | [nitro-contracts](https://github.com/OffchainLabs/nitro-contracts) | [stylus-contracts](https://github.com/OffchainLabs/stylus-contracts) |\n\n- Nitro's core rollup contracts (Solidity)\n- [token-bridge-contracts](https://github.com/OffchainLabs/token-bridge-contracts): ERC20 token bridge contracts (Solidity)\n\nRun by validators:\n\n- (fork of ):\n\n# The sequencer\n\nThe sequencer is the currently centralized entity that determines an order for incoming L2 transactions into L2 blocks. This order is committed to the parent chain (Ethereum) to ensure data availability and finality of the ordering. From here on, the state transition of the rollup is determined deterministically. This means that anyone can process and simulate the sequencer transactions locally to calculate the future state of the rollup without waiting the full 7 day finality period for proposed L2 blocks. This also means that it's not required for Arbitrum nodes to communicate with each other, since the sequencer is the only entity that is able to influence the L2 end state.\n\nQuestions:\n\n- How even include a malicious transaction? The node doesn't provide apis for malicious actions, and invalid transactions will be discarded.\n- What parts of the protocol are involved?\n- How does fraud proving work?\n\n# Before the malicious transaction\n\nIn this section we'll briefly describe the protocol in its optimistic workings—when all transactions are valid.\n\nAlice sends a signed transaction to the sequencer that will end up paying Bob 1 Ether. Currently, there is only a single sequencer controlled by Arbitrum (active work is being put in to change this in the future with systems such as [Espresso Systems](https://twitter.com/sgoldfed/status/1740109895494693334) working on a shared, decentralized sequencer).\n\nTODO: sequencing mechanics in ArbOS and sequence posting + feed.\n\nOnce the sequence is committed with finality and readily available to everyone, the future state of Arbitrum's rollup is known, since it's a deterministic process from here on. Arbitrum validators can create new attestations to the new rollup block state. This is done in\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n\nX\n","title":"0x Protocol Settler bug","date":"Dec 28, 2023","suptitle":null}},"__N_SSG":true},"page":"/[...slug]","query":{"slug":["unpublished","0xSettler"]},"buildId":"AocSisQRIhnO2ZxvvO6f8","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>