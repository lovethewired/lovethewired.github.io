<!DOCTYPE html><html><head><meta charSet="utf-8"/><title class="animate__fadeIn">0xPhaze</title><meta name="viewport" content="initial-scale=1.0, width=device-width"/><meta name="next-head-count" content="3"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/802638926a2eb779.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/802638926a2eb779.css" crossorigin="" data-n-g=""/><link rel="preload" href="/_next/static/css/5b6964bdff897f88.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/5b6964bdff897f88.css" crossorigin="" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-dcf4136cb4ed4a3e.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-10fac88913917d91.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-f2a13320fa311176.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-d2563c831d8a01f7.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/5423ad26-9ee507e8c57e7e9a.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/175675d1-b1f16020bd9e4fee.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/264-01fb23d8f50dfdd3.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/%5B...slug%5D-e2b689577b51a7c3.js" defer="" crossorigin=""></script><script src="/_next/static/x5f4kHXjRlrAhViHGaz-k/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/x5f4kHXjRlrAhViHGaz-k/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><div class="app px-4 pb-20 min-h-screen flex flex-col items-center w-full max-w-screen"><header class="w-full flex flex-col px-4 sm:px-8 md:px-12 max-w-5xl sm:flex-row justify-between items-center border-white/20 overflow-hidden border-b p-4 h-16"><div class="w-full h-full flex flex-col sm:flex-row justify-start sm:justify-between items-center gap-y-4 overflow-hidden sm:overflow-visible"><div class="flex w-full sm:w-fit items-center"><h1 class="text-xl mx-auto font-display"><a href="/">0xPhaze</a></h1><div class="my-auto -ml-6 w-6 sm:hidden"><div class="text-slate-300 hover:text-secondary-400 transition-colors duration-200 cursor-pointer h-6"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="bars" class="svg-inline--fa fa-bars " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M0 96C0 78.33 14.33 64 32 64H416C433.7 64 448 78.33 448 96C448 113.7 433.7 128 416 128H32C14.33 128 0 113.7 0 96zM0 256C0 238.3 14.33 224 32 224H416C433.7 224 448 238.3 448 256C448 273.7 433.7 288 416 288H32C14.33 288 0 273.7 0 256zM416 448H32C14.33 448 0 433.7 0 416C0 398.3 14.33 384 32 384H416C433.7 384 448 398.3 448 416C448 433.7 433.7 448 416 448z"></path></svg></div></div></div><div class="flex flex-col sm:flex-row gap-x-8 md:gap-x-10 gap-y-4"><div class="flex gap-x-2 sm:gap-x-5 items-center justify-evenly"><a target="_blank" rel="noreferrer" class="link" href="https://github.com/0xPhaze/"><div><div class="text-slate-300 hover:text-secondary-400 transition-colors duration-200 cursor-pointer"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="h-4"><path style="fill:currentColor" d="M12 0C5.374 0 0 5.373 0 12c0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23A11.509 11.509 0 0 1 12 5.803c1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576C20.566 21.797 24 17.3 24 12c0-6.627-5.373-12-12-12z"></path></svg></div></div></a><a target="_blank" rel="noreferrer" class="link" href="https://twitter.com/lovethewired"><div><div class="text-slate-300 hover:text-secondary-400 transition-colors duration-200 cursor-pointer"><svg viewBox="0 0 16 14" fill="none" xmlns="http://www.w3.org/2000/svg" class="h-4"><path style="fill:currentColor" d="M15.584 1.578a7.91 7.91 0 0 1-1.57 1.807v.482c0 .965-.112 1.929-.336 2.772-.224.965-.673 1.808-1.121 2.652a17.373 17.373 0 0 1-1.794 2.29c-.785.723-1.681 1.205-2.578 1.566-1.01.362-2.13.603-3.252.603-1.793 0-3.475-.603-4.932-1.567h.784c1.458 0 2.915-.482 4.036-1.446a2.914 2.914 0 0 1-1.905-.723c-.561-.482-.897-.964-1.122-1.687h.561c.336 0 .56 0 .897-.12C2.579 8.085 1.907 7.603 1.458 7 .785 6.398.561 5.675.561 4.83c.449.242 1.01.362 1.458.483A5.531 5.531 0 0 1 .898 4.109C.673 3.626.449 3.024.449 2.42c0-.602.112-1.205.449-1.687a8.606 8.606 0 0 0 2.914 2.53c1.122.603 2.355.965 3.7 1.086 0-.241-.112-.483-.112-.844 0-.723.224-1.326.56-1.928.337-.603.897-.965 1.458-1.326.56-.241 1.233-.362 1.906-.12.672.12 1.233.481 1.681.964.673-.121 1.458-.362 2.018-.844-.224.844-.784 1.446-1.457 1.928.785-.12 1.457-.24 2.018-.602Z" fill="#081026"></path></svg></div></div></a><div><div class="text-slate-300 hover:text-secondary-400 transition-colors duration-200 cursor-pointer">ABI</div></div><div><div class="text-slate-300 hover:text-secondary-400 transition-colors duration-200 cursor-pointer">ENC</div></div></div><button class="rounded px-4 py-2 uppercase text-white select-none  transition-all duration-300 disabled:pointer-events-none bg-primary-600 hover:bg-primary-700  !outline-none normal-case text-sm w-[140px] w-36">Connect Wallet</button></div></div></header><main class="gap-y-20 mt-8 py-4 sm:px-8 md:px-12 w-full min-h-[500px] max-w-4xl"><div class="flex flex-col justify-between gap-y-20"><div class="content markdown"><h1 class="text-center">Shared Sequencing</h1><p class="text-slate-500 text-sm text-center">Apr 24, 2024</p><div class="mt-16"><ul>
<li><a href="/unpublished/shared-sequencing#what-is-shared-sequencing">What is shared sequencing?</a>
<ul>
<li><a href="/unpublished/shared-sequencing#what-is-a-rollup">What is a rollup?</a></li>
<li><a href="/unpublished/shared-sequencing#what-is-the-sequencers-role">What is the sequencer&#x27;s role?</a></li>
<li><a href="/unpublished/shared-sequencing#why-should-we-care-about-decentralizing-the-sequencer">Why should we care about decentralizing the sequencer?</a></li>
</ul>
</li>
<li><a href="/unpublished/shared-sequencing#overview-of-the-shared-sequencer-stack">Overview of the shared sequencer stack</a>
<ul>
<li><a href="/unpublished/shared-sequencing#the-sequencing-layer">The sequencing layer</a>
<ul>
<li><a href="/unpublished/shared-sequencing#a-rollup-agnostic-super-block">A rollup agnostic super block</a></li>
<li><a href="/unpublished/shared-sequencing#lazy-sequencing">Lazy sequencing</a></li>
<li><a href="/unpublished/shared-sequencing#atomic-composability">Atomic composability</a></li>
</ul>
</li>
<li><a href="/unpublished/shared-sequencing#consensus-algorithm">Consensus algorithm</a></li>
<li><a href="/unpublished/shared-sequencing#based-rollups">Based rollups</a></li>
<li><a href="/unpublished/shared-sequencing#proposer-builder-separation">Proposer builder separation</a></li>
<li><a href="/unpublished/shared-sequencing#data-availability">Data Availability</a></li>
<li><a href="/unpublished/shared-sequencing#encryption">Encryption</a></li>
</ul>
</li>
<li><a href="/unpublished/shared-sequencing#current-state-of-shared-sequencing">Current state of shared sequencing</a>
<ul>
<li><a href="/unpublished/shared-sequencing#overview-of-different-platforms">Overview of different platforms</a></li>
<li><a href="/unpublished/shared-sequencing#rollup-alignment">Rollup alignment</a></li>
</ul>
</li>
<li><a href="/unpublished/shared-sequencing#research-questions-and-outlooks">Research questions and outlooks</a></li>
<li><a href="/unpublished/shared-sequencing#conclusion">Conclusion</a></li>
</ul>
<h2 id="what-is-shared-sequencing"><a href="/unpublished/shared-sequencing#what-is-shared-sequencing"><span class="icon icon-link"></span></a>What is shared sequencing?</h2>
<h3 id="what-is-a-rollup"><a href="/unpublished/shared-sequencing#what-is-a-rollup"><span class="icon icon-link"></span></a>What is a rollup?</h3>
<p>A rollup chain—a layer 2 blockchain—is a blockchain that builds on top of another host blockchain—the layer 1 blockchain. It can be characterized by a few key points:</p>
<ol>
<li>Builds on top of L1.</li>
<li>Inherits L1 security: Objective finality (fraud proofs or validity proofs).</li>
<li>Liveness guarantees from L1: L1 chain is unlikely to go offline.</li>
<li>Data availability guaranteed through L1: Transactions are posted as calldata or blobs.</li>
<li>Cheaper due to transaction compression, off-chain execution, and small state commits.</li>
</ol>
<p>The L2 chain inherits the L1 chain&#x27;s finality guarantees. Once a fraud proof window has passed or a validity proof has been included in a finalized L1 block, it is automatically finalized as seen by the L2. A double spending attack would require an L1 chain block reorganization.</p>
<p>The L2 chain also benefits from the host chain&#x27;s decentralized validator set and economic security in terms of liveness. The L1 chain is unlikely to go offline and censor transactions. In principle, the rollup should be able to continue advancing its state and produce blocks as long as the L1 chain is online.</p>
<p>The layer 2 blockchain will likely run a layer 1 node in parallel. Since all the relevant layer 2 transaction data is available when syncing the layer 1 node—either through L1 calldata or EIP-4844 data blobs—the state of the layer 2 blockchain can be recomputed entirely by only relying on data from the host blockchain.</p>
<p>Rollups benefit from cheaper transaction costs. This is because layer 2 transaction data can be compressed and decompressed off-chain. Also, costly updates to the state database and execution do not happen on the more expensive layer 1 chain. Only every N block/state commits are required to be stored in the host chain&#x27;s rollup contract.</p>
<p>A big challenge that most rollups face today is meeting the demand for faster finality than L1 for improved user experience. This forces the rollup to use a centralized and trusted sequencer.</p>
<h3 id="what-is-the-sequencers-role"><a href="/unpublished/shared-sequencing#what-is-the-sequencers-role"><span class="icon icon-link"></span></a>What is the sequencer&#x27;s role?</h3>
<p>When a user sends a layer 2 transaction, it is first picked up by the sequencer. The sequencer&#x27;s job is to commit to a transaction ordering such that the new rollup state can be determined reliably. Once the ordering is set, all other node operators can compute the rollup&#x27;s new state by applying the deterministic state transition function iteratively producing layer 2 blocks.</p>
<p><img src="/data/blog/2023/arbitrum/arbitrum-nitro-whitepaper-transaction.png" alt="Arbitrum&#x27;s transaction lifecycle"/></p>
<ol>
<li>Sequencer receives multiple user transactions</li>
<li>Sequencer orders these</li>
<li>Sequencer sends out an ordering promise (feed)</li>
<li>Batched and compressed transactions are committed to L1 chain</li>
<li>The L2 transactions are executed off-chain</li>
<li>The new L2 blocks are confirmed to the L1 chain</li>
</ol>
<p>The new state can be computed by running the Nitro Geth fork which also fetches the transaction data from the layer 1 blockchain. The transaction data itself does not necessarily need to be committed to persistent state. It is often only included as transaction calldata to the sequencers ordering commitment such that layer 1 operators are able to fetch and process the transactions. An alternative that has been made possible recently through EIP-4844 is to use data blobs for the transaction data availability.</p>
<p>While fraud proving an invalid block is less permissioned, the sequencer is arguably the most centralized component of today&#x27;s layer 2 rollups.</p>
<p>The reason that the shared sequencer often is a centralized component today is that it is quite an engineering feat to implement. All other rollup components work deterministic and are clear to compute, whereas decentralizing the sequencer requires an additional consensus algorithm or auctioning mechanism. Along with this come a plethora of fairness, economic security and decentralized coordination questions and concerns. Similar to the advantages of being able to produce the block on a layer 1 blockchain, being able to determine the transaction ordering comes with the ability of extracting user value and transaction censorship.</p>
<h3 id="why-should-we-care-about-decentralizing-the-sequencer"><a href="/unpublished/shared-sequencing#why-should-we-care-about-decentralizing-the-sequencer"><span class="icon icon-link"></span></a>Why should we care about decentralizing the sequencer?</h3>
<p>Building a shared sequencer that is fast, incorruptible and decentralized might seem like a <strong>big engineering undertaking</strong> that probably will come with a slightly <strong>worse user experience</strong>, <strong>additional security risks</strong> and a <strong>loss in autonomy and fees for rollups</strong>. <em>Why would we even want and care for decentralizing the sequencer?</em></p>
<p>As with many blockchain components, a <strong>central point of failure</strong> is not desirable. The goal is to build censorship resistant and resilient infrastructure that cannot be corrupted in the moment when it counts. Having a centralized component inevitably means that a party with enough influence might be able to corrupt the component if the desire is high enough. This can in the form of a government decree that aims to censor certain users and protocols or by any actor with a shared interest. <strong>Censorship and inclusion delays</strong> can even come from the rollup&#x27;s sequencer themselves. Further, an accidental server crash or data breach can occur leading to protocol <strong>liveness</strong> issues. Or worse, a sequencer might not fulfill its promise to include pre-committed transactions opening up the possibility of <strong>double spend attacks</strong>.</p>
<p>Currently, most centralized sequencers handle incoming user transactions via a private transaction mem-pool on a first come first serve basis. Having complete control over the sequencer also means that there is a monopoly on inclusion and ordering pricing. In principle, the sequencer stands to benefit from performing MEV (front and back-running, delaying or including its own transactions) or from selling the block building rights.</p>
<p>In summary, the following reasons highlight why we would want to move away from a centralized sequencer:</p>
<ul>
<li>Censorship resistance</li>
<li>Robustness: Liveness</li>
<li>Trust requirements</li>
<li>Block building rights for all</li>
</ul>
<p>If a sequencer is decentralized, there is no need for it to only server one rollup. A decentralized sequencing protocol might as well act as a shared sequencing abstraction layer that multiple rollups can plug into. This opens up the door to the possibility of atomic composability between rollups. Outsourcing the sequencer role for rollups to a shared sequencer service can come with the added benefits of:</p>
<ul>
<li>Decentralized sequencing</li>
<li>Outsourced development cost</li>
<li>Higher code security guarantees</li>
<li>Atomic composability</li>
<li>Batch posting cost amortization</li>
</ul>
<p>Further, some shared sequencer services want to provide even more value, such as:</p>
<ul>
<li>Pre-execution privacy (encrypted mem-pool)</li>
<li>Subsidized transactions &amp; MEV revenue share</li>
<li>Block builder auctions</li>
<li>Reduced costs: Integration with Data Availability layer</li>
<li>Guaranteed pre-commits</li>
<li>Restaking ability</li>
</ul>
<p>It is unclear whether most rollups will be interested in sharing a sequencer. As block building rights can be auctioned off at high prices and can lead to bad user experience, most bigger rollup chains will likely employ their own solutions and either capture and redistribute or use a fair ordering mechanism. Decentralizing the sequencer is currently part of Arbitrum&#x27;s and Optimism&#x27;s roadmap. Smaller blockchains with less engineering manpower will be happy to plug in a modular component that offers a decentralized sequencing solution with some added benefit.</p>
<h2 id="overview-of-the-shared-sequencer-stack"><a href="/unpublished/shared-sequencing#overview-of-the-shared-sequencer-stack"><span class="icon icon-link"></span></a>Overview of the shared sequencer stack</h2>
<h3 id="the-sequencing-layer"><a href="/unpublished/shared-sequencing#the-sequencing-layer"><span class="icon icon-link"></span></a>The sequencing layer</h3>
<p>When talking about integrating a shared/decentralized sequencer into a rollup protocol the idea is to abstract and outsource the entire sequencing process into a &quot;sequencing layer&quot;.</p>
<p><img src="shared-sequencing-layer.svg" alt="Shared sequencing layer"/></p>
<ol>
<li>Multiple transactions from multiple rollups are processed by the sequencing layer</li>
<li>The sequencing layer produces a &quot;super block&quot; by some mechanism</li>
<li>The individual transactions are processed by the respective rollup chains</li>
</ol>
<p>A <em>shared sequencer</em> can be shared by multiple rollups. Once the infrastructure for a decentralized sequencer has been built it can, at least in theory, easily be plugged into other rollups as well.</p>
<h3 id="a-rollup-agnostic-super-block"><a href="/unpublished/shared-sequencing#a-rollup-agnostic-super-block"><span class="icon icon-link"></span></a>A rollup agnostic super block</h3>
<p>A shared sequencer can produce a block containing transactions for multiple rollups. This is sometimes referred to as a &quot;super block&quot;. A super block is technically not a block, but more of a list of transactions, since the transactions are not actually executed in the sequencing layer. In order to abstract the sequencing layer, it has to be decoupled from the execution layer. If a shared sequencer should be able to handle the ordering of transactions from any kind of rollup, then it inevitably must be agnostic to the rollup&#x27;s executing virtual machine.</p>
<h3 id="lazy-sequencing"><a href="/unpublished/shared-sequencing#lazy-sequencing"><span class="icon icon-link"></span></a>Lazy sequencing</h3>
<p>This also has the added benefit that the sequencing layer now can solely focus on one thing—the sequencing. Any sequencing mechanism that is dependent on the execution machine will suffer from potential Denial-of-service attack vectors. This is because the sequencers now must also be able to execute and produce blocks from various different rollups requiring running multiple different blockchain node programs in parallel.</p>
<h3 id="atomic-composability"><a href="/unpublished/shared-sequencing#atomic-composability"><span class="icon icon-link"></span></a>Atomic composability</h3>
<p>A desirable property for super blocks is <strong>atomic intra-rollup composability</strong>. For example, a bridging transaction typically involves burning tokens on the source chain and minting them on the target chain. If a shared sequencer has the ability to atomically include transactions from various rollups, then it is also possible to include both a burn and a mint transaction atomically greatly enhancing the bridging experience.</p>
<p>Unfortunately, atomic inclusion does not guarantee atomic execution. This is because of the desired requirement of decoupling the sequencing from the execution layer. A shared sequencer can guarantee the inclusion of both transactions in their respective chains, however it cannot guarantee that these transactions will not fail.</p>
<p>Previously valid transactions can revert upon actual execution due to state changes in the blockchain. A user might have transferred the tokens out of their wallet or simply increased their account&#x27;s nonce in the meantime. It would be a serious issue if the burn transaction failed, but the mint transaction succeeded.</p>
<h3 id="consensus-algorithm"><a href="/unpublished/shared-sequencing#consensus-algorithm"><span class="icon icon-link"></span></a>Consensus algorithm</h3>
<p>Decentralizing the sequencer comes with the added challenge of reaching consensus in an adversarial setting. A set of distributed nodes needs to be able to agree on the next set of transactions in the presence of faulty and malicious nodes. This is called byzantine fault tolerance (BFT) and remains a core problem to solve for layer one blockchains.</p>
<p>The previous transaction lifecycle diagram makes it clear that our newly computed state is dependent on the ordered set of transaction inputs. Given these inputs, the rollup&#x27;s state transition function will deterministically produce L2 blocks and other nodes will always arrive at the same L2 state root. This is also largely much how L1 blockchains work today. Given a list of ordered transactions, a L1 block is executed deterministically to arrive at a new state root.</p>
<p>The only non-deterministic part of a blockchain&#x27;s state machine is the list of transactions that make up a block. The challenge lies in coordinating who gets to elect the new block.</p>
<h3 id="based-rollups"><a href="/unpublished/shared-sequencing#based-rollups"><span class="icon icon-link"></span></a>Based rollups</h3>
<p>With all the additional complications that decentralizing the sequencer brings forth, is there no simpler way to reach consensus? There is.. A <em>based rollup</em> simply uses the host chain&#x27;s consensus mechanism to determine the rollup chain&#x27;s transaction ordering. This can be achieved by allowing anyone to propose and submit a new block in the rollup&#x27;s sequencing smart contract. This way, once the host chain&#x27;s blocks are finalized, a transaction ordering will be determined.</p>
<p><em>Why would we still want to consider alternative solutions to based rollups?</em></p>
<p>The transaction confirmation speed of based rollups will always be limited to the host chain&#x27;s confirmation speed. A centralized sequencer can give out instant pre-commitment confirmations of the transaction ordering, because it is the only leader and it knows it can fulfill the promise. Although this is not implemented by most rollups with a centralized sequencer, these pre-commitments could be accompanied by a verifiable signature and a slashing mechanism in the case that the sequencer breaks its promise. This makes for a great user experience as the confirmation speed is increased at the expense of decentralization.</p>
<p><em>Why should we even build on top of an L1 at all?</em></p>
<p>Using a host chain as a base settlement layer can still provide benefits. By leveraging the host chain&#x27;s execution layer, a rollup&#x27;s entire fraud proving system can be secured or validity proofs can be verified immediately. Further mechanisms such as slashing can be integrated and benefit from the embedded environment&#x27;s economic security. Data availability and liveness are still strong arguments for building on top of a well-established layer one chain, although this might change if another consensus mechanism is implemented and data availability services are integrated.</p>
<h3 id="proposer-builder-separation"><a href="/unpublished/shared-sequencing#proposer-builder-separation"><span class="icon icon-link"></span></a>Proposer builder separation</h3>
<p>As the challenges of decentralizing the sequencer are similar to those of the
<em>Why should we care about fair builder markets?</em></p>
<p>When aiming to decentralize the sequencer, we face similar consensus problems as with a layer one blockchain. This is unless we use the host blockchain itself to determine a transaction ordering</p>
<h3 id="data-availability"><a href="/unpublished/shared-sequencing#data-availability"><span class="icon icon-link"></span></a>Data Availability</h3>
<h3 id="encryption"><a href="/unpublished/shared-sequencing#encryption"><span class="icon icon-link"></span></a>Encryption</h3>
<h2 id="current-state-of-shared-sequencing"><a href="/unpublished/shared-sequencing#current-state-of-shared-sequencing"><span class="icon icon-link"></span></a>Current state of shared sequencing</h2>
<h3 id="overview-of-different-platforms"><a href="/unpublished/shared-sequencing#overview-of-different-platforms"><span class="icon icon-link"></span></a>Overview of different platforms</h3>
<h3 id="rollup-alignment"><a href="/unpublished/shared-sequencing#rollup-alignment"><span class="icon icon-link"></span></a>Rollup alignment</h3>
<h2 id="research-questions-and-outlooks"><a href="/unpublished/shared-sequencing#research-questions-and-outlooks"><span class="icon icon-link"></span></a>Research questions and outlooks</h2>
<h2 id="conclusion"><a href="/unpublished/shared-sequencing#conclusion"><span class="icon icon-link"></span></a>Conclusion</h2></div></div></div></main></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"postData":{"slug":["unpublished","shared-sequencing"],"contentRaw":"\n- [What is shared sequencing?](#what-is-shared-sequencing)\n  - [What is a rollup?](#what-is-a-rollup)\n  - [What is the sequencer's role?](#what-is-the-sequencers-role)\n  - [Why should we care about decentralizing the sequencer?](#why-should-we-care-about-decentralizing-the-sequencer)\n- [Overview of the shared sequencer stack](#overview-of-the-shared-sequencer-stack)\n  - [The sequencing layer](#the-sequencing-layer)\n    - [A rollup agnostic super block](#a-rollup-agnostic-super-block)\n    - [Lazy sequencing](#lazy-sequencing)\n    - [Atomic composability](#atomic-composability)\n  - [Consensus algorithm](#consensus-algorithm)\n  - [Based rollups](#based-rollups)\n  - [Proposer builder separation](#proposer-builder-separation)\n  - [Data Availability](#data-availability)\n  - [Encryption](#encryption)\n- [Current state of shared sequencing](#current-state-of-shared-sequencing)\n  - [Overview of different platforms](#overview-of-different-platforms)\n  - [Rollup alignment](#rollup-alignment)\n- [Research questions and outlooks](#research-questions-and-outlooks)\n- [Conclusion](#conclusion)\n\n# What is shared sequencing?\n\n## What is a rollup?\n\nA rollup chain—a layer 2 blockchain—is a blockchain that builds on top of another host blockchain—the layer 1 blockchain. It can be characterized by a few key points:\n\n1. Builds on top of L1.\n2. Inherits L1 security: Objective finality (fraud proofs or validity proofs).\n3. Liveness guarantees from L1: L1 chain is unlikely to go offline.\n4. Data availability guaranteed through L1: Transactions are posted as calldata or blobs.\n5. Cheaper due to transaction compression, off-chain execution, and small state commits.\n\nThe L2 chain inherits the L1 chain's finality guarantees. Once a fraud proof window has passed or a validity proof has been included in a finalized L1 block, it is automatically finalized as seen by the L2. A double spending attack would require an L1 chain block reorganization.\n\nThe L2 chain also benefits from the host chain's decentralized validator set and economic security in terms of liveness. The L1 chain is unlikely to go offline and censor transactions. In principle, the rollup should be able to continue advancing its state and produce blocks as long as the L1 chain is online.\n\nThe layer 2 blockchain will likely run a layer 1 node in parallel. Since all the relevant layer 2 transaction data is available when syncing the layer 1 node—either through L1 calldata or EIP-4844 data blobs—the state of the layer 2 blockchain can be recomputed entirely by only relying on data from the host blockchain.\n\nRollups benefit from cheaper transaction costs. This is because layer 2 transaction data can be compressed and decompressed off-chain. Also, costly updates to the state database and execution do not happen on the more expensive layer 1 chain. Only every N block/state commits are required to be stored in the host chain's rollup contract.\n\nA big challenge that most rollups face today is meeting the demand for faster finality than L1 for improved user experience. This forces the rollup to use a centralized and trusted sequencer.\n\n## What is the sequencer's role?\n\nWhen a user sends a layer 2 transaction, it is first picked up by the sequencer. The sequencer's job is to commit to a transaction ordering such that the new rollup state can be determined reliably. Once the ordering is set, all other node operators can compute the rollup's new state by applying the deterministic state transition function iteratively producing layer 2 blocks.\n\n![Arbitrum's transaction lifecycle](../../public/data/blog/2023/arbitrum/arbitrum-nitro-whitepaper-transaction.png)\n\n1.  Sequencer receives multiple user transactions\n2.  Sequencer orders these\n3.  Sequencer sends out an ordering promise (feed)\n4.  Batched and compressed transactions are committed to L1 chain\n5.  The L2 transactions are executed off-chain\n6.  The new L2 blocks are confirmed to the L1 chain\n\nThe new state can be computed by running the Nitro Geth fork which also fetches the transaction data from the layer 1 blockchain. The transaction data itself does not necessarily need to be committed to persistent state. It is often only included as transaction calldata to the sequencers ordering commitment such that layer 1 operators are able to fetch and process the transactions. An alternative that has been made possible recently through EIP-4844 is to use data blobs for the transaction data availability.\n\nWhile fraud proving an invalid block is less permissioned, the sequencer is arguably the most centralized component of today's layer 2 rollups.\n\nThe reason that the shared sequencer often is a centralized component today is that it is quite an engineering feat to implement. All other rollup components work deterministic and are clear to compute, whereas decentralizing the sequencer requires an additional consensus algorithm or auctioning mechanism. Along with this come a plethora of fairness, economic security and decentralized coordination questions and concerns. Similar to the advantages of being able to produce the block on a layer 1 blockchain, being able to determine the transaction ordering comes with the ability of extracting user value and transaction censorship.\n\n## Why should we care about decentralizing the sequencer?\n\nBuilding a shared sequencer that is fast, incorruptible and decentralized might seem like a **big engineering undertaking** that probably will come with a slightly **worse user experience**, **additional security risks** and a **loss in autonomy and fees for rollups**. _Why would we even want and care for decentralizing the sequencer?_\n\nAs with many blockchain components, a **central point of failure** is not desirable. The goal is to build censorship resistant and resilient infrastructure that cannot be corrupted in the moment when it counts. Having a centralized component inevitably means that a party with enough influence might be able to corrupt the component if the desire is high enough. This can in the form of a government decree that aims to censor certain users and protocols or by any actor with a shared interest. **Censorship and inclusion delays** can even come from the rollup's sequencer themselves. Further, an accidental server crash or data breach can occur leading to protocol **liveness** issues. Or worse, a sequencer might not fulfill its promise to include pre-committed transactions opening up the possibility of **double spend attacks**.\n\nCurrently, most centralized sequencers handle incoming user transactions via a private transaction mem-pool on a first come first serve basis. Having complete control over the sequencer also means that there is a monopoly on inclusion and ordering pricing. In principle, the sequencer stands to benefit from performing MEV (front and back-running, delaying or including its own transactions) or from selling the block building rights.\n\nIn summary, the following reasons highlight why we would want to move away from a centralized sequencer:\n\n- Censorship resistance\n- Robustness: Liveness\n- Trust requirements\n- Block building rights for all\n\nIf a sequencer is decentralized, there is no need for it to only server one rollup. A decentralized sequencing protocol might as well act as a shared sequencing abstraction layer that multiple rollups can plug into. This opens up the door to the possibility of atomic composability between rollups. Outsourcing the sequencer role for rollups to a shared sequencer service can come with the added benefits of:\n\n- Decentralized sequencing\n- Outsourced development cost\n- Higher code security guarantees\n- Atomic composability\n- Batch posting cost amortization\n\nFurther, some shared sequencer services want to provide even more value, such as:\n\n- Pre-execution privacy (encrypted mem-pool)\n- Subsidized transactions \u0026 MEV revenue share\n- Block builder auctions\n- Reduced costs: Integration with Data Availability layer\n- Guaranteed pre-commits\n- Restaking ability\n\nIt is unclear whether most rollups will be interested in sharing a sequencer. As block building rights can be auctioned off at high prices and can lead to bad user experience, most bigger rollup chains will likely employ their own solutions and either capture and redistribute or use a fair ordering mechanism. Decentralizing the sequencer is currently part of Arbitrum's and Optimism's roadmap. Smaller blockchains with less engineering manpower will be happy to plug in a modular component that offers a decentralized sequencing solution with some added benefit.\n\n# Overview of the shared sequencer stack\n\n## The sequencing layer\n\nWhen talking about integrating a shared/decentralized sequencer into a rollup protocol the idea is to abstract and outsource the entire sequencing process into a \"sequencing layer\".\n\n![Shared sequencing layer](shared-sequencing-layer.svg)\n\n1.  Multiple transactions from multiple rollups are processed by the sequencing layer\n2.  The sequencing layer produces a \"super block\" by some mechanism\n3.  The individual transactions are processed by the respective rollup chains\n\nA _shared sequencer_ can be shared by multiple rollups. Once the infrastructure for a decentralized sequencer has been built it can, at least in theory, easily be plugged into other rollups as well.\n\n### A rollup agnostic super block\n\nA shared sequencer can produce a block containing transactions for multiple rollups. This is sometimes referred to as a \"super block\". A super block is technically not a block, but more of a list of transactions, since the transactions are not actually executed in the sequencing layer. In order to abstract the sequencing layer, it has to be decoupled from the execution layer. If a shared sequencer should be able to handle the ordering of transactions from any kind of rollup, then it inevitably must be agnostic to the rollup's executing virtual machine.\n\n### Lazy sequencing\n\nThis also has the added benefit that the sequencing layer now can solely focus on one thing—the sequencing. Any sequencing mechanism that is dependent on the execution machine will suffer from potential Denial-of-service attack vectors. This is because the sequencers now must also be able to execute and produce blocks from various different rollups requiring running multiple different blockchain node programs in parallel.\n\n### Atomic composability\n\nA desirable property for super blocks is **atomic intra-rollup composability**. For example, a bridging transaction typically involves burning tokens on the source chain and minting them on the target chain. If a shared sequencer has the ability to atomically include transactions from various rollups, then it is also possible to include both a burn and a mint transaction atomically greatly enhancing the bridging experience.\n\nUnfortunately, atomic inclusion does not guarantee atomic execution. This is because of the desired requirement of decoupling the sequencing from the execution layer. A shared sequencer can guarantee the inclusion of both transactions in their respective chains, however it cannot guarantee that these transactions will not fail.\n\nPreviously valid transactions can revert upon actual execution due to state changes in the blockchain. A user might have transferred the tokens out of their wallet or simply increased their account's nonce in the meantime. It would be a serious issue if the burn transaction failed, but the mint transaction succeeded.\n\n## Consensus algorithm\n\nDecentralizing the sequencer comes with the added challenge of reaching consensus in an adversarial setting. A set of distributed nodes needs to be able to agree on the next set of transactions in the presence of faulty and malicious nodes. This is called byzantine fault tolerance (BFT) and remains a core problem to solve for layer one blockchains.\n\nThe previous transaction lifecycle diagram makes it clear that our newly computed state is dependent on the ordered set of transaction inputs. Given these inputs, the rollup's state transition function will deterministically produce L2 blocks and other nodes will always arrive at the same L2 state root. This is also largely much how L1 blockchains work today. Given a list of ordered transactions, a L1 block is executed deterministically to arrive at a new state root.\n\nThe only non-deterministic part of a blockchain's state machine is the list of transactions that make up a block. The challenge lies in coordinating who gets to elect the new block.\n\n## Based rollups\n\nWith all the additional complications that decentralizing the sequencer brings forth, is there no simpler way to reach consensus? There is.. A _based rollup_ simply uses the host chain's consensus mechanism to determine the rollup chain's transaction ordering. This can be achieved by allowing anyone to propose and submit a new block in the rollup's sequencing smart contract. This way, once the host chain's blocks are finalized, a transaction ordering will be determined.\n\n_Why would we still want to consider alternative solutions to based rollups?_\n\nThe transaction confirmation speed of based rollups will always be limited to the host chain's confirmation speed. A centralized sequencer can give out instant pre-commitment confirmations of the transaction ordering, because it is the only leader and it knows it can fulfill the promise. Although this is not implemented by most rollups with a centralized sequencer, these pre-commitments could be accompanied by a verifiable signature and a slashing mechanism in the case that the sequencer breaks its promise. This makes for a great user experience as the confirmation speed is increased at the expense of decentralization.\n\n_Why should we even build on top of an L1 at all?_\n\nUsing a host chain as a base settlement layer can still provide benefits. By leveraging the host chain's execution layer, a rollup's entire fraud proving system can be secured or validity proofs can be verified immediately. Further mechanisms such as slashing can be integrated and benefit from the embedded environment's economic security. Data availability and liveness are still strong arguments for building on top of a well-established layer one chain, although this might change if another consensus mechanism is implemented and data availability services are integrated.\n\n## Proposer builder separation\n\nAs the challenges of decentralizing the sequencer are similar to those of the\n_Why should we care about fair builder markets?_\n\nWhen aiming to decentralize the sequencer, we face similar consensus problems as with a layer one blockchain. This is unless we use the host blockchain itself to determine a transaction ordering\n\n## Data Availability\n\n## Encryption\n\n# Current state of shared sequencing\n\n## Overview of different platforms\n\n## Rollup alignment\n\n# Research questions and outlooks\n\n# Conclusion\n","title":"Shared Sequencing","date":"Apr 24, 2024"}},"__N_SSG":true},"page":"/[...slug]","query":{"slug":["unpublished","shared-sequencing"]},"buildId":"x5f4kHXjRlrAhViHGaz-k","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>